<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sensor Watch: Analog Input</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Sensor Watch<span id="projectnumber">&#160;0.0.2</span>
   </div>
   <div id="projectbrief">A board replacement for the classic Casio F-91W wristwatch, powered by a Microchip SAM L22 microcontroller.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Analog Input</div></div>
</div><!--header-->
<div class="contents">

<p>This section covers functions related to the SAM L22's analog-to-digital converter, as well as configuring and reading values from the five analog-capable pins on the 9-pin connector.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga844283c184c3510635199e50c64304c8" id="r_ga844283c184c3510635199e50c64304c8"><td class="memItemLeft" align="right" valign="top"><a id="ga844283c184c3510635199e50c64304c8" name="ga844283c184c3510635199e50c64304c8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>watch_adc_reference_voltage</b> { <b>ADC_REFERENCE_INTREF</b> = 0
, <b>ADC_REFERENCE_VCC_DIV1POINT6</b>
, <b>ADC_REFERENCE_VCC_DIV2</b>
, <b>ADC_REFERENCE_VCC</b>
 }</td></tr>
<tr class="separator:ga844283c184c3510635199e50c64304c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga908b5334af677309b03d7679d77aaa02" id="r_ga908b5334af677309b03d7679d77aaa02"><td class="memItemLeft" align="right" valign="top"><a id="ga908b5334af677309b03d7679d77aaa02" name="ga908b5334af677309b03d7679d77aaa02"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>watch_enable_adc</b> (void)</td></tr>
<tr class="memdesc:ga908b5334af677309b03d7679d77aaa02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the ADC peripheral. You must call this before attempting to read a value from an analog pin. <br /></td></tr>
<tr class="separator:ga908b5334af677309b03d7679d77aaa02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30a491e9cab049a2812f75862a613aa8" id="r_ga30a491e9cab049a2812f75862a613aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga30a491e9cab049a2812f75862a613aa8">watch_enable_analog_input</a> (const uint8_t pin)</td></tr>
<tr class="memdesc:ga30a491e9cab049a2812f75862a613aa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the selected pin for analog input.  <br /></td></tr>
<tr class="separator:ga30a491e9cab049a2812f75862a613aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2064244f68cff87a1df08f6b07183069" id="r_ga2064244f68cff87a1df08f6b07183069"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga2064244f68cff87a1df08f6b07183069">watch_get_analog_pin_level</a> (const uint8_t pin)</td></tr>
<tr class="memdesc:ga2064244f68cff87a1df08f6b07183069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an analog value from one of the pins.  <br /></td></tr>
<tr class="separator:ga2064244f68cff87a1df08f6b07183069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90bac58a3fa935d8fd640f4b58c8037d" id="r_ga90bac58a3fa935d8fd640f4b58c8037d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga90bac58a3fa935d8fd640f4b58c8037d">watch_set_analog_num_samples</a> (uint16_t samples)</td></tr>
<tr class="memdesc:ga90bac58a3fa935d8fd640f4b58c8037d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of samples to accumulate when measuring a pin level. Default is 16.  <br /></td></tr>
<tr class="separator:ga90bac58a3fa935d8fd640f4b58c8037d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f9ed34e8752e211c1692af473a88dc" id="r_gae9f9ed34e8752e211c1692af473a88dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae9f9ed34e8752e211c1692af473a88dc">watch_set_analog_sampling_length</a> (uint8_t cycles)</td></tr>
<tr class="memdesc:gae9f9ed34e8752e211c1692af473a88dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the length of time spent sampling, which allows measurement of higher impedance inputs. Default is 1.  <br /></td></tr>
<tr class="separator:gae9f9ed34e8752e211c1692af473a88dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ea7b8aef4573f02ff3adafcf891cd93" id="r_ga9ea7b8aef4573f02ff3adafcf891cd93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga9ea7b8aef4573f02ff3adafcf891cd93">watch_set_analog_reference_voltage</a> (watch_adc_reference_voltage reference)</td></tr>
<tr class="memdesc:ga9ea7b8aef4573f02ff3adafcf891cd93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the reference voltage to use for analog readings. Default is ADC_REFERENCE_VCC.  <br /></td></tr>
<tr class="separator:ga9ea7b8aef4573f02ff3adafcf891cd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465fcb058492d350d29fe4403df85b14" id="r_ga465fcb058492d350d29fe4403df85b14"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga465fcb058492d350d29fe4403df85b14">watch_get_vcc_voltage</a> (void)</td></tr>
<tr class="memdesc:ga465fcb058492d350d29fe4403df85b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the voltage of the VCC supply in millivolts (i.e. 3000 mV == 3.0 V). If running on a coin cell, this will be the battery voltage.  <br /></td></tr>
<tr class="separator:ga465fcb058492d350d29fe4403df85b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae38e15840bc5f3eca16ccb782dbb1c31" id="r_gae38e15840bc5f3eca16ccb782dbb1c31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gae38e15840bc5f3eca16ccb782dbb1c31">watch_disable_analog_input</a> (const uint8_t pin)</td></tr>
<tr class="memdesc:gae38e15840bc5f3eca16ccb782dbb1c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the analog circuitry on the selected pin.  <br /></td></tr>
<tr class="separator:gae38e15840bc5f3eca16ccb782dbb1c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf443c79008bec5ceecbd21ad401d52cb" id="r_gaf443c79008bec5ceecbd21ad401d52cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaf443c79008bec5ceecbd21ad401d52cb">watch_disable_adc</a> (void)</td></tr>
<tr class="memdesc:gaf443c79008bec5ceecbd21ad401d52cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the ADC peripheral.  <br /></td></tr>
<tr class="separator:gaf443c79008bec5ceecbd21ad401d52cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This section covers functions related to the SAM L22's analog-to-digital converter, as well as configuring and reading values from the five analog-capable pins on the 9-pin connector. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf443c79008bec5ceecbd21ad401d52cb" name="gaf443c79008bec5ceecbd21ad401d52cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf443c79008bec5ceecbd21ad401d52cb">&#9670;&#160;</a></span>watch_disable_adc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watch_disable_adc </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the ADC peripheral. </p>
<dl class="section note"><dt>Note</dt><dd>You will need to call watch_enable_adc to re-enable the ADC peripheral. When you do, it will have the default settings of 16 samples and 1 measurement cycle; if you customized these parameters, you will need to set them up again. </dd></dl>

</div>
</div>
<a id="gae38e15840bc5f3eca16ccb782dbb1c31" name="gae38e15840bc5f3eca16ccb782dbb1c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae38e15840bc5f3eca16ccb782dbb1c31">&#9670;&#160;</a></span>watch_disable_analog_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watch_disable_analog_input </td>
          <td>(</td>
          <td class="paramtype">const uint8_t</td>          <td class="paramname"><span class="paramname"><em>pin</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the analog circuitry on the selected pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>One of pins A0-A4. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30a491e9cab049a2812f75862a613aa8" name="ga30a491e9cab049a2812f75862a613aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30a491e9cab049a2812f75862a613aa8">&#9670;&#160;</a></span>watch_enable_analog_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watch_enable_analog_input </td>
          <td>(</td>
          <td class="paramtype">const uint8_t</td>          <td class="paramname"><span class="paramname"><em>pin</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the selected pin for analog input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>One of pins A0-A4. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2064244f68cff87a1df08f6b07183069" name="ga2064244f68cff87a1df08f6b07183069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2064244f68cff87a1df08f6b07183069">&#9670;&#160;</a></span>watch_get_analog_pin_level()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t watch_get_analog_pin_level </td>
          <td>(</td>
          <td class="paramtype">const uint8_t</td>          <td class="paramname"><span class="paramname"><em>pin</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an analog value from one of the pins. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>One of pins A0-A4. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a 16-bit unsigned integer from 0-65535 representing the sampled value, unless you have changed the number of samples. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>watch_set_num_analog_samples for details on how that function changes the values returned from this one. </dd></dl>

</div>
</div>
<a id="ga465fcb058492d350d29fe4403df85b14" name="ga465fcb058492d350d29fe4403df85b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga465fcb058492d350d29fe4403df85b14">&#9670;&#160;</a></span>watch_get_vcc_voltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t watch_get_vcc_voltage </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the voltage of the VCC supply in millivolts (i.e. 3000 mV == 3.0 V). If running on a coin cell, this will be the battery voltage. </p>
<p>Unlike other ADC functions, this function does not return a raw value from the ADC, but rather scales it to an actual number of millivolts. This is because the ADC doesn't let us measure VCC per se; it instead lets us measure VCC / 4, and we choose to measure it against the internal reference voltage of 1.024 V. In short, the ADC gives us a number that's complicated to deal with, so we just turn it into a useful number for you :) </p><dl class="section note"><dt>Note</dt><dd>This function depends on INTREF being 1.024V. If you have changed it by poking at the supply controller's VREF.SEL bits, this function will return inaccurate values. </dd></dl>

</div>
</div>
<a id="ga90bac58a3fa935d8fd640f4b58c8037d" name="ga90bac58a3fa935d8fd640f4b58c8037d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90bac58a3fa935d8fd640f4b58c8037d">&#9670;&#160;</a></span>watch_set_analog_num_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watch_set_analog_num_samples </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>samples</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of samples to accumulate when measuring a pin level. Default is 16. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>A power of 2 &lt;= 1024. Specifically: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 or 1024. Any other value will be ignored.</td></tr>
  </table>
  </dd>
</dl>
<p>The SAM L22's ADC has a resolution of 12 bits. By default, the watch configures the ADC to take 16 samples of the analog input and accumulate them in the result register; this effectively gives us a 16-bit resolution, at the cost of taking 16 ADC cycles to complete a measurement. If you are measuring a slowly changing signal like a thermistor output or an ambient light sensor this is probably fine, even desirable. If you are measuring something a bit more fast-paced, like an analog accelerometer, you may wish to exchange precision for speed. In this case you may call this function to configure the ADC to accumulate fewer samples. HOWEVER! Note that this may change the range of values returned from watch_get_analog_pin_level:</p><ul>
<li>For watch_set_num_analog_samples(1), the returned value will be 12 bits (0-4095).</li>
<li>For watch_set_num_analog_samples(2), the returned value will be 13 bits (0-8191).</li>
<li>For watch_set_num_analog_samples(4), the returned value will be 14 bits (0-16383).</li>
<li>For watch_set_num_analog_samples(8), the returned value will be 15 bits (0-32767). For sampling values over 16, the returned value will still be 16 bits (0-65535); the ADC will automatically divide the measured value by whatever factor is necessary to fit the result in 16 bits. <dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga2064244f68cff87a1df08f6b07183069" title="Reads an analog value from one of the pins.">watch_get_analog_pin_level</a> </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ga9ea7b8aef4573f02ff3adafcf891cd93" name="ga9ea7b8aef4573f02ff3adafcf891cd93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ea7b8aef4573f02ff3adafcf891cd93">&#9670;&#160;</a></span>watch_set_analog_reference_voltage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watch_set_analog_reference_voltage </td>
          <td>(</td>
          <td class="paramtype">watch_adc_reference_voltage</td>          <td class="paramname"><span class="paramname"><em>reference</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the reference voltage to use for analog readings. Default is ADC_REFERENCE_VCC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reference</td><td>One of ADC_REFERENCE_VCC, ADC_REFERENCE_VCC_DIV1POINT6, ADC_REFERENCE_VCC_DIV2 or ADC_REFERENCE_INTREF.</td></tr>
  </table>
  </dd>
</dl>
<p>In order to turn an analog voltage into a 16-bit integer, the ADC needs to compare the measured voltage to a reference point. For example, if you were powering the watch with VCC == 3.0V and you had two 10K resistors connected in series from 3V to GND, you could expect to get 3 volts when you measure the top of the voltage divider, 0 volts at the bottom, and 1.5 volts in the middle. If you read these values uising a reference voltage of ADC_REFERENCE_VCC, the top value would be about 65535, the bottom about 0, and the middle about 32768. However! If we used ADC_REFERENCE_VCC_DIV2 as our reference, we would expect to get 65535 both at the top and the middle, because the largest value the ADC can measure in this configutation is 1.5V (VCC / 2).</p>
<p>By changing the reference voltage from ADC_REFERENCE_VCC to ADC_REFERENCE_VCC_DIV1POINT6 or ADC_REFERENCE_VCC_DIV2, you can get more resolution when measuring small voltages (i.e. a phototransistor circuit in low light).</p>
<p>There is also a special reference voltage called ADC_REFERENCE_INTREF. The SAM L22's Supply Controller provides a selectable voltage reference (by default, 1.024 V) that you can select as a reference voltage for ADC conversions. Unlike the three references we talked about in the last paragraph, this reference voltage does not depend on VCC, which makes it very useful for measuring the battery voltage (since you can't really compare VCC to itself). You can change the INTREF voltage to 2.048 or 4.096 V by poking at the supply controller's VREF register, but the watch library does not support this use case. </p>

</div>
</div>
<a id="gae9f9ed34e8752e211c1692af473a88dc" name="gae9f9ed34e8752e211c1692af473a88dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9f9ed34e8752e211c1692af473a88dc">&#9670;&#160;</a></span>watch_set_analog_sampling_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watch_set_analog_sampling_length </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>cycles</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the length of time spent sampling, which allows measurement of higher impedance inputs. Default is 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cycles</td><td>The number of ADC cycles to sample, between 1 and 64. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>this article by Thea Flowers: <a href="https://blog.thea.codes/getting-the-most-out-of-the-samd21-adc/">https://blog.thea.codes/getting-the-most-out-of-the-samd21-adc/</a> which is where I learned all of this.</dd></dl>
<p>To measure an analog value, the SAM L22 must charge a capacitor to the analog voltage presented at the input. This takes time. Importantly, the higher the input impedance, the more time this takes. As a basic example: if you are using a thermistor tied to VCC to measure temperature, the capacitor has to charge through the thermistor. The higher the resistor value, the higher the input impedance, and the more time we need to allow for the measurement. By default, the ADC is configured to run on a 500 kHz clock with a sample time of one cycle. This is appropriate for an input impedance up to about 28kΩ. Setting the sampling time to 4 cycles allows for an input impedance up to 123kΩ. Setting the sampling time to the maximum of 64 cycles theoretically allows for input impedance up to 2 MΩ. (I based these numbers on the calculator in the linked blog post; it also has a ton of great info on the SAM D21 ADC, which is similar to the SAM L22's). </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
