#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define _STDIO_H 1

#define _FEATURES_H 1

#define _DEFAULT_SOURCE 1

#define __GLIBC_USE_ISOC2X 0

#define __USE_ISOC11 1

#define __USE_ISOC99 1

#define __USE_ISOC95 1

#define __USE_POSIX_IMPLICITLY 1

#define _POSIX_SOURCE 1

#define _POSIX_C_SOURCE 200809

#define __USE_POSIX 1

#define __USE_POSIX2 1

#define __USE_POSIX199309 1

#define __USE_POSIX199506 1

#define __USE_XOPEN2K 1

#define __USE_XOPEN2K8 1

#define _ATFILE_SOURCE 1

#define __USE_MISC 1

#define __USE_ATFILE 1

#define __USE_FORTIFY_LEVEL 0

#define __GLIBC_USE_DEPRECATED_GETS 0

#define __GLIBC_USE_DEPRECATED_SCANF 0

#define _STDC_PREDEF_H 1

#define __STDC_IEC_559__ 1

#define __STDC_IEC_559_COMPLEX__ 1

#define __STDC_ISO_10646__ 201706

#define __GNU_LIBRARY__ 6

#define __GLIBC__ 2

#define __GLIBC_MINOR__ 31

#define _SYS_CDEFS_H 1

#define __glibc_c99_flexarr_available 1

#define __WORDSIZE 64

#define __WORDSIZE_TIME64_COMPAT32 1

#define __SYSCALL_WORDSIZE 64

#define __LONG_DOUBLE_USES_FLOAT128 0

#define __HAVE_GENERIC_SELECTION 1

#define __GLIBC_USE_LIB_EXT2 0

#define __GLIBC_USE_IEC_60559_BFP_EXT 0

#define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0

#define __GLIBC_USE_IEC_60559_FUNCS_EXT 0

#define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0

#define __GLIBC_USE_IEC_60559_TYPES_EXT 0

#define __GNUC_VA_LIST 1

#define _BITS_TYPES_H 1

#define __TIMESIZE 64

#define _BITS_TYPESIZES_H 1

#define __OFF_T_MATCHES_OFF64_T 1

#define __INO_T_MATCHES_INO64_T 1

#define __RLIM_T_MATCHES_RLIM64_T 1

#define __STATFS_MATCHES_STATFS64 1

#define __FD_SETSIZE 1024

#define _BITS_TIME64_H 1

#define _____fpos_t_defined 1

#define ____mbstate_t_defined 1

#define _____fpos64_t_defined 1

#define ____FILE_defined 1

#define __FILE_defined 1

#define __struct_FILE_defined 1

#define _IO_EOF_SEEN 16

#define _IO_ERR_SEEN 32

#define _IO_USER_LOCK 32768

#define _IOFBF 0

#define _IOLBF 1

#define _IONBF 2

#define BUFSIZ 8192

#define EOF -1

#define SEEK_SET 0

#define SEEK_CUR 1

#define SEEK_END 2

#define _BITS_STDIO_LIM_H 1

#define L_tmpnam 20

#define TMP_MAX 238328

#define FILENAME_MAX 4096

#define L_ctermid 9

#define FOPEN_MAX 16

#define true_ 1

#define false_ 0

#define __bool_true_false_are_defined 1

#define _STDINT_H 1

#define _BITS_WCHAR_H 1

#define _BITS_STDINT_INTN_H 1

#define _BITS_STDINT_UINTN_H 1

#define INT8_MIN -128

#define INT16_MIN -32768

#define INT32_MIN -2147483648

#define INT8_MAX 127

#define INT16_MAX 32767

#define INT32_MAX 2147483647

#define UINT8_MAX 255

#define UINT16_MAX 65535

#define UINT32_MAX 4294967295

#define INT_LEAST8_MIN -128

#define INT_LEAST16_MIN -32768

#define INT_LEAST32_MIN -2147483648

#define INT_LEAST8_MAX 127

#define INT_LEAST16_MAX 32767

#define INT_LEAST32_MAX 2147483647

#define UINT_LEAST8_MAX 255

#define UINT_LEAST16_MAX 65535

#define UINT_LEAST32_MAX 4294967295

#define INT_FAST8_MIN -128

#define INT_FAST16_MIN -9223372036854775808ull

#define INT_FAST32_MIN -9223372036854775808ull

#define INT_FAST8_MAX 127

#define INT_FAST16_MAX 9223372036854775807

#define INT_FAST32_MAX 9223372036854775807

#define UINT_FAST8_MAX 255

#define UINT_FAST16_MAX -1

#define UINT_FAST32_MAX -1

#define INTPTR_MIN -9223372036854775808ull

#define INTPTR_MAX 9223372036854775807

#define UINTPTR_MAX -1

#define PTRDIFF_MIN -9223372036854775808ull

#define PTRDIFF_MAX 9223372036854775807

#define SIG_ATOMIC_MIN -2147483648

#define SIG_ATOMIC_MAX 2147483647

#define SIZE_MAX -1

#define WINT_MIN 0

#define WINT_MAX 4294967295

#define GPIO_PIN_FUNCTION_A 0

#define GPIO_PIN_FUNCTION_B 1

#define GPIO_PIN_FUNCTION_C 2

#define GPIO_PIN_FUNCTION_D 3

#define GPIO_PIN_FUNCTION_E 4

#define GPIO_PIN_FUNCTION_F 5

#define GPIO_PIN_FUNCTION_G 6

#define GPIO_PIN_FUNCTION_H 7

#define GPIO_PIN_FUNCTION_I 8

#define WATCH_BTN_ALARM_EIC_CHANNEL 2

#define WATCH_BTN_LIGHT_EIC_CHANNEL 6

#define WATCH_BTN_MODE_EIC_CHANNEL 7

#define WATCH_BUZZER_TCC_CHANNEL 1

#define WATCH_RED_TCC_CHANNEL 2

#define WATCH_GREEN_TCC_CHANNEL 3

#define WATCH_A0_EIC_CHANNEL 4

#define WATCH_A1_EIC_CHANNEL 1

#define WATCH_A2_EIC_CHANNEL 2

#define WATCH_A3_EIC_CHANNEL 3

#define WATCH_A4_EIC_CHANNEL 0

#define __CM0PLUS_REV 1

#define __MPU_PRESENT 1

#define __NVIC_PRIO_BITS 2

#define __VTOR_PRESENT 1

#define __Vendor_SysTickConfig 0

#define __CM0PLUS_CMSIS_VERSION_MAIN 4

#define __CM0PLUS_CMSIS_VERSION_SUB 0

#define __CM0PLUS_CMSIS_VERSION 262144

#define __CORTEX_M 0

#define __FPU_USED 0

#define SCB_CPUID_IMPLEMENTER_Pos 24

#define SCB_CPUID_IMPLEMENTER_Msk 4278190080

#define SCB_CPUID_VARIANT_Pos 20

#define SCB_CPUID_VARIANT_Msk 15728640

#define SCB_CPUID_ARCHITECTURE_Pos 16

#define SCB_CPUID_ARCHITECTURE_Msk 983040

#define SCB_CPUID_PARTNO_Pos 4

#define SCB_CPUID_PARTNO_Msk 65520

#define SCB_CPUID_REVISION_Pos 0

#define SCB_CPUID_REVISION_Msk 15

#define SCB_ICSR_NMIPENDSET_Pos 31

#define SCB_ICSR_NMIPENDSET_Msk 2147483648

#define SCB_ICSR_PENDSVSET_Pos 28

#define SCB_ICSR_PENDSVSET_Msk 268435456

#define SCB_ICSR_PENDSVCLR_Pos 27

#define SCB_ICSR_PENDSVCLR_Msk 134217728

#define SCB_ICSR_PENDSTSET_Pos 26

#define SCB_ICSR_PENDSTSET_Msk 67108864

#define SCB_ICSR_PENDSTCLR_Pos 25

#define SCB_ICSR_PENDSTCLR_Msk 33554432

#define SCB_ICSR_ISRPREEMPT_Pos 23

#define SCB_ICSR_ISRPREEMPT_Msk 8388608

#define SCB_ICSR_ISRPENDING_Pos 22

#define SCB_ICSR_ISRPENDING_Msk 4194304

#define SCB_ICSR_VECTPENDING_Pos 12

#define SCB_ICSR_VECTPENDING_Msk 2093056

#define SCB_ICSR_VECTACTIVE_Pos 0

#define SCB_ICSR_VECTACTIVE_Msk 511

#define SCB_VTOR_TBLOFF_Pos 8

#define SCB_VTOR_TBLOFF_Msk 4294967040

#define SCB_AIRCR_VECTKEY_Pos 16

#define SCB_AIRCR_VECTKEY_Msk 4294901760

#define SCB_AIRCR_VECTKEYSTAT_Pos 16

#define SCB_AIRCR_VECTKEYSTAT_Msk 4294901760

#define SCB_AIRCR_ENDIANESS_Pos 15

#define SCB_AIRCR_ENDIANESS_Msk 32768

#define SCB_AIRCR_SYSRESETREQ_Pos 2

#define SCB_AIRCR_SYSRESETREQ_Msk 4

#define SCB_AIRCR_VECTCLRACTIVE_Pos 1

#define SCB_AIRCR_VECTCLRACTIVE_Msk 2

#define SCB_SCR_SEVONPEND_Pos 4

#define SCB_SCR_SEVONPEND_Msk 16

#define SCB_SCR_SLEEPDEEP_Pos 2

#define SCB_SCR_SLEEPDEEP_Msk 4

#define SCB_SCR_SLEEPONEXIT_Pos 1

#define SCB_SCR_SLEEPONEXIT_Msk 2

#define SCB_CCR_STKALIGN_Pos 9

#define SCB_CCR_STKALIGN_Msk 512

#define SCB_CCR_UNALIGN_TRP_Pos 3

#define SCB_CCR_UNALIGN_TRP_Msk 8

#define SCB_SHCSR_SVCALLPENDED_Pos 15

#define SCB_SHCSR_SVCALLPENDED_Msk 32768

#define SysTick_CTRL_COUNTFLAG_Pos 16

#define SysTick_CTRL_COUNTFLAG_Msk 65536

#define SysTick_CTRL_CLKSOURCE_Pos 2

#define SysTick_CTRL_CLKSOURCE_Msk 4

#define SysTick_CTRL_TICKINT_Pos 1

#define SysTick_CTRL_TICKINT_Msk 2

#define SysTick_CTRL_ENABLE_Pos 0

#define SysTick_CTRL_ENABLE_Msk 1

#define SysTick_LOAD_RELOAD_Pos 0

#define SysTick_LOAD_RELOAD_Msk 16777215

#define SysTick_VAL_CURRENT_Pos 0

#define SysTick_VAL_CURRENT_Msk 16777215

#define SysTick_CALIB_NOREF_Pos 31

#define SysTick_CALIB_NOREF_Msk 2147483648

#define SysTick_CALIB_SKEW_Pos 30

#define SysTick_CALIB_SKEW_Msk 1073741824

#define SysTick_CALIB_TENMS_Pos 0

#define SysTick_CALIB_TENMS_Msk 16777215

#define MPU_TYPE_IREGION_Pos 16

#define MPU_TYPE_IREGION_Msk 16711680

#define MPU_TYPE_DREGION_Pos 8

#define MPU_TYPE_DREGION_Msk 65280

#define MPU_TYPE_SEPARATE_Pos 0

#define MPU_TYPE_SEPARATE_Msk 1

#define MPU_CTRL_PRIVDEFENA_Pos 2

#define MPU_CTRL_PRIVDEFENA_Msk 4

#define MPU_CTRL_HFNMIENA_Pos 1

#define MPU_CTRL_HFNMIENA_Msk 2

#define MPU_CTRL_ENABLE_Pos 0

#define MPU_CTRL_ENABLE_Msk 1

#define MPU_RNR_REGION_Pos 0

#define MPU_RNR_REGION_Msk 255

#define MPU_RBAR_ADDR_Pos 8

#define MPU_RBAR_ADDR_Msk 4294967040

#define MPU_RBAR_VALID_Pos 4

#define MPU_RBAR_VALID_Msk 16

#define MPU_RBAR_REGION_Pos 0

#define MPU_RBAR_REGION_Msk 15

#define MPU_RASR_ATTRS_Pos 16

#define MPU_RASR_ATTRS_Msk 4294901760

#define MPU_RASR_XN_Pos 28

#define MPU_RASR_XN_Msk 268435456

#define MPU_RASR_AP_Pos 24

#define MPU_RASR_AP_Msk 117440512

#define MPU_RASR_TEX_Pos 19

#define MPU_RASR_TEX_Msk 3670016

#define MPU_RASR_S_Pos 18

#define MPU_RASR_S_Msk 262144

#define MPU_RASR_C_Pos 17

#define MPU_RASR_C_Msk 131072

#define MPU_RASR_B_Pos 16

#define MPU_RASR_B_Msk 65536

#define MPU_RASR_SRD_Pos 8

#define MPU_RASR_SRD_Msk 65280

#define MPU_RASR_SIZE_Pos 1

#define MPU_RASR_SIZE_Msk 62

#define MPU_RASR_ENABLE_Pos 0

#define MPU_RASR_ENABLE_Msk 1

#define SCS_BASE 3758153728

#define SysTick_BASE 3758153744

#define NVIC_BASE 3758153984

#define SCB_BASE 3758157056

#define MPU_BASE 3758157200

#define REV_AC 257

#define AC_CTRLA_OFFSET 0

#define AC_CTRLA_SWRST_Pos 0

#define AC_CTRLA_ENABLE_Pos 1

#define AC_CTRLB_OFFSET 1

#define AC_CTRLB_START0_Pos 0

#define AC_CTRLB_START1_Pos 1

#define AC_CTRLB_START_Pos 0

#define AC_EVCTRL_OFFSET 2

#define AC_EVCTRL_COMPEO0_Pos 0

#define AC_EVCTRL_COMPEO1_Pos 1

#define AC_EVCTRL_COMPEO_Pos 0

#define AC_EVCTRL_WINEO0_Pos 4

#define AC_EVCTRL_WINEO_Pos 4

#define AC_EVCTRL_COMPEI0_Pos 8

#define AC_EVCTRL_COMPEI1_Pos 9

#define AC_EVCTRL_COMPEI_Pos 8

#define AC_EVCTRL_INVEI0_Pos 12

#define AC_EVCTRL_INVEI1_Pos 13

#define AC_EVCTRL_INVEI_Pos 12

#define AC_INTENCLR_OFFSET 4

#define AC_INTENCLR_COMP0_Pos 0

#define AC_INTENCLR_COMP1_Pos 1

#define AC_INTENCLR_COMP_Pos 0

#define AC_INTENCLR_WIN0_Pos 4

#define AC_INTENCLR_WIN_Pos 4

#define AC_INTENSET_OFFSET 5

#define AC_INTENSET_COMP0_Pos 0

#define AC_INTENSET_COMP1_Pos 1

#define AC_INTENSET_COMP_Pos 0

#define AC_INTENSET_WIN0_Pos 4

#define AC_INTENSET_WIN_Pos 4

#define AC_INTFLAG_OFFSET 6

#define AC_INTFLAG_COMP0_Pos 0

#define AC_INTFLAG_COMP1_Pos 1

#define AC_INTFLAG_COMP_Pos 0

#define AC_INTFLAG_WIN0_Pos 4

#define AC_INTFLAG_WIN_Pos 4

#define AC_STATUSA_OFFSET 7

#define AC_STATUSA_STATE0_Pos 0

#define AC_STATUSA_STATE1_Pos 1

#define AC_STATUSA_STATE_Pos 0

#define AC_STATUSA_WSTATE0_Pos 4

#define AC_STATUSB_OFFSET 8

#define AC_STATUSB_READY0_Pos 0

#define AC_STATUSB_READY1_Pos 1

#define AC_STATUSB_READY_Pos 0

#define AC_DBGCTRL_OFFSET 9

#define AC_DBGCTRL_DBGRUN_Pos 0

#define AC_WINCTRL_OFFSET 10

#define AC_WINCTRL_WEN0_Pos 0

#define AC_WINCTRL_WINTSEL0_Pos 1

#define AC_SCALER_OFFSET 12

#define AC_SCALER_VALUE_Pos 0

#define AC_COMPCTRL_OFFSET 16

#define AC_COMPCTRL_ENABLE_Pos 1

#define AC_COMPCTRL_SINGLE_Pos 2

#define AC_COMPCTRL_INTSEL_Pos 3

#define AC_COMPCTRL_RUNSTDBY_Pos 6

#define AC_COMPCTRL_MUXNEG_Pos 8

#define AC_COMPCTRL_MUXPOS_Pos 12

#define AC_COMPCTRL_SWAP_Pos 15

#define AC_COMPCTRL_SPEED_Pos 16

#define AC_COMPCTRL_HYSTEN_Pos 19

#define AC_COMPCTRL_HYST_Pos 20

#define AC_COMPCTRL_FLEN_Pos 24

#define AC_COMPCTRL_OUT_Pos 28

#define AC_SYNCBUSY_OFFSET 32

#define AC_SYNCBUSY_SWRST_Pos 0

#define AC_SYNCBUSY_ENABLE_Pos 1

#define AC_SYNCBUSY_WINCTRL_Pos 2

#define AC_SYNCBUSY_COMPCTRL0_Pos 3

#define AC_SYNCBUSY_COMPCTRL1_Pos 4

#define AC_SYNCBUSY_COMPCTRL_Pos 3

#define REV_ADC 528

#define ADC_CTRLA_OFFSET 0

#define ADC_CTRLA_SWRST_Pos 0

#define ADC_CTRLA_ENABLE_Pos 1

#define ADC_CTRLA_RUNSTDBY_Pos 6

#define ADC_CTRLA_ONDEMAND_Pos 7

#define ADC_CTRLB_OFFSET 1

#define ADC_CTRLB_PRESCALER_Pos 0

#define ADC_REFCTRL_OFFSET 2

#define ADC_REFCTRL_REFSEL_Pos 0

#define ADC_REFCTRL_REFCOMP_Pos 7

#define ADC_EVCTRL_OFFSET 3

#define ADC_EVCTRL_FLUSHEI_Pos 0

#define ADC_EVCTRL_STARTEI_Pos 1

#define ADC_EVCTRL_FLUSHINV_Pos 2

#define ADC_EVCTRL_STARTINV_Pos 3

#define ADC_EVCTRL_RESRDYEO_Pos 4

#define ADC_EVCTRL_WINMONEO_Pos 5

#define ADC_INTENCLR_OFFSET 4

#define ADC_INTENCLR_RESRDY_Pos 0

#define ADC_INTENCLR_OVERRUN_Pos 1

#define ADC_INTENCLR_WINMON_Pos 2

#define ADC_INTENSET_OFFSET 5

#define ADC_INTENSET_RESRDY_Pos 0

#define ADC_INTENSET_OVERRUN_Pos 1

#define ADC_INTENSET_WINMON_Pos 2

#define ADC_INTFLAG_OFFSET 6

#define ADC_INTFLAG_RESRDY_Pos 0

#define ADC_INTFLAG_OVERRUN_Pos 1

#define ADC_INTFLAG_WINMON_Pos 2

#define ADC_SEQSTATUS_OFFSET 7

#define ADC_SEQSTATUS_SEQSTATE_Pos 0

#define ADC_SEQSTATUS_SEQBUSY_Pos 7

#define ADC_INPUTCTRL_OFFSET 8

#define ADC_INPUTCTRL_MUXPOS_Pos 0

#define ADC_INPUTCTRL_MUXNEG_Pos 8

#define ADC_CTRLC_OFFSET 10

#define ADC_CTRLC_DIFFMODE_Pos 0

#define ADC_CTRLC_LEFTADJ_Pos 1

#define ADC_CTRLC_FREERUN_Pos 2

#define ADC_CTRLC_CORREN_Pos 3

#define ADC_CTRLC_RESSEL_Pos 4

#define ADC_CTRLC_R2R_Pos 7

#define ADC_CTRLC_WINMODE_Pos 8

#define ADC_CTRLC_DUALSEL_Pos 12

#define ADC_AVGCTRL_OFFSET 12

#define ADC_AVGCTRL_SAMPLENUM_Pos 0

#define ADC_AVGCTRL_ADJRES_Pos 4

#define ADC_SAMPCTRL_OFFSET 13

#define ADC_SAMPCTRL_SAMPLEN_Pos 0

#define ADC_SAMPCTRL_OFFCOMP_Pos 7

#define ADC_WINLT_OFFSET 14

#define ADC_WINLT_WINLT_Pos 0

#define ADC_WINUT_OFFSET 16

#define ADC_WINUT_WINUT_Pos 0

#define ADC_GAINCORR_OFFSET 18

#define ADC_GAINCORR_GAINCORR_Pos 0

#define ADC_OFFSETCORR_OFFSET 20

#define ADC_OFFSETCORR_OFFSETCORR_Pos 0

#define ADC_SWTRIG_OFFSET 24

#define ADC_SWTRIG_FLUSH_Pos 0

#define ADC_SWTRIG_START_Pos 1

#define ADC_DBGCTRL_OFFSET 28

#define ADC_DBGCTRL_DBGRUN_Pos 0

#define ADC_SYNCBUSY_OFFSET 32

#define ADC_SYNCBUSY_SWRST_Pos 0

#define ADC_SYNCBUSY_ENABLE_Pos 1

#define ADC_SYNCBUSY_INPUTCTRL_Pos 2

#define ADC_SYNCBUSY_CTRLC_Pos 3

#define ADC_SYNCBUSY_AVGCTRL_Pos 4

#define ADC_SYNCBUSY_SAMPCTRL_Pos 5

#define ADC_SYNCBUSY_WINLT_Pos 6

#define ADC_SYNCBUSY_WINUT_Pos 7

#define ADC_SYNCBUSY_GAINCORR_Pos 8

#define ADC_SYNCBUSY_OFFSETCORR_Pos 9

#define ADC_SYNCBUSY_SWTRIG_Pos 10

#define ADC_RESULT_OFFSET 36

#define ADC_RESULT_RESULT_Pos 0

#define ADC_SEQCTRL_OFFSET 40

#define ADC_SEQCTRL_SEQEN_Pos 0

#define ADC_CALIB_OFFSET 44

#define ADC_CALIB_BIASCOMP_Pos 0

#define ADC_CALIB_BIASREFBUF_Pos 8

#define REV_AES 528

#define AES_CTRLA_OFFSET 0

#define AES_CTRLA_SWRST_Pos 0

#define AES_CTRLA_ENABLE_Pos 1

#define AES_CTRLA_AESMODE_Pos 2

#define AES_CTRLA_CFBS_Pos 5

#define AES_CTRLA_KEYSIZE_Pos 8

#define AES_CTRLA_CIPHER_Pos 10

#define AES_CTRLA_STARTMODE_Pos 11

#define AES_CTRLA_LOD_Pos 12

#define AES_CTRLA_KEYGEN_Pos 13

#define AES_CTRLA_XORKEY_Pos 14

#define AES_CTRLA_CTYPE_Pos 16

#define AES_CTRLB_OFFSET 4

#define AES_CTRLB_START_Pos 0

#define AES_CTRLB_NEWMSG_Pos 1

#define AES_CTRLB_EOM_Pos 2

#define AES_CTRLB_GFMUL_Pos 3

#define AES_INTENCLR_OFFSET 5

#define AES_INTENCLR_ENCCMP_Pos 0

#define AES_INTENCLR_GFMCMP_Pos 1

#define AES_INTENSET_OFFSET 6

#define AES_INTENSET_ENCCMP_Pos 0

#define AES_INTENSET_GFMCMP_Pos 1

#define AES_INTFLAG_OFFSET 7

#define AES_INTFLAG_ENCCMP_Pos 0

#define AES_INTFLAG_GFMCMP_Pos 1

#define AES_DATABUFPTR_OFFSET 8

#define AES_DATABUFPTR_INDATAPTR_Pos 0

#define AES_DBGCTRL_OFFSET 9

#define AES_DBGCTRL_DBGRUN_Pos 0

#define AES_KEYWORD_OFFSET 12

#define AES_INDATA_OFFSET 56

#define AES_INTVECTV_OFFSET 60

#define AES_HASHKEY_OFFSET 92

#define AES_GHASH_OFFSET 108

#define AES_CIPLEN_OFFSET 128

#define AES_RANDSEED_OFFSET 132

#define REV_CCL 257

#define CCL_CTRL_OFFSET 0

#define CCL_CTRL_SWRST_Pos 0

#define CCL_CTRL_ENABLE_Pos 1

#define CCL_CTRL_RUNSTDBY_Pos 6

#define CCL_SEQCTRL_OFFSET 4

#define CCL_SEQCTRL_SEQSEL_Pos 0

#define CCL_LUTCTRL_OFFSET 8

#define CCL_LUTCTRL_ENABLE_Pos 1

#define CCL_LUTCTRL_FILTSEL_Pos 4

#define CCL_LUTCTRL_EDGESEL_Pos 7

#define CCL_LUTCTRL_INSEL0_Pos 8

#define CCL_LUTCTRL_INSEL1_Pos 12

#define CCL_LUTCTRL_INSEL2_Pos 16

#define CCL_LUTCTRL_INVEI_Pos 20

#define CCL_LUTCTRL_LUTEI_Pos 21

#define CCL_LUTCTRL_LUTEO_Pos 22

#define CCL_LUTCTRL_TRUTH_Pos 24

#define REV_DMAC 546

#define DMAC_CTRL_OFFSET 0

#define DMAC_CTRL_SWRST_Pos 0

#define DMAC_CTRL_DMAENABLE_Pos 1

#define DMAC_CTRL_CRCENABLE_Pos 2

#define DMAC_CTRL_LVLEN0_Pos 8

#define DMAC_CTRL_LVLEN1_Pos 9

#define DMAC_CTRL_LVLEN2_Pos 10

#define DMAC_CTRL_LVLEN3_Pos 11

#define DMAC_CTRL_LVLEN_Pos 8

#define DMAC_CRCCTRL_OFFSET 2

#define DMAC_CRCCTRL_CRCBEATSIZE_Pos 0

#define DMAC_CRCCTRL_CRCPOLY_Pos 2

#define DMAC_CRCCTRL_CRCSRC_Pos 8

#define DMAC_CRCDATAIN_OFFSET 4

#define DMAC_CRCDATAIN_CRCDATAIN_Pos 0

#define DMAC_CRCCHKSUM_OFFSET 8

#define DMAC_CRCCHKSUM_CRCCHKSUM_Pos 0

#define DMAC_CRCSTATUS_OFFSET 12

#define DMAC_CRCSTATUS_CRCBUSY_Pos 0

#define DMAC_CRCSTATUS_CRCZERO_Pos 1

#define DMAC_DBGCTRL_OFFSET 13

#define DMAC_DBGCTRL_DBGRUN_Pos 0

#define DMAC_QOSCTRL_OFFSET 14

#define DMAC_QOSCTRL_WRBQOS_Pos 0

#define DMAC_QOSCTRL_FQOS_Pos 2

#define DMAC_QOSCTRL_DQOS_Pos 4

#define DMAC_SWTRIGCTRL_OFFSET 16

#define DMAC_SWTRIGCTRL_SWTRIG0_Pos 0

#define DMAC_SWTRIGCTRL_SWTRIG1_Pos 1

#define DMAC_SWTRIGCTRL_SWTRIG2_Pos 2

#define DMAC_SWTRIGCTRL_SWTRIG3_Pos 3

#define DMAC_SWTRIGCTRL_SWTRIG4_Pos 4

#define DMAC_SWTRIGCTRL_SWTRIG5_Pos 5

#define DMAC_SWTRIGCTRL_SWTRIG6_Pos 6

#define DMAC_SWTRIGCTRL_SWTRIG7_Pos 7

#define DMAC_SWTRIGCTRL_SWTRIG8_Pos 8

#define DMAC_SWTRIGCTRL_SWTRIG9_Pos 9

#define DMAC_SWTRIGCTRL_SWTRIG10_Pos 10

#define DMAC_SWTRIGCTRL_SWTRIG11_Pos 11

#define DMAC_SWTRIGCTRL_SWTRIG12_Pos 12

#define DMAC_SWTRIGCTRL_SWTRIG13_Pos 13

#define DMAC_SWTRIGCTRL_SWTRIG14_Pos 14

#define DMAC_SWTRIGCTRL_SWTRIG15_Pos 15

#define DMAC_SWTRIGCTRL_SWTRIG_Pos 0

#define DMAC_PRICTRL0_OFFSET 20

#define DMAC_PRICTRL0_LVLPRI0_Pos 0

#define DMAC_PRICTRL0_RRLVLEN0_Pos 7

#define DMAC_PRICTRL0_LVLPRI1_Pos 8

#define DMAC_PRICTRL0_RRLVLEN1_Pos 15

#define DMAC_PRICTRL0_LVLPRI2_Pos 16

#define DMAC_PRICTRL0_RRLVLEN2_Pos 23

#define DMAC_PRICTRL0_LVLPRI3_Pos 24

#define DMAC_PRICTRL0_RRLVLEN3_Pos 31

#define DMAC_INTPEND_OFFSET 32

#define DMAC_INTPEND_ID_Pos 0

#define DMAC_INTPEND_TERR_Pos 8

#define DMAC_INTPEND_TCMPL_Pos 9

#define DMAC_INTPEND_SUSP_Pos 10

#define DMAC_INTPEND_FERR_Pos 13

#define DMAC_INTPEND_BUSY_Pos 14

#define DMAC_INTPEND_PEND_Pos 15

#define DMAC_INTSTATUS_OFFSET 36

#define DMAC_INTSTATUS_CHINT0_Pos 0

#define DMAC_INTSTATUS_CHINT1_Pos 1

#define DMAC_INTSTATUS_CHINT2_Pos 2

#define DMAC_INTSTATUS_CHINT3_Pos 3

#define DMAC_INTSTATUS_CHINT4_Pos 4

#define DMAC_INTSTATUS_CHINT5_Pos 5

#define DMAC_INTSTATUS_CHINT6_Pos 6

#define DMAC_INTSTATUS_CHINT7_Pos 7

#define DMAC_INTSTATUS_CHINT8_Pos 8

#define DMAC_INTSTATUS_CHINT9_Pos 9

#define DMAC_INTSTATUS_CHINT10_Pos 10

#define DMAC_INTSTATUS_CHINT11_Pos 11

#define DMAC_INTSTATUS_CHINT12_Pos 12

#define DMAC_INTSTATUS_CHINT13_Pos 13

#define DMAC_INTSTATUS_CHINT14_Pos 14

#define DMAC_INTSTATUS_CHINT15_Pos 15

#define DMAC_INTSTATUS_CHINT_Pos 0

#define DMAC_BUSYCH_OFFSET 40

#define DMAC_BUSYCH_BUSYCH0_Pos 0

#define DMAC_BUSYCH_BUSYCH1_Pos 1

#define DMAC_BUSYCH_BUSYCH2_Pos 2

#define DMAC_BUSYCH_BUSYCH3_Pos 3

#define DMAC_BUSYCH_BUSYCH4_Pos 4

#define DMAC_BUSYCH_BUSYCH5_Pos 5

#define DMAC_BUSYCH_BUSYCH6_Pos 6

#define DMAC_BUSYCH_BUSYCH7_Pos 7

#define DMAC_BUSYCH_BUSYCH8_Pos 8

#define DMAC_BUSYCH_BUSYCH9_Pos 9

#define DMAC_BUSYCH_BUSYCH10_Pos 10

#define DMAC_BUSYCH_BUSYCH11_Pos 11

#define DMAC_BUSYCH_BUSYCH12_Pos 12

#define DMAC_BUSYCH_BUSYCH13_Pos 13

#define DMAC_BUSYCH_BUSYCH14_Pos 14

#define DMAC_BUSYCH_BUSYCH15_Pos 15

#define DMAC_BUSYCH_BUSYCH_Pos 0

#define DMAC_PENDCH_OFFSET 44

#define DMAC_PENDCH_PENDCH0_Pos 0

#define DMAC_PENDCH_PENDCH1_Pos 1

#define DMAC_PENDCH_PENDCH2_Pos 2

#define DMAC_PENDCH_PENDCH3_Pos 3

#define DMAC_PENDCH_PENDCH4_Pos 4

#define DMAC_PENDCH_PENDCH5_Pos 5

#define DMAC_PENDCH_PENDCH6_Pos 6

#define DMAC_PENDCH_PENDCH7_Pos 7

#define DMAC_PENDCH_PENDCH8_Pos 8

#define DMAC_PENDCH_PENDCH9_Pos 9

#define DMAC_PENDCH_PENDCH10_Pos 10

#define DMAC_PENDCH_PENDCH11_Pos 11

#define DMAC_PENDCH_PENDCH12_Pos 12

#define DMAC_PENDCH_PENDCH13_Pos 13

#define DMAC_PENDCH_PENDCH14_Pos 14

#define DMAC_PENDCH_PENDCH15_Pos 15

#define DMAC_PENDCH_PENDCH_Pos 0

#define DMAC_ACTIVE_OFFSET 48

#define DMAC_ACTIVE_LVLEX0_Pos 0

#define DMAC_ACTIVE_LVLEX1_Pos 1

#define DMAC_ACTIVE_LVLEX2_Pos 2

#define DMAC_ACTIVE_LVLEX3_Pos 3

#define DMAC_ACTIVE_LVLEX_Pos 0

#define DMAC_ACTIVE_ID_Pos 8

#define DMAC_ACTIVE_ABUSY_Pos 15

#define DMAC_ACTIVE_BTCNT_Pos 16

#define DMAC_BASEADDR_OFFSET 52

#define DMAC_BASEADDR_BASEADDR_Pos 0

#define DMAC_WRBADDR_OFFSET 56

#define DMAC_WRBADDR_WRBADDR_Pos 0

#define DMAC_CHID_OFFSET 63

#define DMAC_CHID_ID_Pos 0

#define DMAC_CHCTRLA_OFFSET 64

#define DMAC_CHCTRLA_SWRST_Pos 0

#define DMAC_CHCTRLA_ENABLE_Pos 1

#define DMAC_CHCTRLA_RUNSTDBY_Pos 6

#define DMAC_CHCTRLB_OFFSET 68

#define DMAC_CHCTRLB_EVACT_Pos 0

#define DMAC_CHCTRLB_EVIE_Pos 3

#define DMAC_CHCTRLB_EVOE_Pos 4

#define DMAC_CHCTRLB_LVL_Pos 5

#define DMAC_CHCTRLB_TRIGSRC_Pos 8

#define DMAC_CHCTRLB_TRIGACT_Pos 22

#define DMAC_CHCTRLB_CMD_Pos 24

#define DMAC_CHINTENCLR_OFFSET 76

#define DMAC_CHINTENCLR_TERR_Pos 0

#define DMAC_CHINTENCLR_TCMPL_Pos 1

#define DMAC_CHINTENCLR_SUSP_Pos 2

#define DMAC_CHINTENSET_OFFSET 77

#define DMAC_CHINTENSET_TERR_Pos 0

#define DMAC_CHINTENSET_TCMPL_Pos 1

#define DMAC_CHINTENSET_SUSP_Pos 2

#define DMAC_CHINTFLAG_OFFSET 78

#define DMAC_CHINTFLAG_TERR_Pos 0

#define DMAC_CHINTFLAG_TCMPL_Pos 1

#define DMAC_CHINTFLAG_SUSP_Pos 2

#define DMAC_CHSTATUS_OFFSET 79

#define DMAC_CHSTATUS_PEND_Pos 0

#define DMAC_CHSTATUS_BUSY_Pos 1

#define DMAC_CHSTATUS_FERR_Pos 2

#define DMAC_BTCTRL_OFFSET 0

#define DMAC_BTCTRL_VALID_Pos 0

#define DMAC_BTCTRL_EVOSEL_Pos 1

#define DMAC_BTCTRL_BLOCKACT_Pos 3

#define DMAC_BTCTRL_BEATSIZE_Pos 8

#define DMAC_BTCTRL_SRCINC_Pos 10

#define DMAC_BTCTRL_DSTINC_Pos 11

#define DMAC_BTCTRL_STEPSEL_Pos 12

#define DMAC_BTCTRL_STEPSIZE_Pos 13

#define DMAC_BTCNT_OFFSET 2

#define DMAC_BTCNT_BTCNT_Pos 0

#define DMAC_SRCADDR_OFFSET 4

#define DMAC_SRCADDR_SRCADDR_Pos 0

#define DMAC_DSTADDR_OFFSET 8

#define DMAC_DSTADDR_DSTADDR_Pos 0

#define DMAC_DESCADDR_OFFSET 12

#define DMAC_DESCADDR_DESCADDR_Pos 0

#define REV_DSU 592

#define DSU_CTRL_OFFSET 0

#define DSU_CTRL_SWRST_Pos 0

#define DSU_CTRL_CRC_Pos 2

#define DSU_CTRL_MBIST_Pos 3

#define DSU_CTRL_CE_Pos 4

#define DSU_CTRL_ARR_Pos 6

#define DSU_CTRL_SMSA_Pos 7

#define DSU_STATUSA_OFFSET 1

#define DSU_STATUSA_DONE_Pos 0

#define DSU_STATUSA_CRSTEXT_Pos 1

#define DSU_STATUSA_BERR_Pos 2

#define DSU_STATUSA_FAIL_Pos 3

#define DSU_STATUSA_PERR_Pos 4

#define DSU_STATUSB_OFFSET 2

#define DSU_STATUSB_PROT_Pos 0

#define DSU_STATUSB_DBGPRES_Pos 1

#define DSU_STATUSB_DCCD0_Pos 2

#define DSU_STATUSB_DCCD1_Pos 3

#define DSU_STATUSB_DCCD_Pos 2

#define DSU_STATUSB_HPE_Pos 4

#define DSU_ADDR_OFFSET 4

#define DSU_ADDR_AMOD_Pos 0

#define DSU_ADDR_ADDR_Pos 2

#define DSU_LENGTH_OFFSET 8

#define DSU_LENGTH_LENGTH_Pos 2

#define DSU_DATA_OFFSET 12

#define DSU_DATA_DATA_Pos 0

#define DSU_DCC_OFFSET 16

#define DSU_DCC_DATA_Pos 0

#define DSU_DID_OFFSET 24

#define DSU_DID_DEVSEL_Pos 0

#define DSU_DID_REVISION_Pos 8

#define DSU_DID_DIE_Pos 12

#define DSU_DID_SERIES_Pos 16

#define DSU_DID_FAMILY_Pos 23

#define DSU_DID_PROCESSOR_Pos 28

#define DSU_DCFG_OFFSET 240

#define DSU_DCFG_DCFG_Pos 0

#define DSU_ENTRY0_OFFSET 4096

#define DSU_ENTRY0_EPRES_Pos 0

#define DSU_ENTRY0_FMT_Pos 1

#define DSU_ENTRY0_ADDOFF_Pos 12

#define DSU_ENTRY1_OFFSET 4100

#define DSU_END_OFFSET 4104

#define DSU_END_END_Pos 0

#define DSU_MEMTYPE_OFFSET 8140

#define DSU_MEMTYPE_SMEMP_Pos 0

#define DSU_PID4_OFFSET 8144

#define DSU_PID4_JEPCC_Pos 0

#define DSU_PID4_FKBC_Pos 4

#define DSU_PID5_OFFSET 8148

#define DSU_PID6_OFFSET 8152

#define DSU_PID7_OFFSET 8156

#define DSU_PID0_OFFSET 8160

#define DSU_PID0_PARTNBL_Pos 0

#define DSU_PID1_OFFSET 8164

#define DSU_PID1_PARTNBH_Pos 0

#define DSU_PID1_JEPIDCL_Pos 4

#define DSU_PID2_OFFSET 8168

#define DSU_PID2_JEPIDCH_Pos 0

#define DSU_PID2_JEPU_Pos 3

#define DSU_PID2_REVISION_Pos 4

#define DSU_PID3_OFFSET 8172

#define DSU_PID3_CUSMOD_Pos 0

#define DSU_PID3_REVAND_Pos 4

#define DSU_CID0_OFFSET 8176

#define DSU_CID0_PREAMBLEB0_Pos 0

#define DSU_CID1_OFFSET 8180

#define DSU_CID1_PREAMBLE_Pos 0

#define DSU_CID1_CCLASS_Pos 4

#define DSU_CID2_OFFSET 8184

#define DSU_CID2_PREAMBLEB2_Pos 0

#define DSU_CID3_OFFSET 8188

#define DSU_CID3_PREAMBLEB3_Pos 0

#define REV_EIC 514

#define EIC_CTRLA_OFFSET 0

#define EIC_CTRLA_SWRST_Pos 0

#define EIC_CTRLA_ENABLE_Pos 1

#define EIC_CTRLA_CKSEL_Pos 4

#define EIC_NMICTRL_OFFSET 1

#define EIC_NMICTRL_NMISENSE_Pos 0

#define EIC_NMICTRL_NMIFILTEN_Pos 3

#define EIC_NMICTRL_NMIASYNCH_Pos 4

#define EIC_NMIFLAG_OFFSET 2

#define EIC_NMIFLAG_NMI_Pos 0

#define EIC_SYNCBUSY_OFFSET 4

#define EIC_SYNCBUSY_SWRST_Pos 0

#define EIC_SYNCBUSY_ENABLE_Pos 1

#define EIC_EVCTRL_OFFSET 8

#define EIC_EVCTRL_EXTINTEO_Pos 0

#define EIC_INTENCLR_OFFSET 12

#define EIC_INTENCLR_EXTINT_Pos 0

#define EIC_INTENSET_OFFSET 16

#define EIC_INTENSET_EXTINT_Pos 0

#define EIC_INTFLAG_OFFSET 20

#define EIC_INTFLAG_EXTINT_Pos 0

#define EIC_ASYNCH_OFFSET 24

#define EIC_ASYNCH_ASYNCH_Pos 0

#define EIC_CONFIG_OFFSET 28

#define EIC_CONFIG_SENSE0_Pos 0

#define EIC_CONFIG_FILTEN0_Pos 3

#define EIC_CONFIG_SENSE1_Pos 4

#define EIC_CONFIG_FILTEN1_Pos 7

#define EIC_CONFIG_SENSE2_Pos 8

#define EIC_CONFIG_FILTEN2_Pos 11

#define EIC_CONFIG_SENSE3_Pos 12

#define EIC_CONFIG_FILTEN3_Pos 15

#define EIC_CONFIG_SENSE4_Pos 16

#define EIC_CONFIG_FILTEN4_Pos 19

#define EIC_CONFIG_SENSE5_Pos 20

#define EIC_CONFIG_FILTEN5_Pos 23

#define EIC_CONFIG_SENSE6_Pos 24

#define EIC_CONFIG_FILTEN6_Pos 27

#define EIC_CONFIG_SENSE7_Pos 28

#define EIC_CONFIG_FILTEN7_Pos 31

#define REV_EVSYS 257

#define EVSYS_CTRLA_OFFSET 0

#define EVSYS_CTRLA_SWRST_Pos 0

#define EVSYS_CHSTATUS_OFFSET 12

#define EVSYS_CHSTATUS_USRRDY0_Pos 0

#define EVSYS_CHSTATUS_USRRDY1_Pos 1

#define EVSYS_CHSTATUS_USRRDY2_Pos 2

#define EVSYS_CHSTATUS_USRRDY3_Pos 3

#define EVSYS_CHSTATUS_USRRDY4_Pos 4

#define EVSYS_CHSTATUS_USRRDY5_Pos 5

#define EVSYS_CHSTATUS_USRRDY6_Pos 6

#define EVSYS_CHSTATUS_USRRDY7_Pos 7

#define EVSYS_CHSTATUS_USRRDY_Pos 0

#define EVSYS_CHSTATUS_CHBUSY0_Pos 16

#define EVSYS_CHSTATUS_CHBUSY1_Pos 17

#define EVSYS_CHSTATUS_CHBUSY2_Pos 18

#define EVSYS_CHSTATUS_CHBUSY3_Pos 19

#define EVSYS_CHSTATUS_CHBUSY4_Pos 20

#define EVSYS_CHSTATUS_CHBUSY5_Pos 21

#define EVSYS_CHSTATUS_CHBUSY6_Pos 22

#define EVSYS_CHSTATUS_CHBUSY7_Pos 23

#define EVSYS_CHSTATUS_CHBUSY_Pos 16

#define EVSYS_INTENCLR_OFFSET 16

#define EVSYS_INTENCLR_OVR0_Pos 0

#define EVSYS_INTENCLR_OVR1_Pos 1

#define EVSYS_INTENCLR_OVR2_Pos 2

#define EVSYS_INTENCLR_OVR3_Pos 3

#define EVSYS_INTENCLR_OVR4_Pos 4

#define EVSYS_INTENCLR_OVR5_Pos 5

#define EVSYS_INTENCLR_OVR6_Pos 6

#define EVSYS_INTENCLR_OVR7_Pos 7

#define EVSYS_INTENCLR_OVR_Pos 0

#define EVSYS_INTENCLR_EVD0_Pos 16

#define EVSYS_INTENCLR_EVD1_Pos 17

#define EVSYS_INTENCLR_EVD2_Pos 18

#define EVSYS_INTENCLR_EVD3_Pos 19

#define EVSYS_INTENCLR_EVD4_Pos 20

#define EVSYS_INTENCLR_EVD5_Pos 21

#define EVSYS_INTENCLR_EVD6_Pos 22

#define EVSYS_INTENCLR_EVD7_Pos 23

#define EVSYS_INTENCLR_EVD_Pos 16

#define EVSYS_INTENSET_OFFSET 20

#define EVSYS_INTENSET_OVR0_Pos 0

#define EVSYS_INTENSET_OVR1_Pos 1

#define EVSYS_INTENSET_OVR2_Pos 2

#define EVSYS_INTENSET_OVR3_Pos 3

#define EVSYS_INTENSET_OVR4_Pos 4

#define EVSYS_INTENSET_OVR5_Pos 5

#define EVSYS_INTENSET_OVR6_Pos 6

#define EVSYS_INTENSET_OVR7_Pos 7

#define EVSYS_INTENSET_OVR_Pos 0

#define EVSYS_INTENSET_EVD0_Pos 16

#define EVSYS_INTENSET_EVD1_Pos 17

#define EVSYS_INTENSET_EVD2_Pos 18

#define EVSYS_INTENSET_EVD3_Pos 19

#define EVSYS_INTENSET_EVD4_Pos 20

#define EVSYS_INTENSET_EVD5_Pos 21

#define EVSYS_INTENSET_EVD6_Pos 22

#define EVSYS_INTENSET_EVD7_Pos 23

#define EVSYS_INTENSET_EVD_Pos 16

#define EVSYS_INTFLAG_OFFSET 24

#define EVSYS_INTFLAG_OVR0_Pos 0

#define EVSYS_INTFLAG_OVR1_Pos 1

#define EVSYS_INTFLAG_OVR2_Pos 2

#define EVSYS_INTFLAG_OVR3_Pos 3

#define EVSYS_INTFLAG_OVR4_Pos 4

#define EVSYS_INTFLAG_OVR5_Pos 5

#define EVSYS_INTFLAG_OVR6_Pos 6

#define EVSYS_INTFLAG_OVR7_Pos 7

#define EVSYS_INTFLAG_OVR_Pos 0

#define EVSYS_INTFLAG_EVD0_Pos 16

#define EVSYS_INTFLAG_EVD1_Pos 17

#define EVSYS_INTFLAG_EVD2_Pos 18

#define EVSYS_INTFLAG_EVD3_Pos 19

#define EVSYS_INTFLAG_EVD4_Pos 20

#define EVSYS_INTFLAG_EVD5_Pos 21

#define EVSYS_INTFLAG_EVD6_Pos 22

#define EVSYS_INTFLAG_EVD7_Pos 23

#define EVSYS_INTFLAG_EVD_Pos 16

#define EVSYS_SWEVT_OFFSET 28

#define EVSYS_SWEVT_CHANNEL0_Pos 0

#define EVSYS_SWEVT_CHANNEL1_Pos 1

#define EVSYS_SWEVT_CHANNEL2_Pos 2

#define EVSYS_SWEVT_CHANNEL3_Pos 3

#define EVSYS_SWEVT_CHANNEL4_Pos 4

#define EVSYS_SWEVT_CHANNEL5_Pos 5

#define EVSYS_SWEVT_CHANNEL6_Pos 6

#define EVSYS_SWEVT_CHANNEL7_Pos 7

#define EVSYS_SWEVT_CHANNEL_Pos 0

#define EVSYS_CHANNEL_OFFSET 32

#define EVSYS_CHANNEL_EVGEN_Pos 0

#define EVSYS_CHANNEL_PATH_Pos 8

#define EVSYS_CHANNEL_EDGSEL_Pos 10

#define EVSYS_CHANNEL_RUNSTDBY_Pos 14

#define EVSYS_CHANNEL_ONDEMAND_Pos 15

#define EVSYS_USER_OFFSET 128

#define EVSYS_USER_CHANNEL_Pos 0

#define REV_FREQM 257

#define FREQM_CTRLA_OFFSET 0

#define FREQM_CTRLA_SWRST_Pos 0

#define FREQM_CTRLA_ENABLE_Pos 1

#define FREQM_CTRLB_OFFSET 1

#define FREQM_CTRLB_START_Pos 0

#define FREQM_CFGA_OFFSET 2

#define FREQM_CFGA_REFNUM_Pos 0

#define FREQM_INTENCLR_OFFSET 8

#define FREQM_INTENCLR_DONE_Pos 0

#define FREQM_INTENSET_OFFSET 9

#define FREQM_INTENSET_DONE_Pos 0

#define FREQM_INTFLAG_OFFSET 10

#define FREQM_INTFLAG_DONE_Pos 0

#define FREQM_STATUS_OFFSET 11

#define FREQM_STATUS_BUSY_Pos 0

#define FREQM_STATUS_OVF_Pos 1

#define FREQM_SYNCBUSY_OFFSET 12

#define FREQM_SYNCBUSY_SWRST_Pos 0

#define FREQM_SYNCBUSY_ENABLE_Pos 1

#define FREQM_VALUE_OFFSET 16

#define FREQM_VALUE_VALUE_Pos 0

#define REV_GCLK 273

#define GCLK_CTRLA_OFFSET 0

#define GCLK_CTRLA_SWRST_Pos 0

#define GCLK_SYNCBUSY_OFFSET 4

#define GCLK_SYNCBUSY_SWRST_Pos 0

#define GCLK_SYNCBUSY_GENCTRL0_Pos 2

#define GCLK_SYNCBUSY_GENCTRL1_Pos 3

#define GCLK_SYNCBUSY_GENCTRL2_Pos 4

#define GCLK_SYNCBUSY_GENCTRL3_Pos 5

#define GCLK_SYNCBUSY_GENCTRL4_Pos 6

#define GCLK_SYNCBUSY_GENCTRL_Pos 2

#define GCLK_GENCTRL_OFFSET 32

#define GCLK_GENCTRL_SRC_Pos 0

#define GCLK_GENCTRL_GENEN_Pos 8

#define GCLK_GENCTRL_IDC_Pos 9

#define GCLK_GENCTRL_OOV_Pos 10

#define GCLK_GENCTRL_OE_Pos 11

#define GCLK_GENCTRL_DIVSEL_Pos 12

#define GCLK_GENCTRL_RUNSTDBY_Pos 13

#define GCLK_GENCTRL_DIV_Pos 16

#define GCLK_PCHCTRL_OFFSET 128

#define GCLK_PCHCTRL_GEN_Pos 0

#define GCLK_PCHCTRL_CHEN_Pos 6

#define GCLK_PCHCTRL_WRTLOCK_Pos 7

#define REV_MCLK 528

#define MCLK_INTENCLR_OFFSET 1

#define MCLK_INTENCLR_CKRDY_Pos 0

#define MCLK_INTENSET_OFFSET 2

#define MCLK_INTENSET_CKRDY_Pos 0

#define MCLK_INTFLAG_OFFSET 3

#define MCLK_INTFLAG_CKRDY_Pos 0

#define MCLK_CPUDIV_OFFSET 4

#define MCLK_CPUDIV_CPUDIV_Pos 0

#define MCLK_BUPDIV_OFFSET 6

#define MCLK_BUPDIV_BUPDIV_Pos 0

#define MCLK_AHBMASK_OFFSET 16

#define MCLK_AHBMASK_HPB0_Pos 0

#define MCLK_AHBMASK_HPB1_Pos 1

#define MCLK_AHBMASK_HPB2_Pos 2

#define MCLK_AHBMASK_DMAC_Pos 3

#define MCLK_AHBMASK_USB_Pos 4

#define MCLK_AHBMASK_DSU_Pos 5

#define MCLK_AHBMASK_PAC_Pos 7

#define MCLK_AHBMASK_NVMCTRL_Pos 8

#define MCLK_AHBMASK_HSRAM_Pos 9

#define MCLK_AHBMASK_NVMCTRL_PICACHU_Pos 10

#define MCLK_APBAMASK_OFFSET 20

#define MCLK_APBAMASK_PAC_Pos 0

#define MCLK_APBAMASK_PM_Pos 1

#define MCLK_APBAMASK_MCLK_Pos 2

#define MCLK_APBAMASK_RSTC_Pos 3

#define MCLK_APBAMASK_OSCCTRL_Pos 4

#define MCLK_APBAMASK_OSC32KCTRL_Pos 5

#define MCLK_APBAMASK_SUPC_Pos 6

#define MCLK_APBAMASK_GCLK_Pos 7

#define MCLK_APBAMASK_WDT_Pos 8

#define MCLK_APBAMASK_RTC_Pos 9

#define MCLK_APBAMASK_EIC_Pos 10

#define MCLK_APBAMASK_FREQM_Pos 11

#define MCLK_APBBMASK_OFFSET 24

#define MCLK_APBBMASK_USB_Pos 0

#define MCLK_APBBMASK_DSU_Pos 1

#define MCLK_APBBMASK_NVMCTRL_Pos 2

#define MCLK_APBBMASK_PORT_Pos 3

#define MCLK_APBCMASK_OFFSET 28

#define MCLK_APBCMASK_EVSYS_Pos 0

#define MCLK_APBCMASK_SERCOM0_Pos 1

#define MCLK_APBCMASK_SERCOM1_Pos 2

#define MCLK_APBCMASK_SERCOM2_Pos 3

#define MCLK_APBCMASK_SERCOM3_Pos 4

#define MCLK_APBCMASK_SERCOM4_Pos 5

#define MCLK_APBCMASK_SERCOM5_Pos 6

#define MCLK_APBCMASK_TCC0_Pos 7

#define MCLK_APBCMASK_TC0_Pos 8

#define MCLK_APBCMASK_TC1_Pos 9

#define MCLK_APBCMASK_TC2_Pos 10

#define MCLK_APBCMASK_TC3_Pos 11

#define MCLK_APBCMASK_ADC_Pos 12

#define MCLK_APBCMASK_AC_Pos 13

#define MCLK_APBCMASK_PTC_Pos 14

#define MCLK_APBCMASK_SLCD_Pos 15

#define MCLK_APBCMASK_AES_Pos 16

#define MCLK_APBCMASK_TRNG_Pos 17

#define MCLK_APBCMASK_CCL_Pos 18

#define REV_MTB 256

#define MTB_POSITION_OFFSET 0

#define MTB_POSITION_WRAP_Pos 2

#define MTB_POSITION_POINTER_Pos 3

#define MTB_MASTER_OFFSET 4

#define MTB_MASTER_MASK_Pos 0

#define MTB_MASTER_TSTARTEN_Pos 5

#define MTB_MASTER_TSTOPEN_Pos 6

#define MTB_MASTER_SFRWPRIV_Pos 7

#define MTB_MASTER_RAMPRIV_Pos 8

#define MTB_MASTER_HALTREQ_Pos 9

#define MTB_MASTER_EN_Pos 31

#define MTB_FLOW_OFFSET 8

#define MTB_FLOW_AUTOSTOP_Pos 0

#define MTB_FLOW_AUTOHALT_Pos 1

#define MTB_FLOW_WATERMARK_Pos 3

#define MTB_BASE_OFFSET 12

#define MTB_ITCTRL_OFFSET 3840

#define MTB_CLAIMSET_OFFSET 4000

#define MTB_CLAIMCLR_OFFSET 4004

#define MTB_LOCKACCESS_OFFSET 4016

#define MTB_LOCKSTATUS_OFFSET 4020

#define MTB_AUTHSTATUS_OFFSET 4024

#define MTB_DEVARCH_OFFSET 4028

#define MTB_DEVID_OFFSET 4040

#define MTB_DEVTYPE_OFFSET 4044

#define MTB_PID4_OFFSET 4048

#define MTB_PID5_OFFSET 4052

#define MTB_PID6_OFFSET 4056

#define MTB_PID7_OFFSET 4060

#define MTB_PID0_OFFSET 4064

#define MTB_PID1_OFFSET 4068

#define MTB_PID2_OFFSET 4072

#define MTB_PID3_OFFSET 4076

#define MTB_CID0_OFFSET 4080

#define MTB_CID1_OFFSET 4084

#define MTB_CID2_OFFSET 4088

#define MTB_CID3_OFFSET 4092

#define REV_NVMCTRL 770

#define NVMCTRL_CTRLA_OFFSET 0

#define NVMCTRL_CTRLA_CMD_Pos 0

#define NVMCTRL_CTRLA_CMDEX_Pos 8

#define NVMCTRL_CTRLB_OFFSET 4

#define NVMCTRL_CTRLB_RWS_Pos 1

#define NVMCTRL_CTRLB_MANW_Pos 7

#define NVMCTRL_CTRLB_SLEEPPRM_Pos 8

#define NVMCTRL_CTRLB_FWUP_Pos 11

#define NVMCTRL_CTRLB_READMODE_Pos 16

#define NVMCTRL_CTRLB_CACHEDIS_Pos 18

#define NVMCTRL_PARAM_OFFSET 8

#define NVMCTRL_PARAM_NVMP_Pos 0

#define NVMCTRL_PARAM_PSZ_Pos 16

#define NVMCTRL_PARAM_RWWEEP_Pos 20

#define NVMCTRL_INTENCLR_OFFSET 12

#define NVMCTRL_INTENCLR_READY_Pos 0

#define NVMCTRL_INTENCLR_ERROR_Pos 1

#define NVMCTRL_INTENSET_OFFSET 16

#define NVMCTRL_INTENSET_READY_Pos 0

#define NVMCTRL_INTENSET_ERROR_Pos 1

#define NVMCTRL_INTFLAG_OFFSET 20

#define NVMCTRL_INTFLAG_READY_Pos 0

#define NVMCTRL_INTFLAG_ERROR_Pos 1

#define NVMCTRL_STATUS_OFFSET 24

#define NVMCTRL_STATUS_PRM_Pos 0

#define NVMCTRL_STATUS_LOAD_Pos 1

#define NVMCTRL_STATUS_PROGE_Pos 2

#define NVMCTRL_STATUS_LOCKE_Pos 3

#define NVMCTRL_STATUS_NVME_Pos 4

#define NVMCTRL_STATUS_SB_Pos 8

#define NVMCTRL_ADDR_OFFSET 28

#define NVMCTRL_ADDR_ADDR_Pos 0

#define NVMCTRL_LOCK_OFFSET 32

#define NVMCTRL_LOCK_LOCK_Pos 0

#define ADC_FUSES_BIASCOMP_Pos 3

#define ADC_FUSES_BIASREFBUF_Pos 0

#define FUSES_BOD12_HYST_Pos 10

#define FUSES_BOD33USERLEVEL_Pos 8

#define FUSES_BOD33_ACTION_Pos 15

#define FUSES_BOD33_DIS_Pos 14

#define FUSES_BOD33_HYST_Pos 9

#define FUSES_DFLL48M_COARSE_CAL_Pos 26

#define FUSES_HOT_ADC_VAL_CTAT_Pos 12

#define FUSES_HOT_ADC_VAL_PTAT_Pos 20

#define FUSES_HOT_INT1V_VAL_Pos 0

#define FUSES_HOT_TEMP_VAL_DEC_Pos 20

#define FUSES_HOT_TEMP_VAL_INT_Pos 12

#define FUSES_ROOM_ADC_VAL_CTAT_Pos 0

#define FUSES_ROOM_ADC_VAL_PTAT_Pos 8

#define FUSES_ROOM_INT1V_VAL_Pos 24

#define FUSES_ROOM_TEMP_VAL_DEC_Pos 8

#define FUSES_ROOM_TEMP_VAL_INT_Pos 0

#define NVMCTRL_FUSES_BOOTPROT_Pos 0

#define NVMCTRL_FUSES_EEPROM_SIZE_Pos 4

#define NVMCTRL_FUSES_REGION_LOCKS_Pos 16

#define USB_FUSES_TRANSN_Pos 13

#define USB_FUSES_TRANSP_Pos 18

#define USB_FUSES_TRIM_Pos 23

#define WDT_FUSES_ALWAYSON_Pos 27

#define WDT_FUSES_ENABLE_Pos 26

#define WDT_FUSES_EWOFFSET_Pos 4

#define WDT_FUSES_PER_Pos 28

#define WDT_FUSES_WEN_Pos 8

#define WDT_FUSES_WINDOW_Pos 0

#define REV_OSCCTRL 768

#define OSCCTRL_INTENCLR_OFFSET 0

#define OSCCTRL_INTENCLR_XOSCRDY_Pos 0

#define OSCCTRL_INTENCLR_XOSCFAIL_Pos 1

#define OSCCTRL_INTENCLR_OSC16MRDY_Pos 4

#define OSCCTRL_INTENCLR_DFLLRDY_Pos 8

#define OSCCTRL_INTENCLR_DFLLOOB_Pos 9

#define OSCCTRL_INTENCLR_DFLLLCKF_Pos 10

#define OSCCTRL_INTENCLR_DFLLLCKC_Pos 11

#define OSCCTRL_INTENCLR_DFLLRCS_Pos 12

#define OSCCTRL_INTENCLR_DPLLLCKR_Pos 16

#define OSCCTRL_INTENCLR_DPLLLCKF_Pos 17

#define OSCCTRL_INTENCLR_DPLLLTO_Pos 18

#define OSCCTRL_INTENCLR_DPLLLDRTO_Pos 19

#define OSCCTRL_INTENSET_OFFSET 4

#define OSCCTRL_INTENSET_XOSCRDY_Pos 0

#define OSCCTRL_INTENSET_XOSCFAIL_Pos 1

#define OSCCTRL_INTENSET_OSC16MRDY_Pos 4

#define OSCCTRL_INTENSET_DFLLRDY_Pos 8

#define OSCCTRL_INTENSET_DFLLOOB_Pos 9

#define OSCCTRL_INTENSET_DFLLLCKF_Pos 10

#define OSCCTRL_INTENSET_DFLLLCKC_Pos 11

#define OSCCTRL_INTENSET_DFLLRCS_Pos 12

#define OSCCTRL_INTENSET_DPLLLCKR_Pos 16

#define OSCCTRL_INTENSET_DPLLLCKF_Pos 17

#define OSCCTRL_INTENSET_DPLLLTO_Pos 18

#define OSCCTRL_INTENSET_DPLLLDRTO_Pos 19

#define OSCCTRL_INTFLAG_OFFSET 8

#define OSCCTRL_INTFLAG_XOSCRDY_Pos 0

#define OSCCTRL_INTFLAG_XOSCFAIL_Pos 1

#define OSCCTRL_INTFLAG_OSC16MRDY_Pos 4

#define OSCCTRL_INTFLAG_DFLLRDY_Pos 8

#define OSCCTRL_INTFLAG_DFLLOOB_Pos 9

#define OSCCTRL_INTFLAG_DFLLLCKF_Pos 10

#define OSCCTRL_INTFLAG_DFLLLCKC_Pos 11

#define OSCCTRL_INTFLAG_DFLLRCS_Pos 12

#define OSCCTRL_INTFLAG_DPLLLCKR_Pos 16

#define OSCCTRL_INTFLAG_DPLLLCKF_Pos 17

#define OSCCTRL_INTFLAG_DPLLLTO_Pos 18

#define OSCCTRL_INTFLAG_DPLLLDRTO_Pos 19

#define OSCCTRL_STATUS_OFFSET 12

#define OSCCTRL_STATUS_XOSCRDY_Pos 0

#define OSCCTRL_STATUS_XOSCFAIL_Pos 1

#define OSCCTRL_STATUS_XOSCCKSW_Pos 2

#define OSCCTRL_STATUS_OSC16MRDY_Pos 4

#define OSCCTRL_STATUS_DFLLRDY_Pos 8

#define OSCCTRL_STATUS_DFLLOOB_Pos 9

#define OSCCTRL_STATUS_DFLLLCKF_Pos 10

#define OSCCTRL_STATUS_DFLLLCKC_Pos 11

#define OSCCTRL_STATUS_DFLLRCS_Pos 12

#define OSCCTRL_STATUS_DPLLLCKR_Pos 16

#define OSCCTRL_STATUS_DPLLLCKF_Pos 17

#define OSCCTRL_STATUS_DPLLTO_Pos 18

#define OSCCTRL_STATUS_DPLLLDRTO_Pos 19

#define OSCCTRL_XOSCCTRL_OFFSET 16

#define OSCCTRL_XOSCCTRL_ENABLE_Pos 1

#define OSCCTRL_XOSCCTRL_XTALEN_Pos 2

#define OSCCTRL_XOSCCTRL_CFDEN_Pos 3

#define OSCCTRL_XOSCCTRL_SWBEN_Pos 4

#define OSCCTRL_XOSCCTRL_RUNSTDBY_Pos 6

#define OSCCTRL_XOSCCTRL_ONDEMAND_Pos 7

#define OSCCTRL_XOSCCTRL_GAIN_Pos 8

#define OSCCTRL_XOSCCTRL_AMPGC_Pos 11

#define OSCCTRL_XOSCCTRL_STARTUP_Pos 12

#define OSCCTRL_CFDPRESC_OFFSET 18

#define OSCCTRL_CFDPRESC_CFDPRESC_Pos 0

#define OSCCTRL_EVCTRL_OFFSET 19

#define OSCCTRL_EVCTRL_CFDEO_Pos 0

#define OSCCTRL_OSC16MCTRL_OFFSET 20

#define OSCCTRL_OSC16MCTRL_ENABLE_Pos 1

#define OSCCTRL_OSC16MCTRL_FSEL_Pos 2

#define OSCCTRL_OSC16MCTRL_RUNSTDBY_Pos 6

#define OSCCTRL_OSC16MCTRL_ONDEMAND_Pos 7

#define OSCCTRL_DFLLCTRL_OFFSET 24

#define OSCCTRL_DFLLCTRL_ENABLE_Pos 1

#define OSCCTRL_DFLLCTRL_MODE_Pos 2

#define OSCCTRL_DFLLCTRL_STABLE_Pos 3

#define OSCCTRL_DFLLCTRL_LLAW_Pos 4

#define OSCCTRL_DFLLCTRL_USBCRM_Pos 5

#define OSCCTRL_DFLLCTRL_RUNSTDBY_Pos 6

#define OSCCTRL_DFLLCTRL_ONDEMAND_Pos 7

#define OSCCTRL_DFLLCTRL_CCDIS_Pos 8

#define OSCCTRL_DFLLCTRL_QLDIS_Pos 9

#define OSCCTRL_DFLLCTRL_BPLCKC_Pos 10

#define OSCCTRL_DFLLCTRL_WAITLOCK_Pos 11

#define OSCCTRL_DFLLVAL_OFFSET 28

#define OSCCTRL_DFLLVAL_FINE_Pos 0

#define OSCCTRL_DFLLVAL_COARSE_Pos 10

#define OSCCTRL_DFLLVAL_DIFF_Pos 16

#define OSCCTRL_DFLLMUL_OFFSET 32

#define OSCCTRL_DFLLMUL_MUL_Pos 0

#define OSCCTRL_DFLLMUL_FSTEP_Pos 16

#define OSCCTRL_DFLLMUL_CSTEP_Pos 26

#define OSCCTRL_DFLLSYNC_OFFSET 36

#define OSCCTRL_DFLLSYNC_READREQ_Pos 7

#define OSCCTRL_DPLLCTRLA_OFFSET 40

#define OSCCTRL_DPLLCTRLA_ENABLE_Pos 1

#define OSCCTRL_DPLLCTRLA_RUNSTDBY_Pos 6

#define OSCCTRL_DPLLCTRLA_ONDEMAND_Pos 7

#define OSCCTRL_DPLLRATIO_OFFSET 44

#define OSCCTRL_DPLLRATIO_LDR_Pos 0

#define OSCCTRL_DPLLRATIO_LDRFRAC_Pos 16

#define OSCCTRL_DPLLCTRLB_OFFSET 48

#define OSCCTRL_DPLLCTRLB_FILTER_Pos 0

#define OSCCTRL_DPLLCTRLB_LPEN_Pos 2

#define OSCCTRL_DPLLCTRLB_WUF_Pos 3

#define OSCCTRL_DPLLCTRLB_REFCLK_Pos 4

#define OSCCTRL_DPLLCTRLB_LTIME_Pos 8

#define OSCCTRL_DPLLCTRLB_LBYPASS_Pos 12

#define OSCCTRL_DPLLCTRLB_DIV_Pos 16

#define OSCCTRL_DPLLPRESC_OFFSET 52

#define OSCCTRL_DPLLPRESC_PRESC_Pos 0

#define OSCCTRL_DPLLSYNCBUSY_OFFSET 56

#define OSCCTRL_DPLLSYNCBUSY_ENABLE_Pos 1

#define OSCCTRL_DPLLSYNCBUSY_DPLLRATIO_Pos 2

#define OSCCTRL_DPLLSYNCBUSY_DPLLPRESC_Pos 3

#define OSCCTRL_DPLLSTATUS_OFFSET 60

#define OSCCTRL_DPLLSTATUS_LOCK_Pos 0

#define OSCCTRL_DPLLSTATUS_CLKRDY_Pos 1

#define REV_OSC32KCTRL 768

#define OSC32KCTRL_INTENCLR_OFFSET 0

#define OSC32KCTRL_INTENCLR_XOSC32KRDY_Pos 0

#define OSC32KCTRL_INTENCLR_CLKFAIL_Pos 2

#define OSC32KCTRL_INTENSET_OFFSET 4

#define OSC32KCTRL_INTENSET_XOSC32KRDY_Pos 0

#define OSC32KCTRL_INTENSET_CLKFAIL_Pos 2

#define OSC32KCTRL_INTFLAG_OFFSET 8

#define OSC32KCTRL_INTFLAG_XOSC32KRDY_Pos 0

#define OSC32KCTRL_INTFLAG_CLKFAIL_Pos 2

#define OSC32KCTRL_STATUS_OFFSET 12

#define OSC32KCTRL_STATUS_XOSC32KRDY_Pos 0

#define OSC32KCTRL_STATUS_CLKFAIL_Pos 2

#define OSC32KCTRL_STATUS_CLKSW_Pos 3

#define OSC32KCTRL_RTCCTRL_OFFSET 16

#define OSC32KCTRL_RTCCTRL_RTCSEL_Pos 0

#define OSC32KCTRL_SLCDCTRL_OFFSET 17

#define OSC32KCTRL_SLCDCTRL_SLCDSEL_Pos 0

#define OSC32KCTRL_XOSC32K_OFFSET 20

#define OSC32KCTRL_XOSC32K_ENABLE_Pos 1

#define OSC32KCTRL_XOSC32K_XTALEN_Pos 2

#define OSC32KCTRL_XOSC32K_EN32K_Pos 3

#define OSC32KCTRL_XOSC32K_EN1K_Pos 4

#define OSC32KCTRL_XOSC32K_RUNSTDBY_Pos 6

#define OSC32KCTRL_XOSC32K_ONDEMAND_Pos 7

#define OSC32KCTRL_XOSC32K_STARTUP_Pos 8

#define OSC32KCTRL_XOSC32K_WRTLOCK_Pos 12

#define OSC32KCTRL_CFDCTRL_OFFSET 22

#define OSC32KCTRL_CFDCTRL_CFDEN_Pos 0

#define OSC32KCTRL_CFDCTRL_SWBACK_Pos 1

#define OSC32KCTRL_CFDCTRL_CFDPRESC_Pos 2

#define OSC32KCTRL_EVCTRL_OFFSET 23

#define OSC32KCTRL_EVCTRL_CFDEO_Pos 0

#define OSC32KCTRL_OSCULP32K_OFFSET 28

#define OSC32KCTRL_OSCULP32K_EN32K_Pos 1

#define OSC32KCTRL_OSCULP32K_EN1K_Pos 2

#define OSC32KCTRL_OSCULP32K_CALIB_Pos 8

#define OSC32KCTRL_OSCULP32K_WRTLOCK_Pos 15

#define REV_PAC 272

#define PAC_WRCTRL_OFFSET 0

#define PAC_WRCTRL_PERID_Pos 0

#define PAC_WRCTRL_KEY_Pos 16

#define PAC_EVCTRL_OFFSET 4

#define PAC_EVCTRL_ERREO_Pos 0

#define PAC_INTENCLR_OFFSET 8

#define PAC_INTENCLR_ERR_Pos 0

#define PAC_INTENSET_OFFSET 9

#define PAC_INTENSET_ERR_Pos 0

#define PAC_INTFLAGAHB_OFFSET 16

#define PAC_INTFLAGAHB_FLASH_Pos 0

#define PAC_INTFLAGAHB_HSRAMCM0P_Pos 1

#define PAC_INTFLAGAHB_HSRAMDSU_Pos 2

#define PAC_INTFLAGAHB_HPB1_Pos 3

#define PAC_INTFLAGAHB_HPB0_Pos 4

#define PAC_INTFLAGAHB_HPB2_Pos 5

#define PAC_INTFLAGAHB_HSRAMDMAC_Pos 6

#define PAC_INTFLAGA_OFFSET 20

#define PAC_INTFLAGA_PAC_Pos 0

#define PAC_INTFLAGA_PM_Pos 1

#define PAC_INTFLAGA_MCLK_Pos 2

#define PAC_INTFLAGA_RSTC_Pos 3

#define PAC_INTFLAGA_OSCCTRL_Pos 4

#define PAC_INTFLAGA_OSC32KCTRL_Pos 5

#define PAC_INTFLAGA_SUPC_Pos 6

#define PAC_INTFLAGA_GCLK_Pos 7

#define PAC_INTFLAGA_WDT_Pos 8

#define PAC_INTFLAGA_RTC_Pos 9

#define PAC_INTFLAGA_EIC_Pos 10

#define PAC_INTFLAGA_FREQM_Pos 11

#define PAC_INTFLAGB_OFFSET 24

#define PAC_INTFLAGB_USB_Pos 0

#define PAC_INTFLAGB_DSU_Pos 1

#define PAC_INTFLAGB_NVMCTRL_Pos 2

#define PAC_INTFLAGB_PORT_Pos 3

#define PAC_INTFLAGB_DMAC_Pos 4

#define PAC_INTFLAGB_MTB_Pos 5

#define PAC_INTFLAGC_OFFSET 28

#define PAC_INTFLAGC_EVSYS_Pos 0

#define PAC_INTFLAGC_SERCOM0_Pos 1

#define PAC_INTFLAGC_SERCOM1_Pos 2

#define PAC_INTFLAGC_SERCOM2_Pos 3

#define PAC_INTFLAGC_SERCOM3_Pos 4

#define PAC_INTFLAGC_SERCOM4_Pos 5

#define PAC_INTFLAGC_SERCOM5_Pos 6

#define PAC_INTFLAGC_TCC0_Pos 7

#define PAC_INTFLAGC_TC0_Pos 8

#define PAC_INTFLAGC_TC1_Pos 9

#define PAC_INTFLAGC_TC2_Pos 10

#define PAC_INTFLAGC_TC3_Pos 11

#define PAC_INTFLAGC_ADC_Pos 12

#define PAC_INTFLAGC_AC_Pos 13

#define PAC_INTFLAGC_PTC_Pos 14

#define PAC_INTFLAGC_SLCD_Pos 15

#define PAC_INTFLAGC_AES_Pos 16

#define PAC_INTFLAGC_TRNG_Pos 17

#define PAC_INTFLAGC_CCL_Pos 18

#define PAC_STATUSA_OFFSET 52

#define PAC_STATUSA_PAC_Pos 0

#define PAC_STATUSA_PM_Pos 1

#define PAC_STATUSA_MCLK_Pos 2

#define PAC_STATUSA_RSTC_Pos 3

#define PAC_STATUSA_OSCCTRL_Pos 4

#define PAC_STATUSA_OSC32KCTRL_Pos 5

#define PAC_STATUSA_SUPC_Pos 6

#define PAC_STATUSA_GCLK_Pos 7

#define PAC_STATUSA_WDT_Pos 8

#define PAC_STATUSA_RTC_Pos 9

#define PAC_STATUSA_EIC_Pos 10

#define PAC_STATUSA_FREQM_Pos 11

#define PAC_STATUSB_OFFSET 56

#define PAC_STATUSB_USB_Pos 0

#define PAC_STATUSB_DSU_Pos 1

#define PAC_STATUSB_NVMCTRL_Pos 2

#define PAC_STATUSB_PORT_Pos 3

#define PAC_STATUSB_DMAC_Pos 4

#define PAC_STATUSB_MTB_Pos 5

#define PAC_STATUSC_OFFSET 60

#define PAC_STATUSC_EVSYS_Pos 0

#define PAC_STATUSC_SERCOM0_Pos 1

#define PAC_STATUSC_SERCOM1_Pos 2

#define PAC_STATUSC_SERCOM2_Pos 3

#define PAC_STATUSC_SERCOM3_Pos 4

#define PAC_STATUSC_SERCOM4_Pos 5

#define PAC_STATUSC_SERCOM5_Pos 6

#define PAC_STATUSC_TCC0_Pos 7

#define PAC_STATUSC_TC0_Pos 8

#define PAC_STATUSC_TC1_Pos 9

#define PAC_STATUSC_TC2_Pos 10

#define PAC_STATUSC_TC3_Pos 11

#define PAC_STATUSC_ADC_Pos 12

#define PAC_STATUSC_AC_Pos 13

#define PAC_STATUSC_PTC_Pos 14

#define PAC_STATUSC_SLCD_Pos 15

#define PAC_STATUSC_AES_Pos 16

#define PAC_STATUSC_TRNG_Pos 17

#define PAC_STATUSC_CCL_Pos 18

#define REV_PM 529

#define PM_CTRLA_OFFSET 0

#define PM_CTRLA_IORET_Pos 2

#define PM_SLEEPCFG_OFFSET 1

#define PM_SLEEPCFG_SLEEPMODE_Pos 0

#define PM_PLCFG_OFFSET 2

#define PM_PLCFG_PLSEL_Pos 0

#define PM_PLCFG_PLDIS_Pos 7

#define PM_INTENCLR_OFFSET 4

#define PM_INTENCLR_PLRDY_Pos 0

#define PM_INTENSET_OFFSET 5

#define PM_INTENSET_PLRDY_Pos 0

#define PM_INTFLAG_OFFSET 6

#define PM_INTFLAG_PLRDY_Pos 0

#define PM_STDBYCFG_OFFSET 8

#define PM_STDBYCFG_VREGSMOD_Pos 6

#define PM_STDBYCFG_BBIASHS_Pos 10

#define REV_PORT 529

#define PORT_DIR_OFFSET 0

#define PORT_DIRCLR_OFFSET 4

#define PORT_DIRSET_OFFSET 8

#define PORT_DIRTGL_OFFSET 12

#define PORT_OUT_OFFSET 16

#define PORT_OUTCLR_OFFSET 20

#define PORT_OUTSET_OFFSET 24

#define PORT_OUTTGL_OFFSET 28

#define PORT_IN_OFFSET 32

#define PORT_CTRL_OFFSET 36

#define PORT_CTRL_SAMPLING_Pos 0

#define PORT_WRCONFIG_OFFSET 40

#define PORT_WRCONFIG_PINMASK_Pos 0

#define PORT_WRCONFIG_PMUXEN_Pos 16

#define PORT_WRCONFIG_INEN_Pos 17

#define PORT_WRCONFIG_PULLEN_Pos 18

#define PORT_WRCONFIG_DRVSTR_Pos 22

#define PORT_WRCONFIG_PMUX_Pos 24

#define PORT_WRCONFIG_WRPMUX_Pos 28

#define PORT_WRCONFIG_WRPINCFG_Pos 30

#define PORT_WRCONFIG_HWSEL_Pos 31

#define PORT_EVCTRL_OFFSET 44

#define PORT_EVCTRL_PID0_Pos 0

#define PORT_EVCTRL_EVACT0_Pos 5

#define PORT_EVCTRL_PORTEI0_Pos 7

#define PORT_EVCTRL_PID1_Pos 8

#define PORT_EVCTRL_EVACT1_Pos 13

#define PORT_EVCTRL_PORTEI1_Pos 15

#define PORT_EVCTRL_PID2_Pos 16

#define PORT_EVCTRL_EVACT2_Pos 21

#define PORT_EVCTRL_PORTEI2_Pos 23

#define PORT_EVCTRL_PID3_Pos 24

#define PORT_EVCTRL_EVACT3_Pos 29

#define PORT_EVCTRL_PORTEI3_Pos 31

#define PORT_PMUX_OFFSET 48

#define PORT_PMUX_PMUXE_Pos 0

#define PORT_PMUX_PMUXO_Pos 4

#define PORT_PINCFG_OFFSET 64

#define PORT_PINCFG_PMUXEN_Pos 0

#define PORT_PINCFG_INEN_Pos 1

#define PORT_PINCFG_PULLEN_Pos 2

#define PORT_PINCFG_DRVSTR_Pos 6

#define REV_RSTC 768

#define RSTC_RCAUSE_OFFSET 0

#define RSTC_RCAUSE_POR_Pos 0

#define RSTC_RCAUSE_BODCORE_Pos 1

#define RSTC_RCAUSE_BODVDD_Pos 2

#define RSTC_RCAUSE_EXT_Pos 4

#define RSTC_RCAUSE_WDT_Pos 5

#define RSTC_RCAUSE_SYST_Pos 6

#define RSTC_RCAUSE_BACKUP_Pos 7

#define RSTC_BKUPEXIT_OFFSET 2

#define RSTC_BKUPEXIT_EXTWAKE_Pos 0

#define RSTC_BKUPEXIT_RTC_Pos 1

#define RSTC_BKUPEXIT_BBPS_Pos 2

#define REV_RTC 513

#define RTC_MODE0_CTRLA_OFFSET 0

#define RTC_MODE0_CTRLA_SWRST_Pos 0

#define RTC_MODE0_CTRLA_ENABLE_Pos 1

#define RTC_MODE0_CTRLA_MODE_Pos 2

#define RTC_MODE0_CTRLA_MATCHCLR_Pos 7

#define RTC_MODE0_CTRLA_PRESCALER_Pos 8

#define RTC_MODE0_CTRLA_BKTRST_Pos 13

#define RTC_MODE0_CTRLA_GPTRST_Pos 14

#define RTC_MODE0_CTRLA_COUNTSYNC_Pos 15

#define RTC_MODE1_CTRLA_OFFSET 0

#define RTC_MODE1_CTRLA_SWRST_Pos 0

#define RTC_MODE1_CTRLA_ENABLE_Pos 1

#define RTC_MODE1_CTRLA_MODE_Pos 2

#define RTC_MODE1_CTRLA_PRESCALER_Pos 8

#define RTC_MODE1_CTRLA_BKTRST_Pos 13

#define RTC_MODE1_CTRLA_GPTRST_Pos 14

#define RTC_MODE1_CTRLA_COUNTSYNC_Pos 15

#define RTC_MODE2_CTRLA_OFFSET 0

#define RTC_MODE2_CTRLA_SWRST_Pos 0

#define RTC_MODE2_CTRLA_ENABLE_Pos 1

#define RTC_MODE2_CTRLA_MODE_Pos 2

#define RTC_MODE2_CTRLA_CLKREP_Pos 6

#define RTC_MODE2_CTRLA_MATCHCLR_Pos 7

#define RTC_MODE2_CTRLA_PRESCALER_Pos 8

#define RTC_MODE2_CTRLA_BKTRST_Pos 13

#define RTC_MODE2_CTRLA_GPTRST_Pos 14

#define RTC_MODE2_CTRLA_CLOCKSYNC_Pos 15

#define RTC_MODE0_CTRLB_OFFSET 2

#define RTC_MODE0_CTRLB_GP0EN_Pos 0

#define RTC_MODE0_CTRLB_DEBMAJ_Pos 4

#define RTC_MODE0_CTRLB_DEBASYNC_Pos 5

#define RTC_MODE0_CTRLB_RTCOUT_Pos 6

#define RTC_MODE0_CTRLB_DMAEN_Pos 7

#define RTC_MODE0_CTRLB_DEBF_Pos 8

#define RTC_MODE0_CTRLB_ACTF_Pos 12

#define RTC_MODE1_CTRLB_OFFSET 2

#define RTC_MODE1_CTRLB_GP0EN_Pos 0

#define RTC_MODE1_CTRLB_DEBMAJ_Pos 4

#define RTC_MODE1_CTRLB_DEBASYNC_Pos 5

#define RTC_MODE1_CTRLB_RTCOUT_Pos 6

#define RTC_MODE1_CTRLB_DMAEN_Pos 7

#define RTC_MODE1_CTRLB_DEBF_Pos 8

#define RTC_MODE1_CTRLB_ACTF_Pos 12

#define RTC_MODE2_CTRLB_OFFSET 2

#define RTC_MODE2_CTRLB_GP0EN_Pos 0

#define RTC_MODE2_CTRLB_DEBMAJ_Pos 4

#define RTC_MODE2_CTRLB_DEBASYNC_Pos 5

#define RTC_MODE2_CTRLB_RTCOUT_Pos 6

#define RTC_MODE2_CTRLB_DMAEN_Pos 7

#define RTC_MODE2_CTRLB_DEBF_Pos 8

#define RTC_MODE2_CTRLB_ACTF_Pos 12

#define RTC_MODE0_EVCTRL_OFFSET 4

#define RTC_MODE0_EVCTRL_PEREO0_Pos 0

#define RTC_MODE0_EVCTRL_PEREO1_Pos 1

#define RTC_MODE0_EVCTRL_PEREO2_Pos 2

#define RTC_MODE0_EVCTRL_PEREO3_Pos 3

#define RTC_MODE0_EVCTRL_PEREO4_Pos 4

#define RTC_MODE0_EVCTRL_PEREO5_Pos 5

#define RTC_MODE0_EVCTRL_PEREO6_Pos 6

#define RTC_MODE0_EVCTRL_PEREO7_Pos 7

#define RTC_MODE0_EVCTRL_PEREO_Pos 0

#define RTC_MODE0_EVCTRL_CMPEO0_Pos 8

#define RTC_MODE0_EVCTRL_CMPEO_Pos 8

#define RTC_MODE0_EVCTRL_TAMPEREO_Pos 14

#define RTC_MODE0_EVCTRL_OVFEO_Pos 15

#define RTC_MODE0_EVCTRL_TAMPEVEI_Pos 16

#define RTC_MODE1_EVCTRL_OFFSET 4

#define RTC_MODE1_EVCTRL_PEREO0_Pos 0

#define RTC_MODE1_EVCTRL_PEREO1_Pos 1

#define RTC_MODE1_EVCTRL_PEREO2_Pos 2

#define RTC_MODE1_EVCTRL_PEREO3_Pos 3

#define RTC_MODE1_EVCTRL_PEREO4_Pos 4

#define RTC_MODE1_EVCTRL_PEREO5_Pos 5

#define RTC_MODE1_EVCTRL_PEREO6_Pos 6

#define RTC_MODE1_EVCTRL_PEREO7_Pos 7

#define RTC_MODE1_EVCTRL_PEREO_Pos 0

#define RTC_MODE1_EVCTRL_CMPEO0_Pos 8

#define RTC_MODE1_EVCTRL_CMPEO1_Pos 9

#define RTC_MODE1_EVCTRL_CMPEO_Pos 8

#define RTC_MODE1_EVCTRL_TAMPEREO_Pos 14

#define RTC_MODE1_EVCTRL_OVFEO_Pos 15

#define RTC_MODE1_EVCTRL_TAMPEVEI_Pos 16

#define RTC_MODE2_EVCTRL_OFFSET 4

#define RTC_MODE2_EVCTRL_PEREO0_Pos 0

#define RTC_MODE2_EVCTRL_PEREO1_Pos 1

#define RTC_MODE2_EVCTRL_PEREO2_Pos 2

#define RTC_MODE2_EVCTRL_PEREO3_Pos 3

#define RTC_MODE2_EVCTRL_PEREO4_Pos 4

#define RTC_MODE2_EVCTRL_PEREO5_Pos 5

#define RTC_MODE2_EVCTRL_PEREO6_Pos 6

#define RTC_MODE2_EVCTRL_PEREO7_Pos 7

#define RTC_MODE2_EVCTRL_PEREO_Pos 0

#define RTC_MODE2_EVCTRL_ALARMEO0_Pos 8

#define RTC_MODE2_EVCTRL_ALARMEO_Pos 8

#define RTC_MODE2_EVCTRL_TAMPEREO_Pos 14

#define RTC_MODE2_EVCTRL_OVFEO_Pos 15

#define RTC_MODE2_EVCTRL_TAMPEVEI_Pos 16

#define RTC_MODE0_INTENCLR_OFFSET 8

#define RTC_MODE0_INTENCLR_PER0_Pos 0

#define RTC_MODE0_INTENCLR_PER1_Pos 1

#define RTC_MODE0_INTENCLR_PER2_Pos 2

#define RTC_MODE0_INTENCLR_PER3_Pos 3

#define RTC_MODE0_INTENCLR_PER4_Pos 4

#define RTC_MODE0_INTENCLR_PER5_Pos 5

#define RTC_MODE0_INTENCLR_PER6_Pos 6

#define RTC_MODE0_INTENCLR_PER7_Pos 7

#define RTC_MODE0_INTENCLR_PER_Pos 0

#define RTC_MODE0_INTENCLR_CMP0_Pos 8

#define RTC_MODE0_INTENCLR_CMP_Pos 8

#define RTC_MODE0_INTENCLR_TAMPER_Pos 14

#define RTC_MODE0_INTENCLR_OVF_Pos 15

#define RTC_MODE1_INTENCLR_OFFSET 8

#define RTC_MODE1_INTENCLR_PER0_Pos 0

#define RTC_MODE1_INTENCLR_PER1_Pos 1

#define RTC_MODE1_INTENCLR_PER2_Pos 2

#define RTC_MODE1_INTENCLR_PER3_Pos 3

#define RTC_MODE1_INTENCLR_PER4_Pos 4

#define RTC_MODE1_INTENCLR_PER5_Pos 5

#define RTC_MODE1_INTENCLR_PER6_Pos 6

#define RTC_MODE1_INTENCLR_PER7_Pos 7

#define RTC_MODE1_INTENCLR_PER_Pos 0

#define RTC_MODE1_INTENCLR_CMP0_Pos 8

#define RTC_MODE1_INTENCLR_CMP1_Pos 9

#define RTC_MODE1_INTENCLR_CMP_Pos 8

#define RTC_MODE1_INTENCLR_TAMPER_Pos 14

#define RTC_MODE1_INTENCLR_OVF_Pos 15

#define RTC_MODE2_INTENCLR_OFFSET 8

#define RTC_MODE2_INTENCLR_PER0_Pos 0

#define RTC_MODE2_INTENCLR_PER1_Pos 1

#define RTC_MODE2_INTENCLR_PER2_Pos 2

#define RTC_MODE2_INTENCLR_PER3_Pos 3

#define RTC_MODE2_INTENCLR_PER4_Pos 4

#define RTC_MODE2_INTENCLR_PER5_Pos 5

#define RTC_MODE2_INTENCLR_PER6_Pos 6

#define RTC_MODE2_INTENCLR_PER7_Pos 7

#define RTC_MODE2_INTENCLR_PER_Pos 0

#define RTC_MODE2_INTENCLR_ALARM0_Pos 8

#define RTC_MODE2_INTENCLR_ALARM_Pos 8

#define RTC_MODE2_INTENCLR_TAMPER_Pos 14

#define RTC_MODE2_INTENCLR_OVF_Pos 15

#define RTC_MODE0_INTENSET_OFFSET 10

#define RTC_MODE0_INTENSET_PER0_Pos 0

#define RTC_MODE0_INTENSET_PER1_Pos 1

#define RTC_MODE0_INTENSET_PER2_Pos 2

#define RTC_MODE0_INTENSET_PER3_Pos 3

#define RTC_MODE0_INTENSET_PER4_Pos 4

#define RTC_MODE0_INTENSET_PER5_Pos 5

#define RTC_MODE0_INTENSET_PER6_Pos 6

#define RTC_MODE0_INTENSET_PER7_Pos 7

#define RTC_MODE0_INTENSET_PER_Pos 0

#define RTC_MODE0_INTENSET_CMP0_Pos 8

#define RTC_MODE0_INTENSET_CMP_Pos 8

#define RTC_MODE0_INTENSET_TAMPER_Pos 14

#define RTC_MODE0_INTENSET_OVF_Pos 15

#define RTC_MODE1_INTENSET_OFFSET 10

#define RTC_MODE1_INTENSET_PER0_Pos 0

#define RTC_MODE1_INTENSET_PER1_Pos 1

#define RTC_MODE1_INTENSET_PER2_Pos 2

#define RTC_MODE1_INTENSET_PER3_Pos 3

#define RTC_MODE1_INTENSET_PER4_Pos 4

#define RTC_MODE1_INTENSET_PER5_Pos 5

#define RTC_MODE1_INTENSET_PER6_Pos 6

#define RTC_MODE1_INTENSET_PER7_Pos 7

#define RTC_MODE1_INTENSET_PER_Pos 0

#define RTC_MODE1_INTENSET_CMP0_Pos 8

#define RTC_MODE1_INTENSET_CMP1_Pos 9

#define RTC_MODE1_INTENSET_CMP_Pos 8

#define RTC_MODE1_INTENSET_TAMPER_Pos 14

#define RTC_MODE1_INTENSET_OVF_Pos 15

#define RTC_MODE2_INTENSET_OFFSET 10

#define RTC_MODE2_INTENSET_PER0_Pos 0

#define RTC_MODE2_INTENSET_PER1_Pos 1

#define RTC_MODE2_INTENSET_PER2_Pos 2

#define RTC_MODE2_INTENSET_PER3_Pos 3

#define RTC_MODE2_INTENSET_PER4_Pos 4

#define RTC_MODE2_INTENSET_PER5_Pos 5

#define RTC_MODE2_INTENSET_PER6_Pos 6

#define RTC_MODE2_INTENSET_PER7_Pos 7

#define RTC_MODE2_INTENSET_PER_Pos 0

#define RTC_MODE2_INTENSET_ALARM0_Pos 8

#define RTC_MODE2_INTENSET_ALARM_Pos 8

#define RTC_MODE2_INTENSET_TAMPER_Pos 14

#define RTC_MODE2_INTENSET_OVF_Pos 15

#define RTC_MODE0_INTFLAG_OFFSET 12

#define RTC_MODE0_INTFLAG_PER0_Pos 0

#define RTC_MODE0_INTFLAG_PER1_Pos 1

#define RTC_MODE0_INTFLAG_PER2_Pos 2

#define RTC_MODE0_INTFLAG_PER3_Pos 3

#define RTC_MODE0_INTFLAG_PER4_Pos 4

#define RTC_MODE0_INTFLAG_PER5_Pos 5

#define RTC_MODE0_INTFLAG_PER6_Pos 6

#define RTC_MODE0_INTFLAG_PER7_Pos 7

#define RTC_MODE0_INTFLAG_PER_Pos 0

#define RTC_MODE0_INTFLAG_CMP0_Pos 8

#define RTC_MODE0_INTFLAG_CMP_Pos 8

#define RTC_MODE0_INTFLAG_TAMPER_Pos 14

#define RTC_MODE0_INTFLAG_OVF_Pos 15

#define RTC_MODE1_INTFLAG_OFFSET 12

#define RTC_MODE1_INTFLAG_PER0_Pos 0

#define RTC_MODE1_INTFLAG_PER1_Pos 1

#define RTC_MODE1_INTFLAG_PER2_Pos 2

#define RTC_MODE1_INTFLAG_PER3_Pos 3

#define RTC_MODE1_INTFLAG_PER4_Pos 4

#define RTC_MODE1_INTFLAG_PER5_Pos 5

#define RTC_MODE1_INTFLAG_PER6_Pos 6

#define RTC_MODE1_INTFLAG_PER7_Pos 7

#define RTC_MODE1_INTFLAG_PER_Pos 0

#define RTC_MODE1_INTFLAG_CMP0_Pos 8

#define RTC_MODE1_INTFLAG_CMP1_Pos 9

#define RTC_MODE1_INTFLAG_CMP_Pos 8

#define RTC_MODE1_INTFLAG_TAMPER_Pos 14

#define RTC_MODE1_INTFLAG_OVF_Pos 15

#define RTC_MODE2_INTFLAG_OFFSET 12

#define RTC_MODE2_INTFLAG_PER0_Pos 0

#define RTC_MODE2_INTFLAG_PER1_Pos 1

#define RTC_MODE2_INTFLAG_PER2_Pos 2

#define RTC_MODE2_INTFLAG_PER3_Pos 3

#define RTC_MODE2_INTFLAG_PER4_Pos 4

#define RTC_MODE2_INTFLAG_PER5_Pos 5

#define RTC_MODE2_INTFLAG_PER6_Pos 6

#define RTC_MODE2_INTFLAG_PER7_Pos 7

#define RTC_MODE2_INTFLAG_PER_Pos 0

#define RTC_MODE2_INTFLAG_ALARM0_Pos 8

#define RTC_MODE2_INTFLAG_ALARM_Pos 8

#define RTC_MODE2_INTFLAG_TAMPER_Pos 14

#define RTC_MODE2_INTFLAG_OVF_Pos 15

#define RTC_DBGCTRL_OFFSET 14

#define RTC_DBGCTRL_DBGRUN_Pos 0

#define RTC_MODE0_SYNCBUSY_OFFSET 16

#define RTC_MODE0_SYNCBUSY_SWRST_Pos 0

#define RTC_MODE0_SYNCBUSY_ENABLE_Pos 1

#define RTC_MODE0_SYNCBUSY_FREQCORR_Pos 2

#define RTC_MODE0_SYNCBUSY_COUNT_Pos 3

#define RTC_MODE0_SYNCBUSY_COMP0_Pos 5

#define RTC_MODE0_SYNCBUSY_COMP_Pos 5

#define RTC_MODE0_SYNCBUSY_COUNTSYNC_Pos 15

#define RTC_MODE0_SYNCBUSY_GP0_Pos 16

#define RTC_MODE0_SYNCBUSY_GP1_Pos 17

#define RTC_MODE0_SYNCBUSY_GP_Pos 16

#define RTC_MODE1_SYNCBUSY_OFFSET 16

#define RTC_MODE1_SYNCBUSY_SWRST_Pos 0

#define RTC_MODE1_SYNCBUSY_ENABLE_Pos 1

#define RTC_MODE1_SYNCBUSY_FREQCORR_Pos 2

#define RTC_MODE1_SYNCBUSY_COUNT_Pos 3

#define RTC_MODE1_SYNCBUSY_PER_Pos 4

#define RTC_MODE1_SYNCBUSY_COMP0_Pos 5

#define RTC_MODE1_SYNCBUSY_COMP1_Pos 6

#define RTC_MODE1_SYNCBUSY_COMP_Pos 5

#define RTC_MODE1_SYNCBUSY_COUNTSYNC_Pos 15

#define RTC_MODE1_SYNCBUSY_GP0_Pos 16

#define RTC_MODE1_SYNCBUSY_GP1_Pos 17

#define RTC_MODE1_SYNCBUSY_GP_Pos 16

#define RTC_MODE2_SYNCBUSY_OFFSET 16

#define RTC_MODE2_SYNCBUSY_SWRST_Pos 0

#define RTC_MODE2_SYNCBUSY_ENABLE_Pos 1

#define RTC_MODE2_SYNCBUSY_FREQCORR_Pos 2

#define RTC_MODE2_SYNCBUSY_CLOCK_Pos 3

#define RTC_MODE2_SYNCBUSY_ALARM0_Pos 5

#define RTC_MODE2_SYNCBUSY_ALARM_Pos 5

#define RTC_MODE2_SYNCBUSY_MASK0_Pos 11

#define RTC_MODE2_SYNCBUSY_MASK_Pos 11

#define RTC_MODE2_SYNCBUSY_CLOCKSYNC_Pos 15

#define RTC_MODE2_SYNCBUSY_GP0_Pos 16

#define RTC_MODE2_SYNCBUSY_GP1_Pos 17

#define RTC_MODE2_SYNCBUSY_GP_Pos 16

#define RTC_FREQCORR_OFFSET 20

#define RTC_FREQCORR_VALUE_Pos 0

#define RTC_FREQCORR_SIGN_Pos 7

#define RTC_MODE0_COUNT_OFFSET 24

#define RTC_MODE0_COUNT_COUNT_Pos 0

#define RTC_MODE1_COUNT_OFFSET 24

#define RTC_MODE1_COUNT_COUNT_Pos 0

#define RTC_MODE2_CLOCK_OFFSET 24

#define RTC_MODE2_CLOCK_SECOND_Pos 0

#define RTC_MODE2_CLOCK_MINUTE_Pos 6

#define RTC_MODE2_CLOCK_HOUR_Pos 12

#define RTC_MODE2_CLOCK_DAY_Pos 17

#define RTC_MODE2_CLOCK_MONTH_Pos 22

#define RTC_MODE2_CLOCK_YEAR_Pos 26

#define RTC_MODE1_PER_OFFSET 28

#define RTC_MODE1_PER_PER_Pos 0

#define RTC_MODE0_COMP_OFFSET 32

#define RTC_MODE0_COMP_COMP_Pos 0

#define RTC_MODE1_COMP_OFFSET 32

#define RTC_MODE1_COMP_COMP_Pos 0

#define RTC_MODE2_ALARM_OFFSET 32

#define RTC_MODE2_ALARM_SECOND_Pos 0

#define RTC_MODE2_ALARM_MINUTE_Pos 6

#define RTC_MODE2_ALARM_HOUR_Pos 12

#define RTC_MODE2_ALARM_DAY_Pos 17

#define RTC_MODE2_ALARM_MONTH_Pos 22

#define RTC_MODE2_ALARM_YEAR_Pos 26

#define RTC_MODE2_MASK_OFFSET 36

#define RTC_MODE2_MASK_SEL_Pos 0

#define RTC_GP_OFFSET 64

#define RTC_GP_GP_Pos 0

#define RTC_TAMPCTRL_OFFSET 96

#define RTC_TAMPCTRL_IN0ACT_Pos 0

#define RTC_TAMPCTRL_IN1ACT_Pos 2

#define RTC_TAMPCTRL_IN2ACT_Pos 4

#define RTC_TAMPCTRL_IN3ACT_Pos 6

#define RTC_TAMPCTRL_IN4ACT_Pos 8

#define RTC_TAMPCTRL_TAMLVL0_Pos 16

#define RTC_TAMPCTRL_TAMLVL1_Pos 17

#define RTC_TAMPCTRL_TAMLVL2_Pos 18

#define RTC_TAMPCTRL_TAMLVL3_Pos 19

#define RTC_TAMPCTRL_TAMLVL4_Pos 20

#define RTC_TAMPCTRL_TAMLVL_Pos 16

#define RTC_TAMPCTRL_DEBNC0_Pos 24

#define RTC_TAMPCTRL_DEBNC1_Pos 25

#define RTC_TAMPCTRL_DEBNC2_Pos 26

#define RTC_TAMPCTRL_DEBNC3_Pos 27

#define RTC_TAMPCTRL_DEBNC4_Pos 28

#define RTC_TAMPCTRL_DEBNC_Pos 24

#define RTC_MODE0_TIMESTAMP_OFFSET 100

#define RTC_MODE0_TIMESTAMP_COUNT_Pos 0

#define RTC_MODE1_TIMESTAMP_OFFSET 100

#define RTC_MODE1_TIMESTAMP_COUNT_Pos 0

#define RTC_MODE2_TIMESTAMP_OFFSET 100

#define RTC_MODE2_TIMESTAMP_SECOND_Pos 0

#define RTC_MODE2_TIMESTAMP_MINUTE_Pos 6

#define RTC_MODE2_TIMESTAMP_HOUR_Pos 12

#define RTC_MODE2_TIMESTAMP_DAY_Pos 17

#define RTC_MODE2_TIMESTAMP_MONTH_Pos 22

#define RTC_MODE2_TIMESTAMP_YEAR_Pos 26

#define RTC_TAMPID_OFFSET 104

#define RTC_TAMPID_TAMPID0_Pos 0

#define RTC_TAMPID_TAMPID1_Pos 1

#define RTC_TAMPID_TAMPID2_Pos 2

#define RTC_TAMPID_TAMPID3_Pos 3

#define RTC_TAMPID_TAMPID4_Pos 4

#define RTC_TAMPID_TAMPID_Pos 0

#define RTC_TAMPID_TAMPEVT_Pos 31

#define RTC_BKUP_OFFSET 128

#define RTC_BKUP_BKUP_Pos 0

#define REV_SERCOM 1024

#define SERCOM_I2CM_CTRLA_OFFSET 0

#define SERCOM_I2CM_CTRLA_SWRST_Pos 0

#define SERCOM_I2CM_CTRLA_ENABLE_Pos 1

#define SERCOM_I2CM_CTRLA_MODE_Pos 2

#define SERCOM_I2CM_CTRLA_RUNSTDBY_Pos 7

#define SERCOM_I2CM_CTRLA_PINOUT_Pos 16

#define SERCOM_I2CM_CTRLA_SDAHOLD_Pos 20

#define SERCOM_I2CM_CTRLA_MEXTTOEN_Pos 22

#define SERCOM_I2CM_CTRLA_SEXTTOEN_Pos 23

#define SERCOM_I2CM_CTRLA_SPEED_Pos 24

#define SERCOM_I2CM_CTRLA_SCLSM_Pos 27

#define SERCOM_I2CM_CTRLA_INACTOUT_Pos 28

#define SERCOM_I2CM_CTRLA_LOWTOUTEN_Pos 30

#define SERCOM_I2CS_CTRLA_OFFSET 0

#define SERCOM_I2CS_CTRLA_SWRST_Pos 0

#define SERCOM_I2CS_CTRLA_ENABLE_Pos 1

#define SERCOM_I2CS_CTRLA_MODE_Pos 2

#define SERCOM_I2CS_CTRLA_RUNSTDBY_Pos 7

#define SERCOM_I2CS_CTRLA_PINOUT_Pos 16

#define SERCOM_I2CS_CTRLA_SDAHOLD_Pos 20

#define SERCOM_I2CS_CTRLA_SEXTTOEN_Pos 23

#define SERCOM_I2CS_CTRLA_SPEED_Pos 24

#define SERCOM_I2CS_CTRLA_SCLSM_Pos 27

#define SERCOM_I2CS_CTRLA_LOWTOUTEN_Pos 30

#define SERCOM_SPI_CTRLA_OFFSET 0

#define SERCOM_SPI_CTRLA_SWRST_Pos 0

#define SERCOM_SPI_CTRLA_ENABLE_Pos 1

#define SERCOM_SPI_CTRLA_MODE_Pos 2

#define SERCOM_SPI_CTRLA_RUNSTDBY_Pos 7

#define SERCOM_SPI_CTRLA_IBON_Pos 8

#define SERCOM_SPI_CTRLA_DOPO_Pos 16

#define SERCOM_SPI_CTRLA_DIPO_Pos 20

#define SERCOM_SPI_CTRLA_FORM_Pos 24

#define SERCOM_SPI_CTRLA_CPHA_Pos 28

#define SERCOM_SPI_CTRLA_CPOL_Pos 29

#define SERCOM_SPI_CTRLA_DORD_Pos 30

#define SERCOM_USART_CTRLA_OFFSET 0

#define SERCOM_USART_CTRLA_SWRST_Pos 0

#define SERCOM_USART_CTRLA_ENABLE_Pos 1

#define SERCOM_USART_CTRLA_MODE_Pos 2

#define SERCOM_USART_CTRLA_RUNSTDBY_Pos 7

#define SERCOM_USART_CTRLA_IBON_Pos 8

#define SERCOM_USART_CTRLA_TXINV_Pos 9

#define SERCOM_USART_CTRLA_RXINV_Pos 10

#define SERCOM_USART_CTRLA_SAMPR_Pos 13

#define SERCOM_USART_CTRLA_TXPO_Pos 16

#define SERCOM_USART_CTRLA_RXPO_Pos 20

#define SERCOM_USART_CTRLA_SAMPA_Pos 22

#define SERCOM_USART_CTRLA_FORM_Pos 24

#define SERCOM_USART_CTRLA_CMODE_Pos 28

#define SERCOM_USART_CTRLA_CPOL_Pos 29

#define SERCOM_USART_CTRLA_DORD_Pos 30

#define SERCOM_I2CM_CTRLB_OFFSET 4

#define SERCOM_I2CM_CTRLB_SMEN_Pos 8

#define SERCOM_I2CM_CTRLB_QCEN_Pos 9

#define SERCOM_I2CM_CTRLB_CMD_Pos 16

#define SERCOM_I2CM_CTRLB_ACKACT_Pos 18

#define SERCOM_I2CS_CTRLB_OFFSET 4

#define SERCOM_I2CS_CTRLB_SMEN_Pos 8

#define SERCOM_I2CS_CTRLB_GCMD_Pos 9

#define SERCOM_I2CS_CTRLB_AACKEN_Pos 10

#define SERCOM_I2CS_CTRLB_AMODE_Pos 14

#define SERCOM_I2CS_CTRLB_CMD_Pos 16

#define SERCOM_I2CS_CTRLB_ACKACT_Pos 18

#define SERCOM_SPI_CTRLB_OFFSET 4

#define SERCOM_SPI_CTRLB_CHSIZE_Pos 0

#define SERCOM_SPI_CTRLB_PLOADEN_Pos 6

#define SERCOM_SPI_CTRLB_SSDE_Pos 9

#define SERCOM_SPI_CTRLB_MSSEN_Pos 13

#define SERCOM_SPI_CTRLB_AMODE_Pos 14

#define SERCOM_SPI_CTRLB_RXEN_Pos 17

#define SERCOM_USART_CTRLB_OFFSET 4

#define SERCOM_USART_CTRLB_CHSIZE_Pos 0

#define SERCOM_USART_CTRLB_SBMODE_Pos 6

#define SERCOM_USART_CTRLB_COLDEN_Pos 8

#define SERCOM_USART_CTRLB_SFDE_Pos 9

#define SERCOM_USART_CTRLB_ENC_Pos 10

#define SERCOM_USART_CTRLB_PMODE_Pos 13

#define SERCOM_USART_CTRLB_TXEN_Pos 16

#define SERCOM_USART_CTRLB_RXEN_Pos 17

#define SERCOM_USART_CTRLC_OFFSET 8

#define SERCOM_USART_CTRLC_GTIME_Pos 0

#define SERCOM_USART_CTRLC_INACK_Pos 16

#define SERCOM_USART_CTRLC_DSNACK_Pos 17

#define SERCOM_USART_CTRLC_MAXITER_Pos 20

#define SERCOM_I2CM_BAUD_OFFSET 12

#define SERCOM_I2CM_BAUD_BAUD_Pos 0

#define SERCOM_I2CM_BAUD_BAUDLOW_Pos 8

#define SERCOM_I2CM_BAUD_HSBAUD_Pos 16

#define SERCOM_I2CM_BAUD_HSBAUDLOW_Pos 24

#define SERCOM_SPI_BAUD_OFFSET 12

#define SERCOM_SPI_BAUD_BAUD_Pos 0

#define SERCOM_USART_BAUD_OFFSET 12

#define SERCOM_USART_BAUD_BAUD_Pos 0

#define SERCOM_USART_BAUD_FRAC_BAUD_Pos 0

#define SERCOM_USART_BAUD_FRAC_FP_Pos 13

#define SERCOM_USART_BAUD_FRACFP_BAUD_Pos 0

#define SERCOM_USART_BAUD_FRACFP_FP_Pos 13

#define SERCOM_USART_BAUD_USARTFP_BAUD_Pos 0

#define SERCOM_USART_RXPL_OFFSET 14

#define SERCOM_USART_RXPL_RXPL_Pos 0

#define SERCOM_I2CM_INTENCLR_OFFSET 20

#define SERCOM_I2CM_INTENCLR_MB_Pos 0

#define SERCOM_I2CM_INTENCLR_SB_Pos 1

#define SERCOM_I2CM_INTENCLR_ERROR_Pos 7

#define SERCOM_I2CS_INTENCLR_OFFSET 20

#define SERCOM_I2CS_INTENCLR_PREC_Pos 0

#define SERCOM_I2CS_INTENCLR_AMATCH_Pos 1

#define SERCOM_I2CS_INTENCLR_DRDY_Pos 2

#define SERCOM_I2CS_INTENCLR_ERROR_Pos 7

#define SERCOM_SPI_INTENCLR_OFFSET 20

#define SERCOM_SPI_INTENCLR_DRE_Pos 0

#define SERCOM_SPI_INTENCLR_TXC_Pos 1

#define SERCOM_SPI_INTENCLR_RXC_Pos 2

#define SERCOM_SPI_INTENCLR_SSL_Pos 3

#define SERCOM_SPI_INTENCLR_ERROR_Pos 7

#define SERCOM_USART_INTENCLR_OFFSET 20

#define SERCOM_USART_INTENCLR_DRE_Pos 0

#define SERCOM_USART_INTENCLR_TXC_Pos 1

#define SERCOM_USART_INTENCLR_RXC_Pos 2

#define SERCOM_USART_INTENCLR_RXS_Pos 3

#define SERCOM_USART_INTENCLR_CTSIC_Pos 4

#define SERCOM_USART_INTENCLR_RXBRK_Pos 5

#define SERCOM_USART_INTENCLR_ERROR_Pos 7

#define SERCOM_I2CM_INTENSET_OFFSET 22

#define SERCOM_I2CM_INTENSET_MB_Pos 0

#define SERCOM_I2CM_INTENSET_SB_Pos 1

#define SERCOM_I2CM_INTENSET_ERROR_Pos 7

#define SERCOM_I2CS_INTENSET_OFFSET 22

#define SERCOM_I2CS_INTENSET_PREC_Pos 0

#define SERCOM_I2CS_INTENSET_AMATCH_Pos 1

#define SERCOM_I2CS_INTENSET_DRDY_Pos 2

#define SERCOM_I2CS_INTENSET_ERROR_Pos 7

#define SERCOM_SPI_INTENSET_OFFSET 22

#define SERCOM_SPI_INTENSET_DRE_Pos 0

#define SERCOM_SPI_INTENSET_TXC_Pos 1

#define SERCOM_SPI_INTENSET_RXC_Pos 2

#define SERCOM_SPI_INTENSET_SSL_Pos 3

#define SERCOM_SPI_INTENSET_ERROR_Pos 7

#define SERCOM_USART_INTENSET_OFFSET 22

#define SERCOM_USART_INTENSET_DRE_Pos 0

#define SERCOM_USART_INTENSET_TXC_Pos 1

#define SERCOM_USART_INTENSET_RXC_Pos 2

#define SERCOM_USART_INTENSET_RXS_Pos 3

#define SERCOM_USART_INTENSET_CTSIC_Pos 4

#define SERCOM_USART_INTENSET_RXBRK_Pos 5

#define SERCOM_USART_INTENSET_ERROR_Pos 7

#define SERCOM_I2CM_INTFLAG_OFFSET 24

#define SERCOM_I2CM_INTFLAG_MB_Pos 0

#define SERCOM_I2CM_INTFLAG_SB_Pos 1

#define SERCOM_I2CM_INTFLAG_ERROR_Pos 7

#define SERCOM_I2CS_INTFLAG_OFFSET 24

#define SERCOM_I2CS_INTFLAG_PREC_Pos 0

#define SERCOM_I2CS_INTFLAG_AMATCH_Pos 1

#define SERCOM_I2CS_INTFLAG_DRDY_Pos 2

#define SERCOM_I2CS_INTFLAG_ERROR_Pos 7

#define SERCOM_SPI_INTFLAG_OFFSET 24

#define SERCOM_SPI_INTFLAG_DRE_Pos 0

#define SERCOM_SPI_INTFLAG_TXC_Pos 1

#define SERCOM_SPI_INTFLAG_RXC_Pos 2

#define SERCOM_SPI_INTFLAG_SSL_Pos 3

#define SERCOM_SPI_INTFLAG_ERROR_Pos 7

#define SERCOM_USART_INTFLAG_OFFSET 24

#define SERCOM_USART_INTFLAG_DRE_Pos 0

#define SERCOM_USART_INTFLAG_TXC_Pos 1

#define SERCOM_USART_INTFLAG_RXC_Pos 2

#define SERCOM_USART_INTFLAG_RXS_Pos 3

#define SERCOM_USART_INTFLAG_CTSIC_Pos 4

#define SERCOM_USART_INTFLAG_RXBRK_Pos 5

#define SERCOM_USART_INTFLAG_ERROR_Pos 7

#define SERCOM_I2CM_STATUS_OFFSET 26

#define SERCOM_I2CM_STATUS_BUSERR_Pos 0

#define SERCOM_I2CM_STATUS_ARBLOST_Pos 1

#define SERCOM_I2CM_STATUS_RXNACK_Pos 2

#define SERCOM_I2CM_STATUS_BUSSTATE_Pos 4

#define SERCOM_I2CM_STATUS_LOWTOUT_Pos 6

#define SERCOM_I2CM_STATUS_CLKHOLD_Pos 7

#define SERCOM_I2CM_STATUS_MEXTTOUT_Pos 8

#define SERCOM_I2CM_STATUS_SEXTTOUT_Pos 9

#define SERCOM_I2CM_STATUS_LENERR_Pos 10

#define SERCOM_I2CS_STATUS_OFFSET 26

#define SERCOM_I2CS_STATUS_BUSERR_Pos 0

#define SERCOM_I2CS_STATUS_COLL_Pos 1

#define SERCOM_I2CS_STATUS_RXNACK_Pos 2

#define SERCOM_I2CS_STATUS_DIR_Pos 3

#define SERCOM_I2CS_STATUS_SR_Pos 4

#define SERCOM_I2CS_STATUS_LOWTOUT_Pos 6

#define SERCOM_I2CS_STATUS_CLKHOLD_Pos 7

#define SERCOM_I2CS_STATUS_SEXTTOUT_Pos 9

#define SERCOM_I2CS_STATUS_HS_Pos 10

#define SERCOM_SPI_STATUS_OFFSET 26

#define SERCOM_SPI_STATUS_BUFOVF_Pos 2

#define SERCOM_USART_STATUS_OFFSET 26

#define SERCOM_USART_STATUS_PERR_Pos 0

#define SERCOM_USART_STATUS_FERR_Pos 1

#define SERCOM_USART_STATUS_BUFOVF_Pos 2

#define SERCOM_USART_STATUS_CTS_Pos 3

#define SERCOM_USART_STATUS_ISF_Pos 4

#define SERCOM_USART_STATUS_COLL_Pos 5

#define SERCOM_USART_STATUS_TXE_Pos 6

#define SERCOM_USART_STATUS_ITER_Pos 7

#define SERCOM_I2CM_SYNCBUSY_OFFSET 28

#define SERCOM_I2CM_SYNCBUSY_SWRST_Pos 0

#define SERCOM_I2CM_SYNCBUSY_ENABLE_Pos 1

#define SERCOM_I2CM_SYNCBUSY_SYSOP_Pos 2

#define SERCOM_I2CS_SYNCBUSY_OFFSET 28

#define SERCOM_I2CS_SYNCBUSY_SWRST_Pos 0

#define SERCOM_I2CS_SYNCBUSY_ENABLE_Pos 1

#define SERCOM_SPI_SYNCBUSY_OFFSET 28

#define SERCOM_SPI_SYNCBUSY_SWRST_Pos 0

#define SERCOM_SPI_SYNCBUSY_ENABLE_Pos 1

#define SERCOM_SPI_SYNCBUSY_CTRLB_Pos 2

#define SERCOM_USART_SYNCBUSY_OFFSET 28

#define SERCOM_USART_SYNCBUSY_SWRST_Pos 0

#define SERCOM_USART_SYNCBUSY_ENABLE_Pos 1

#define SERCOM_USART_SYNCBUSY_CTRLB_Pos 2

#define SERCOM_USART_RXERRCNT_OFFSET 32

#define SERCOM_I2CM_ADDR_OFFSET 36

#define SERCOM_I2CM_ADDR_ADDR_Pos 0

#define SERCOM_I2CM_ADDR_LENEN_Pos 13

#define SERCOM_I2CM_ADDR_HS_Pos 14

#define SERCOM_I2CM_ADDR_TENBITEN_Pos 15

#define SERCOM_I2CM_ADDR_LEN_Pos 16

#define SERCOM_I2CS_ADDR_OFFSET 36

#define SERCOM_I2CS_ADDR_GENCEN_Pos 0

#define SERCOM_I2CS_ADDR_ADDR_Pos 1

#define SERCOM_I2CS_ADDR_TENBITEN_Pos 15

#define SERCOM_I2CS_ADDR_ADDRMASK_Pos 17

#define SERCOM_SPI_ADDR_OFFSET 36

#define SERCOM_SPI_ADDR_ADDR_Pos 0

#define SERCOM_SPI_ADDR_ADDRMASK_Pos 16

#define SERCOM_I2CM_DATA_OFFSET 40

#define SERCOM_I2CM_DATA_DATA_Pos 0

#define SERCOM_I2CS_DATA_OFFSET 40

#define SERCOM_I2CS_DATA_DATA_Pos 0

#define SERCOM_SPI_DATA_OFFSET 40

#define SERCOM_SPI_DATA_DATA_Pos 0

#define SERCOM_USART_DATA_OFFSET 40

#define SERCOM_USART_DATA_DATA_Pos 0

#define SERCOM_I2CM_DBGCTRL_OFFSET 48

#define SERCOM_I2CM_DBGCTRL_DBGSTOP_Pos 0

#define SERCOM_SPI_DBGCTRL_OFFSET 48

#define SERCOM_SPI_DBGCTRL_DBGSTOP_Pos 0

#define SERCOM_USART_DBGCTRL_OFFSET 48

#define SERCOM_USART_DBGCTRL_DBGSTOP_Pos 0

#define REV_SLCD 256

#define SLCD_CTRLA_OFFSET 0

#define SLCD_CTRLA_SWRST_Pos 0

#define SLCD_CTRLA_ENABLE_Pos 1

#define SLCD_CTRLA_DUTY_Pos 2

#define SLCD_CTRLA_WMOD_Pos 5

#define SLCD_CTRLA_RUNSTDBY_Pos 6

#define SLCD_CTRLA_PRESC_Pos 8

#define SLCD_CTRLA_CKDIV_Pos 12

#define SLCD_CTRLA_BIAS_Pos 16

#define SLCD_CTRLA_XVLCD_Pos 19

#define SLCD_CTRLA_PRF_Pos 20

#define SLCD_CTRLA_DMFCS_Pos 22

#define SLCD_CTRLA_RRF_Pos 24

#define SLCD_CTRLB_OFFSET 4

#define SLCD_CTRLB_BBD_Pos 0

#define SLCD_CTRLB_BBEN_Pos 7

#define SLCD_CTRLB_LRD_Pos 8

#define SLCD_CTRLB_LREN_Pos 15

#define SLCD_CTRLC_OFFSET 6

#define SLCD_CTRLC_CLEAR_Pos 0

#define SLCD_CTRLC_LOCK_Pos 1

#define SLCD_CTRLC_ABMEN_Pos 2

#define SLCD_CTRLC_ACMEN_Pos 3

#define SLCD_CTRLC_CTST_Pos 4

#define SLCD_CTRLC_LPPM_Pos 8

#define SLCD_CTRLD_OFFSET 8

#define SLCD_CTRLD_BLANK_Pos 0

#define SLCD_CTRLD_BLINK_Pos 1

#define SLCD_CTRLD_CSREN_Pos 2

#define SLCD_CTRLD_FC0EN_Pos 4

#define SLCD_CTRLD_FC1EN_Pos 5

#define SLCD_CTRLD_FC2EN_Pos 6

#define SLCD_CTRLD_DISPEN_Pos 7

#define SLCD_EVCTRL_OFFSET 12

#define SLCD_EVCTRL_FC0OEO_Pos 0

#define SLCD_EVCTRL_FC1OEO_Pos 1

#define SLCD_EVCTRL_FC2OEO_Pos 2

#define SLCD_INTENCLR_OFFSET 13

#define SLCD_INTENCLR_FC0O_Pos 0

#define SLCD_INTENCLR_FC1O_Pos 1

#define SLCD_INTENCLR_FC2O_Pos 2

#define SLCD_INTENCLR_VLCDRT_Pos 3

#define SLCD_INTENCLR_VLCDST_Pos 4

#define SLCD_INTENCLR_PRST_Pos 5

#define SLCD_INTENSET_OFFSET 14

#define SLCD_INTENSET_FC0O_Pos 0

#define SLCD_INTENSET_FC1O_Pos 1

#define SLCD_INTENSET_FC2O_Pos 2

#define SLCD_INTENSET_VLCDRT_Pos 3

#define SLCD_INTENSET_VLCDST_Pos 4

#define SLCD_INTENSET_PRST_Pos 5

#define SLCD_INTFLAG_OFFSET 15

#define SLCD_INTFLAG_FC0O_Pos 0

#define SLCD_INTFLAG_FC1O_Pos 1

#define SLCD_INTFLAG_FC2O_Pos 2

#define SLCD_INTFLAG_VLCDRT_Pos 3

#define SLCD_INTFLAG_VLCDST_Pos 4

#define SLCD_INTFLAG_PRST_Pos 5

#define SLCD_STATUS_OFFSET 16

#define SLCD_STATUS_VLCDR_Pos 0

#define SLCD_STATUS_PRUN_Pos 1

#define SLCD_STATUS_VLCDS_Pos 2

#define SLCD_STATUS_CMWRBUSY_Pos 3

#define SLCD_STATUS_ACMBUSY_Pos 4

#define SLCD_STATUS_ABMBUSY_Pos 5

#define SLCD_SYNCBUSY_OFFSET 20

#define SLCD_SYNCBUSY_SWRST_Pos 0

#define SLCD_SYNCBUSY_ENABLE_Pos 1

#define SLCD_SYNCBUSY_CTRLD_Pos 2

#define SLCD_FC0_OFFSET 24

#define SLCD_FC0_OVF_Pos 0

#define SLCD_FC0_PB_Pos 7

#define SLCD_FC1_OFFSET 25

#define SLCD_FC1_OVF_Pos 0

#define SLCD_FC1_PB_Pos 7

#define SLCD_FC2_OFFSET 26

#define SLCD_FC2_OVF_Pos 0

#define SLCD_FC2_PB_Pos 7

#define SLCD_LPENL_OFFSET 28

#define SLCD_LPENL_LPEN_Pos 0

#define SLCD_LPENH_OFFSET 32

#define SLCD_LPENH_LPEN_Pos 0

#define SLCD_SDATAL0_OFFSET 36

#define SLCD_SDATAL0_SDATA_Pos 0

#define SLCD_SDATAH0_OFFSET 40

#define SLCD_SDATAH0_SDATA_Pos 0

#define SLCD_SDATAL1_OFFSET 44

#define SLCD_SDATAL1_SDATA_Pos 0

#define SLCD_SDATAH1_OFFSET 48

#define SLCD_SDATAH1_SDATA_Pos 0

#define SLCD_SDATAL2_OFFSET 52

#define SLCD_SDATAL2_SDATA_Pos 0

#define SLCD_SDATAH2_OFFSET 56

#define SLCD_SDATAH2_SDATA_Pos 0

#define SLCD_SDATAL3_OFFSET 60

#define SLCD_SDATAL3_SDATA_Pos 0

#define SLCD_SDATAH3_OFFSET 64

#define SLCD_SDATAH3_SDATA_Pos 0

#define SLCD_SDATAL4_OFFSET 68

#define SLCD_SDATAL4_SDATA_Pos 0

#define SLCD_SDATAH4_OFFSET 72

#define SLCD_SDATAH4_SDATA_Pos 0

#define SLCD_SDATAL5_OFFSET 76

#define SLCD_SDATAL5_SDATA_Pos 0

#define SLCD_SDATAH5_OFFSET 80

#define SLCD_SDATAH5_SDATA_Pos 0

#define SLCD_SDATAL6_OFFSET 84

#define SLCD_SDATAL6_SDATA_Pos 0

#define SLCD_SDATAH6_OFFSET 88

#define SLCD_SDATAH6_SDATA_Pos 0

#define SLCD_SDATAL7_OFFSET 92

#define SLCD_SDATAL7_SDATA_Pos 0

#define SLCD_SDATAH7_OFFSET 96

#define SLCD_SDATAH7_SDATA_Pos 0

#define SLCD_ISDATA_OFFSET 100

#define SLCD_ISDATA_SDATA_Pos 0

#define SLCD_ISDATA_SDMASK_Pos 8

#define SLCD_ISDATA_OFF_Pos 16

#define SLCD_BCFG_OFFSET 104

#define SLCD_BCFG_MODE_Pos 0

#define SLCD_BCFG_FCS_Pos 1

#define SLCD_BCFG_BSS0_Pos 8

#define SLCD_BCFG_BSS1_Pos 16

#define SLCD_CSRCFG_OFFSET 108

#define SLCD_CSRCFG_DIR_Pos 0

#define SLCD_CSRCFG_FCS_Pos 1

#define SLCD_CSRCFG_SIZE_Pos 4

#define SLCD_CSRCFG_DATA_Pos 8

#define SLCD_CMCFG_OFFSET 112

#define SLCD_CMCFG_NSEG_Pos 0

#define SLCD_CMCFG_DEC_Pos 3

#define SLCD_ACMCFG_OFFSET 116

#define SLCD_ACMCFG_NCOM_Pos 0

#define SLCD_ACMCFG_NDIG_Pos 4

#define SLCD_ACMCFG_STEPS_Pos 8

#define SLCD_ACMCFG_NDROW_Pos 16

#define SLCD_ACMCFG_MODE_Pos 23

#define SLCD_ACMCFG_STSEG_Pos 24

#define SLCD_ACMCFG_FCS_Pos 30

#define SLCD_ABMCFG_OFFSET 120

#define SLCD_ABMCFG_FCS_Pos 0

#define SLCD_ABMCFG_SIZE_Pos 2

#define SLCD_CMDATA_OFFSET 124

#define SLCD_CMDATA_SDATA_Pos 0

#define SLCD_CMDMASK_OFFSET 128

#define SLCD_CMDMASK_SDMASK_Pos 0

#define SLCD_CMINDEX_OFFSET 132

#define SLCD_CMINDEX_SINDEX_Pos 0

#define SLCD_CMINDEX_CINDEX_Pos 8

#define REV_SUPC 768

#define SUPC_INTENCLR_OFFSET 0

#define SUPC_INTENCLR_BOD33RDY_Pos 0

#define SUPC_INTENCLR_BOD33DET_Pos 1

#define SUPC_INTENCLR_B33SRDY_Pos 2

#define SUPC_INTENCLR_BOD12RDY_Pos 3

#define SUPC_INTENCLR_BOD12DET_Pos 4

#define SUPC_INTENCLR_B12SRDY_Pos 5

#define SUPC_INTENCLR_VREGRDY_Pos 8

#define SUPC_INTENCLR_APWSRDY_Pos 9

#define SUPC_INTENCLR_VCORERDY_Pos 10

#define SUPC_INTENSET_OFFSET 4

#define SUPC_INTENSET_BOD33RDY_Pos 0

#define SUPC_INTENSET_BOD33DET_Pos 1

#define SUPC_INTENSET_B33SRDY_Pos 2

#define SUPC_INTENSET_BOD12RDY_Pos 3

#define SUPC_INTENSET_BOD12DET_Pos 4

#define SUPC_INTENSET_B12SRDY_Pos 5

#define SUPC_INTENSET_VREGRDY_Pos 8

#define SUPC_INTENSET_APWSRDY_Pos 9

#define SUPC_INTENSET_VCORERDY_Pos 10

#define SUPC_INTFLAG_OFFSET 8

#define SUPC_INTFLAG_BOD33RDY_Pos 0

#define SUPC_INTFLAG_BOD33DET_Pos 1

#define SUPC_INTFLAG_B33SRDY_Pos 2

#define SUPC_INTFLAG_BOD12RDY_Pos 3

#define SUPC_INTFLAG_BOD12DET_Pos 4

#define SUPC_INTFLAG_B12SRDY_Pos 5

#define SUPC_INTFLAG_VREGRDY_Pos 8

#define SUPC_INTFLAG_APWSRDY_Pos 9

#define SUPC_INTFLAG_VCORERDY_Pos 10

#define SUPC_STATUS_OFFSET 12

#define SUPC_STATUS_BOD33RDY_Pos 0

#define SUPC_STATUS_BOD33DET_Pos 1

#define SUPC_STATUS_B33SRDY_Pos 2

#define SUPC_STATUS_BOD12RDY_Pos 3

#define SUPC_STATUS_BOD12DET_Pos 4

#define SUPC_STATUS_B12SRDY_Pos 5

#define SUPC_STATUS_VREGRDY_Pos 8

#define SUPC_STATUS_APWSRDY_Pos 9

#define SUPC_STATUS_VCORERDY_Pos 10

#define SUPC_STATUS_BBPS_Pos 11

#define SUPC_BOD33_OFFSET 16

#define SUPC_BOD33_ENABLE_Pos 1

#define SUPC_BOD33_HYST_Pos 2

#define SUPC_BOD33_ACTION_Pos 3

#define SUPC_BOD33_STDBYCFG_Pos 5

#define SUPC_BOD33_RUNSTDBY_Pos 6

#define SUPC_BOD33_RUNBKUP_Pos 7

#define SUPC_BOD33_ACTCFG_Pos 8

#define SUPC_BOD33_VMON_Pos 10

#define SUPC_BOD33_PSEL_Pos 12

#define SUPC_BOD33_LEVEL_Pos 16

#define SUPC_BOD33_BKUPLEVEL_Pos 24

#define SUPC_BOD12_OFFSET 20

#define SUPC_BOD12_ENABLE_Pos 1

#define SUPC_BOD12_HYST_Pos 2

#define SUPC_BOD12_ACTION_Pos 3

#define SUPC_BOD12_STDBYCFG_Pos 5

#define SUPC_BOD12_RUNSTDBY_Pos 6

#define SUPC_BOD12_ACTCFG_Pos 8

#define SUPC_BOD12_PSEL_Pos 12

#define SUPC_BOD12_LEVEL_Pos 16

#define SUPC_VREG_OFFSET 24

#define SUPC_VREG_ENABLE_Pos 1

#define SUPC_VREG_SEL_Pos 2

#define SUPC_VREG_STDBYPL0_Pos 5

#define SUPC_VREG_RUNSTDBY_Pos 6

#define SUPC_VREG_LPEFF_Pos 8

#define SUPC_VREG_VSVSTEP_Pos 16

#define SUPC_VREG_VSPER_Pos 24

#define SUPC_VREF_OFFSET 28

#define SUPC_VREF_TSEN_Pos 1

#define SUPC_VREF_VREFOE_Pos 2

#define SUPC_VREF_TSSEL_Pos 3

#define SUPC_VREF_RUNSTDBY_Pos 6

#define SUPC_VREF_ONDEMAND_Pos 7

#define SUPC_VREF_SEL_Pos 16

#define SUPC_BBPS_OFFSET 32

#define SUPC_BBPS_CONF_Pos 0

#define SUPC_BBPS_WAKEEN_Pos 2

#define SUPC_BBPS_PSOKEN_Pos 3

#define SUPC_BKOUT_OFFSET 36

#define SUPC_BKOUT_EN_Pos 0

#define SUPC_BKOUT_CLR_Pos 8

#define SUPC_BKOUT_SET_Pos 16

#define SUPC_BKOUT_RTCTGL_Pos 24

#define SUPC_BKIN_OFFSET 40

#define SUPC_BKIN_BKIN_Pos 0

#define REV_TC 512

#define TC_CTRLA_OFFSET 0

#define TC_CTRLA_SWRST_Pos 0

#define TC_CTRLA_ENABLE_Pos 1

#define TC_CTRLA_MODE_Pos 2

#define TC_CTRLA_PRESCSYNC_Pos 4

#define TC_CTRLA_RUNSTDBY_Pos 6

#define TC_CTRLA_ONDEMAND_Pos 7

#define TC_CTRLA_PRESCALER_Pos 8

#define TC_CTRLA_ALOCK_Pos 11

#define TC_CTRLA_CAPTEN0_Pos 16

#define TC_CTRLA_CAPTEN1_Pos 17

#define TC_CTRLA_CAPTEN_Pos 16

#define TC_CTRLA_COPEN0_Pos 20

#define TC_CTRLA_COPEN1_Pos 21

#define TC_CTRLA_COPEN_Pos 20

#define TC_CTRLBCLR_OFFSET 4

#define TC_CTRLBCLR_DIR_Pos 0

#define TC_CTRLBCLR_LUPD_Pos 1

#define TC_CTRLBCLR_ONESHOT_Pos 2

#define TC_CTRLBCLR_CMD_Pos 5

#define TC_CTRLBSET_OFFSET 5

#define TC_CTRLBSET_DIR_Pos 0

#define TC_CTRLBSET_LUPD_Pos 1

#define TC_CTRLBSET_ONESHOT_Pos 2

#define TC_CTRLBSET_CMD_Pos 5

#define TC_EVCTRL_OFFSET 6

#define TC_EVCTRL_EVACT_Pos 0

#define TC_EVCTRL_TCINV_Pos 4

#define TC_EVCTRL_TCEI_Pos 5

#define TC_EVCTRL_OVFEO_Pos 8

#define TC_EVCTRL_MCEO0_Pos 12

#define TC_EVCTRL_MCEO1_Pos 13

#define TC_EVCTRL_MCEO_Pos 12

#define TC_INTENCLR_OFFSET 8

#define TC_INTENCLR_OVF_Pos 0

#define TC_INTENCLR_ERR_Pos 1

#define TC_INTENCLR_MC0_Pos 4

#define TC_INTENCLR_MC1_Pos 5

#define TC_INTENCLR_MC_Pos 4

#define TC_INTENSET_OFFSET 9

#define TC_INTENSET_OVF_Pos 0

#define TC_INTENSET_ERR_Pos 1

#define TC_INTENSET_MC0_Pos 4

#define TC_INTENSET_MC1_Pos 5

#define TC_INTENSET_MC_Pos 4

#define TC_INTFLAG_OFFSET 10

#define TC_INTFLAG_OVF_Pos 0

#define TC_INTFLAG_ERR_Pos 1

#define TC_INTFLAG_MC0_Pos 4

#define TC_INTFLAG_MC1_Pos 5

#define TC_INTFLAG_MC_Pos 4

#define TC_STATUS_OFFSET 11

#define TC_STATUS_STOP_Pos 0

#define TC_STATUS_SLAVE_Pos 1

#define TC_STATUS_PERBUFV_Pos 3

#define TC_STATUS_CCBUFV0_Pos 4

#define TC_STATUS_CCBUFV1_Pos 5

#define TC_STATUS_CCBUFV_Pos 4

#define TC_WAVE_OFFSET 12

#define TC_WAVE_WAVEGEN_Pos 0

#define TC_DRVCTRL_OFFSET 13

#define TC_DRVCTRL_INVEN0_Pos 0

#define TC_DRVCTRL_INVEN1_Pos 1

#define TC_DRVCTRL_INVEN_Pos 0

#define TC_DBGCTRL_OFFSET 15

#define TC_DBGCTRL_DBGRUN_Pos 0

#define TC_SYNCBUSY_OFFSET 16

#define TC_SYNCBUSY_SWRST_Pos 0

#define TC_SYNCBUSY_ENABLE_Pos 1

#define TC_SYNCBUSY_CTRLB_Pos 2

#define TC_SYNCBUSY_STATUS_Pos 3

#define TC_SYNCBUSY_COUNT_Pos 4

#define TC_SYNCBUSY_PER_Pos 5

#define TC_SYNCBUSY_CC0_Pos 6

#define TC_SYNCBUSY_CC1_Pos 7

#define TC_SYNCBUSY_CC_Pos 6

#define TC_COUNT16_COUNT_OFFSET 20

#define TC_COUNT16_COUNT_COUNT_Pos 0

#define TC_COUNT32_COUNT_OFFSET 20

#define TC_COUNT32_COUNT_COUNT_Pos 0

#define TC_COUNT8_COUNT_OFFSET 20

#define TC_COUNT8_COUNT_COUNT_Pos 0

#define TC_COUNT8_PER_OFFSET 27

#define TC_COUNT8_PER_PER_Pos 0

#define TC_COUNT16_CC_OFFSET 28

#define TC_COUNT16_CC_CC_Pos 0

#define TC_COUNT32_CC_OFFSET 28

#define TC_COUNT32_CC_CC_Pos 0

#define TC_COUNT8_CC_OFFSET 28

#define TC_COUNT8_CC_CC_Pos 0

#define TC_COUNT8_PERBUF_OFFSET 47

#define TC_COUNT8_PERBUF_PERBUF_Pos 0

#define TC_COUNT16_CCBUF_OFFSET 48

#define TC_COUNT16_CCBUF_CCBUF_Pos 0

#define TC_COUNT32_CCBUF_OFFSET 48

#define TC_COUNT32_CCBUF_CCBUF_Pos 0

#define TC_COUNT8_CCBUF_OFFSET 48

#define TC_COUNT8_CCBUF_CCBUF_Pos 0

#define REV_TCC 768

#define TCC_CTRLA_OFFSET 0

#define TCC_CTRLA_SWRST_Pos 0

#define TCC_CTRLA_ENABLE_Pos 1

#define TCC_CTRLA_RESOLUTION_Pos 5

#define TCC_CTRLA_PRESCALER_Pos 8

#define TCC_CTRLA_RUNSTDBY_Pos 11

#define TCC_CTRLA_PRESCSYNC_Pos 12

#define TCC_CTRLA_ALOCK_Pos 14

#define TCC_CTRLA_MSYNC_Pos 15

#define TCC_CTRLA_DMAOS_Pos 23

#define TCC_CTRLA_CPTEN0_Pos 24

#define TCC_CTRLA_CPTEN1_Pos 25

#define TCC_CTRLA_CPTEN2_Pos 26

#define TCC_CTRLA_CPTEN3_Pos 27

#define TCC_CTRLA_CPTEN_Pos 24

#define TCC_CTRLBCLR_OFFSET 4

#define TCC_CTRLBCLR_DIR_Pos 0

#define TCC_CTRLBCLR_LUPD_Pos 1

#define TCC_CTRLBCLR_ONESHOT_Pos 2

#define TCC_CTRLBCLR_IDXCMD_Pos 3

#define TCC_CTRLBCLR_CMD_Pos 5

#define TCC_CTRLBSET_OFFSET 5

#define TCC_CTRLBSET_DIR_Pos 0

#define TCC_CTRLBSET_LUPD_Pos 1

#define TCC_CTRLBSET_ONESHOT_Pos 2

#define TCC_CTRLBSET_IDXCMD_Pos 3

#define TCC_CTRLBSET_CMD_Pos 5

#define TCC_SYNCBUSY_OFFSET 8

#define TCC_SYNCBUSY_SWRST_Pos 0

#define TCC_SYNCBUSY_ENABLE_Pos 1

#define TCC_SYNCBUSY_CTRLB_Pos 2

#define TCC_SYNCBUSY_STATUS_Pos 3

#define TCC_SYNCBUSY_COUNT_Pos 4

#define TCC_SYNCBUSY_PATT_Pos 5

#define TCC_SYNCBUSY_WAVE_Pos 6

#define TCC_SYNCBUSY_PER_Pos 7

#define TCC_SYNCBUSY_CC0_Pos 8

#define TCC_SYNCBUSY_CC1_Pos 9

#define TCC_SYNCBUSY_CC2_Pos 10

#define TCC_SYNCBUSY_CC3_Pos 11

#define TCC_SYNCBUSY_CC_Pos 8

#define TCC_FCTRLA_OFFSET 12

#define TCC_FCTRLA_SRC_Pos 0

#define TCC_FCTRLA_KEEP_Pos 3

#define TCC_FCTRLA_QUAL_Pos 4

#define TCC_FCTRLA_BLANK_Pos 5

#define TCC_FCTRLA_RESTART_Pos 7

#define TCC_FCTRLA_HALT_Pos 8

#define TCC_FCTRLA_CHSEL_Pos 10

#define TCC_FCTRLA_CAPTURE_Pos 12

#define TCC_FCTRLA_BLANKPRESC_Pos 15

#define TCC_FCTRLA_BLANKVAL_Pos 16

#define TCC_FCTRLA_FILTERVAL_Pos 24

#define TCC_FCTRLB_OFFSET 16

#define TCC_FCTRLB_SRC_Pos 0

#define TCC_FCTRLB_KEEP_Pos 3

#define TCC_FCTRLB_QUAL_Pos 4

#define TCC_FCTRLB_BLANK_Pos 5

#define TCC_FCTRLB_RESTART_Pos 7

#define TCC_FCTRLB_HALT_Pos 8

#define TCC_FCTRLB_CHSEL_Pos 10

#define TCC_FCTRLB_CAPTURE_Pos 12

#define TCC_FCTRLB_BLANKPRESC_Pos 15

#define TCC_FCTRLB_BLANKVAL_Pos 16

#define TCC_FCTRLB_FILTERVAL_Pos 24

#define TCC_WEXCTRL_OFFSET 20

#define TCC_WEXCTRL_OTMX_Pos 0

#define TCC_WEXCTRL_DTIEN0_Pos 8

#define TCC_WEXCTRL_DTIEN1_Pos 9

#define TCC_WEXCTRL_DTIEN2_Pos 10

#define TCC_WEXCTRL_DTIEN3_Pos 11

#define TCC_WEXCTRL_DTIEN_Pos 8

#define TCC_WEXCTRL_DTLS_Pos 16

#define TCC_WEXCTRL_DTHS_Pos 24

#define TCC_DRVCTRL_OFFSET 24

#define TCC_DRVCTRL_NRE0_Pos 0

#define TCC_DRVCTRL_NRE1_Pos 1

#define TCC_DRVCTRL_NRE2_Pos 2

#define TCC_DRVCTRL_NRE3_Pos 3

#define TCC_DRVCTRL_NRE4_Pos 4

#define TCC_DRVCTRL_NRE5_Pos 5

#define TCC_DRVCTRL_NRE6_Pos 6

#define TCC_DRVCTRL_NRE7_Pos 7

#define TCC_DRVCTRL_NRE_Pos 0

#define TCC_DRVCTRL_NRV0_Pos 8

#define TCC_DRVCTRL_NRV1_Pos 9

#define TCC_DRVCTRL_NRV2_Pos 10

#define TCC_DRVCTRL_NRV3_Pos 11

#define TCC_DRVCTRL_NRV4_Pos 12

#define TCC_DRVCTRL_NRV5_Pos 13

#define TCC_DRVCTRL_NRV6_Pos 14

#define TCC_DRVCTRL_NRV7_Pos 15

#define TCC_DRVCTRL_NRV_Pos 8

#define TCC_DRVCTRL_INVEN0_Pos 16

#define TCC_DRVCTRL_INVEN1_Pos 17

#define TCC_DRVCTRL_INVEN2_Pos 18

#define TCC_DRVCTRL_INVEN3_Pos 19

#define TCC_DRVCTRL_INVEN4_Pos 20

#define TCC_DRVCTRL_INVEN5_Pos 21

#define TCC_DRVCTRL_INVEN6_Pos 22

#define TCC_DRVCTRL_INVEN7_Pos 23

#define TCC_DRVCTRL_INVEN_Pos 16

#define TCC_DRVCTRL_FILTERVAL0_Pos 24

#define TCC_DRVCTRL_FILTERVAL1_Pos 28

#define TCC_DBGCTRL_OFFSET 30

#define TCC_DBGCTRL_DBGRUN_Pos 0

#define TCC_DBGCTRL_FDDBD_Pos 2

#define TCC_EVCTRL_OFFSET 32

#define TCC_EVCTRL_EVACT0_Pos 0

#define TCC_EVCTRL_EVACT1_Pos 3

#define TCC_EVCTRL_CNTSEL_Pos 6

#define TCC_EVCTRL_OVFEO_Pos 8

#define TCC_EVCTRL_TRGEO_Pos 9

#define TCC_EVCTRL_CNTEO_Pos 10

#define TCC_EVCTRL_TCINV0_Pos 12

#define TCC_EVCTRL_TCINV1_Pos 13

#define TCC_EVCTRL_TCINV_Pos 12

#define TCC_EVCTRL_TCEI0_Pos 14

#define TCC_EVCTRL_TCEI1_Pos 15

#define TCC_EVCTRL_TCEI_Pos 14

#define TCC_EVCTRL_MCEI0_Pos 16

#define TCC_EVCTRL_MCEI1_Pos 17

#define TCC_EVCTRL_MCEI2_Pos 18

#define TCC_EVCTRL_MCEI3_Pos 19

#define TCC_EVCTRL_MCEI_Pos 16

#define TCC_EVCTRL_MCEO0_Pos 24

#define TCC_EVCTRL_MCEO1_Pos 25

#define TCC_EVCTRL_MCEO2_Pos 26

#define TCC_EVCTRL_MCEO3_Pos 27

#define TCC_EVCTRL_MCEO_Pos 24

#define TCC_INTENCLR_OFFSET 36

#define TCC_INTENCLR_OVF_Pos 0

#define TCC_INTENCLR_TRG_Pos 1

#define TCC_INTENCLR_CNT_Pos 2

#define TCC_INTENCLR_ERR_Pos 3

#define TCC_INTENCLR_UFS_Pos 10

#define TCC_INTENCLR_DFS_Pos 11

#define TCC_INTENCLR_FAULTA_Pos 12

#define TCC_INTENCLR_FAULTB_Pos 13

#define TCC_INTENCLR_FAULT0_Pos 14

#define TCC_INTENCLR_FAULT1_Pos 15

#define TCC_INTENCLR_MC0_Pos 16

#define TCC_INTENCLR_MC1_Pos 17

#define TCC_INTENCLR_MC2_Pos 18

#define TCC_INTENCLR_MC3_Pos 19

#define TCC_INTENCLR_MC_Pos 16

#define TCC_INTENSET_OFFSET 40

#define TCC_INTENSET_OVF_Pos 0

#define TCC_INTENSET_TRG_Pos 1

#define TCC_INTENSET_CNT_Pos 2

#define TCC_INTENSET_ERR_Pos 3

#define TCC_INTENSET_UFS_Pos 10

#define TCC_INTENSET_DFS_Pos 11

#define TCC_INTENSET_FAULTA_Pos 12

#define TCC_INTENSET_FAULTB_Pos 13

#define TCC_INTENSET_FAULT0_Pos 14

#define TCC_INTENSET_FAULT1_Pos 15

#define TCC_INTENSET_MC0_Pos 16

#define TCC_INTENSET_MC1_Pos 17

#define TCC_INTENSET_MC2_Pos 18

#define TCC_INTENSET_MC3_Pos 19

#define TCC_INTENSET_MC_Pos 16

#define TCC_INTFLAG_OFFSET 44

#define TCC_INTFLAG_OVF_Pos 0

#define TCC_INTFLAG_TRG_Pos 1

#define TCC_INTFLAG_CNT_Pos 2

#define TCC_INTFLAG_ERR_Pos 3

#define TCC_INTFLAG_UFS_Pos 10

#define TCC_INTFLAG_DFS_Pos 11

#define TCC_INTFLAG_FAULTA_Pos 12

#define TCC_INTFLAG_FAULTB_Pos 13

#define TCC_INTFLAG_FAULT0_Pos 14

#define TCC_INTFLAG_FAULT1_Pos 15

#define TCC_INTFLAG_MC0_Pos 16

#define TCC_INTFLAG_MC1_Pos 17

#define TCC_INTFLAG_MC2_Pos 18

#define TCC_INTFLAG_MC3_Pos 19

#define TCC_INTFLAG_MC_Pos 16

#define TCC_STATUS_OFFSET 48

#define TCC_STATUS_STOP_Pos 0

#define TCC_STATUS_IDX_Pos 1

#define TCC_STATUS_UFS_Pos 2

#define TCC_STATUS_DFS_Pos 3

#define TCC_STATUS_SLAVE_Pos 4

#define TCC_STATUS_PATTBUFV_Pos 5

#define TCC_STATUS_PERBUFV_Pos 7

#define TCC_STATUS_FAULTAIN_Pos 8

#define TCC_STATUS_FAULTBIN_Pos 9

#define TCC_STATUS_FAULT0IN_Pos 10

#define TCC_STATUS_FAULT1IN_Pos 11

#define TCC_STATUS_FAULTA_Pos 12

#define TCC_STATUS_FAULTB_Pos 13

#define TCC_STATUS_FAULT0_Pos 14

#define TCC_STATUS_FAULT1_Pos 15

#define TCC_STATUS_CCBUFV0_Pos 16

#define TCC_STATUS_CCBUFV1_Pos 17

#define TCC_STATUS_CCBUFV2_Pos 18

#define TCC_STATUS_CCBUFV3_Pos 19

#define TCC_STATUS_CCBUFV_Pos 16

#define TCC_STATUS_CMP0_Pos 24

#define TCC_STATUS_CMP1_Pos 25

#define TCC_STATUS_CMP2_Pos 26

#define TCC_STATUS_CMP3_Pos 27

#define TCC_STATUS_CMP_Pos 24

#define TCC_COUNT_OFFSET 52

#define TCC_COUNT_DITH4_COUNT_Pos 4

#define TCC_COUNT_DITH5_COUNT_Pos 5

#define TCC_COUNT_DITH6_COUNT_Pos 6

#define TCC_COUNT_COUNT_Pos 0

#define TCC_PATT_OFFSET 56

#define TCC_PATT_PGE0_Pos 0

#define TCC_PATT_PGE1_Pos 1

#define TCC_PATT_PGE2_Pos 2

#define TCC_PATT_PGE3_Pos 3

#define TCC_PATT_PGE4_Pos 4

#define TCC_PATT_PGE5_Pos 5

#define TCC_PATT_PGE6_Pos 6

#define TCC_PATT_PGE7_Pos 7

#define TCC_PATT_PGE_Pos 0

#define TCC_PATT_PGV0_Pos 8

#define TCC_PATT_PGV1_Pos 9

#define TCC_PATT_PGV2_Pos 10

#define TCC_PATT_PGV3_Pos 11

#define TCC_PATT_PGV4_Pos 12

#define TCC_PATT_PGV5_Pos 13

#define TCC_PATT_PGV6_Pos 14

#define TCC_PATT_PGV7_Pos 15

#define TCC_PATT_PGV_Pos 8

#define TCC_WAVE_OFFSET 60

#define TCC_WAVE_WAVEGEN_Pos 0

#define TCC_WAVE_RAMP_Pos 4

#define TCC_WAVE_CIPEREN_Pos 7

#define TCC_WAVE_CICCEN0_Pos 8

#define TCC_WAVE_CICCEN1_Pos 9

#define TCC_WAVE_CICCEN2_Pos 10

#define TCC_WAVE_CICCEN3_Pos 11

#define TCC_WAVE_CICCEN_Pos 8

#define TCC_WAVE_POL0_Pos 16

#define TCC_WAVE_POL1_Pos 17

#define TCC_WAVE_POL2_Pos 18

#define TCC_WAVE_POL3_Pos 19

#define TCC_WAVE_POL_Pos 16

#define TCC_WAVE_SWAP0_Pos 24

#define TCC_WAVE_SWAP1_Pos 25

#define TCC_WAVE_SWAP2_Pos 26

#define TCC_WAVE_SWAP3_Pos 27

#define TCC_WAVE_SWAP_Pos 24

#define TCC_PER_OFFSET 64

#define TCC_PER_DITH4_DITHER_Pos 0

#define TCC_PER_DITH4_PER_Pos 4

#define TCC_PER_DITH5_DITHER_Pos 0

#define TCC_PER_DITH5_PER_Pos 5

#define TCC_PER_DITH6_DITHER_Pos 0

#define TCC_PER_DITH6_PER_Pos 6

#define TCC_PER_PER_Pos 0

#define TCC_CC_OFFSET 68

#define TCC_CC_DITH4_DITHER_Pos 0

#define TCC_CC_DITH4_CC_Pos 4

#define TCC_CC_DITH5_DITHER_Pos 0

#define TCC_CC_DITH5_CC_Pos 5

#define TCC_CC_DITH6_DITHER_Pos 0

#define TCC_CC_DITH6_CC_Pos 6

#define TCC_CC_CC_Pos 0

#define TCC_PATTBUF_OFFSET 100

#define TCC_PATTBUF_PGEB0_Pos 0

#define TCC_PATTBUF_PGEB1_Pos 1

#define TCC_PATTBUF_PGEB2_Pos 2

#define TCC_PATTBUF_PGEB3_Pos 3

#define TCC_PATTBUF_PGEB4_Pos 4

#define TCC_PATTBUF_PGEB5_Pos 5

#define TCC_PATTBUF_PGEB6_Pos 6

#define TCC_PATTBUF_PGEB7_Pos 7

#define TCC_PATTBUF_PGEB_Pos 0

#define TCC_PATTBUF_PGVB0_Pos 8

#define TCC_PATTBUF_PGVB1_Pos 9

#define TCC_PATTBUF_PGVB2_Pos 10

#define TCC_PATTBUF_PGVB3_Pos 11

#define TCC_PATTBUF_PGVB4_Pos 12

#define TCC_PATTBUF_PGVB5_Pos 13

#define TCC_PATTBUF_PGVB6_Pos 14

#define TCC_PATTBUF_PGVB7_Pos 15

#define TCC_PATTBUF_PGVB_Pos 8

#define TCC_PERBUF_OFFSET 108

#define TCC_PERBUF_DITH4_DITHERBUF_Pos 0

#define TCC_PERBUF_DITH4_PERBUF_Pos 4

#define TCC_PERBUF_DITH5_DITHERBUF_Pos 0

#define TCC_PERBUF_DITH5_PERBUF_Pos 5

#define TCC_PERBUF_DITH6_DITHERBUF_Pos 0

#define TCC_PERBUF_DITH6_PERBUF_Pos 6

#define TCC_PERBUF_PERBUF_Pos 0

#define TCC_CCBUF_OFFSET 112

#define TCC_CCBUF_DITH4_CCBUF_Pos 0

#define TCC_CCBUF_DITH4_DITHERBUF_Pos 4

#define TCC_CCBUF_DITH5_DITHERBUF_Pos 0

#define TCC_CCBUF_DITH5_CCBUF_Pos 5

#define TCC_CCBUF_DITH6_DITHERBUF_Pos 0

#define TCC_CCBUF_DITH6_CCBUF_Pos 6

#define TCC_CCBUF_CCBUF_Pos 0

#define REV_TRNG 257

#define TRNG_CTRLA_OFFSET 0

#define TRNG_CTRLA_ENABLE_Pos 1

#define TRNG_CTRLA_RUNSTDBY_Pos 6

#define TRNG_EVCTRL_OFFSET 4

#define TRNG_EVCTRL_DATARDYEO_Pos 0

#define TRNG_INTENCLR_OFFSET 8

#define TRNG_INTENCLR_DATARDY_Pos 0

#define TRNG_INTENSET_OFFSET 9

#define TRNG_INTENSET_DATARDY_Pos 0

#define TRNG_INTFLAG_OFFSET 10

#define TRNG_INTFLAG_DATARDY_Pos 0

#define TRNG_DATA_OFFSET 32

#define TRNG_DATA_DATA_Pos 0

#define REV_USB 273

#define USB_CTRLA_OFFSET 0

#define USB_CTRLA_SWRST_Pos 0

#define USB_CTRLA_ENABLE_Pos 1

#define USB_CTRLA_RUNSTDBY_Pos 2

#define USB_CTRLA_MODE_Pos 7

#define USB_SYNCBUSY_OFFSET 2

#define USB_SYNCBUSY_SWRST_Pos 0

#define USB_SYNCBUSY_ENABLE_Pos 1

#define USB_QOSCTRL_OFFSET 3

#define USB_QOSCTRL_CQOS_Pos 0

#define USB_QOSCTRL_DQOS_Pos 2

#define USB_DEVICE_CTRLB_OFFSET 8

#define USB_DEVICE_CTRLB_DETACH_Pos 0

#define USB_DEVICE_CTRLB_UPRSM_Pos 1

#define USB_DEVICE_CTRLB_SPDCONF_Pos 2

#define USB_DEVICE_CTRLB_NREPLY_Pos 4

#define USB_DEVICE_CTRLB_TSTJ_Pos 5

#define USB_DEVICE_CTRLB_TSTK_Pos 6

#define USB_DEVICE_CTRLB_TSTPCKT_Pos 7

#define USB_DEVICE_CTRLB_OPMODE2_Pos 8

#define USB_DEVICE_CTRLB_GNAK_Pos 9

#define USB_DEVICE_CTRLB_LPMHDSK_Pos 10

#define USB_DEVICE_DADD_OFFSET 10

#define USB_DEVICE_DADD_DADD_Pos 0

#define USB_DEVICE_DADD_ADDEN_Pos 7

#define USB_DEVICE_STATUS_OFFSET 12

#define USB_DEVICE_STATUS_SPEED_Pos 2

#define USB_DEVICE_STATUS_LINESTATE_Pos 6

#define USB_FSMSTATUS_OFFSET 13

#define USB_FSMSTATUS_FSMSTATE_Pos 0

#define USB_DEVICE_FNUM_OFFSET 16

#define USB_DEVICE_FNUM_MFNUM_Pos 0

#define USB_DEVICE_FNUM_FNUM_Pos 3

#define USB_DEVICE_FNUM_FNCERR_Pos 15

#define USB_DEVICE_INTENCLR_OFFSET 20

#define USB_DEVICE_INTENCLR_SUSPEND_Pos 0

#define USB_DEVICE_INTENCLR_MSOF_Pos 1

#define USB_DEVICE_INTENCLR_SOF_Pos 2

#define USB_DEVICE_INTENCLR_EORST_Pos 3

#define USB_DEVICE_INTENCLR_WAKEUP_Pos 4

#define USB_DEVICE_INTENCLR_EORSM_Pos 5

#define USB_DEVICE_INTENCLR_UPRSM_Pos 6

#define USB_DEVICE_INTENCLR_RAMACER_Pos 7

#define USB_DEVICE_INTENCLR_LPMNYET_Pos 8

#define USB_DEVICE_INTENCLR_LPMSUSP_Pos 9

#define USB_DEVICE_INTENSET_OFFSET 24

#define USB_DEVICE_INTENSET_SUSPEND_Pos 0

#define USB_DEVICE_INTENSET_MSOF_Pos 1

#define USB_DEVICE_INTENSET_SOF_Pos 2

#define USB_DEVICE_INTENSET_EORST_Pos 3

#define USB_DEVICE_INTENSET_WAKEUP_Pos 4

#define USB_DEVICE_INTENSET_EORSM_Pos 5

#define USB_DEVICE_INTENSET_UPRSM_Pos 6

#define USB_DEVICE_INTENSET_RAMACER_Pos 7

#define USB_DEVICE_INTENSET_LPMNYET_Pos 8

#define USB_DEVICE_INTENSET_LPMSUSP_Pos 9

#define USB_DEVICE_INTFLAG_OFFSET 28

#define USB_DEVICE_INTFLAG_SUSPEND_Pos 0

#define USB_DEVICE_INTFLAG_MSOF_Pos 1

#define USB_DEVICE_INTFLAG_SOF_Pos 2

#define USB_DEVICE_INTFLAG_EORST_Pos 3

#define USB_DEVICE_INTFLAG_WAKEUP_Pos 4

#define USB_DEVICE_INTFLAG_EORSM_Pos 5

#define USB_DEVICE_INTFLAG_UPRSM_Pos 6

#define USB_DEVICE_INTFLAG_RAMACER_Pos 7

#define USB_DEVICE_INTFLAG_LPMNYET_Pos 8

#define USB_DEVICE_INTFLAG_LPMSUSP_Pos 9

#define USB_DEVICE_EPINTSMRY_OFFSET 32

#define USB_DEVICE_EPINTSMRY_EPINT0_Pos 0

#define USB_DEVICE_EPINTSMRY_EPINT1_Pos 1

#define USB_DEVICE_EPINTSMRY_EPINT2_Pos 2

#define USB_DEVICE_EPINTSMRY_EPINT3_Pos 3

#define USB_DEVICE_EPINTSMRY_EPINT4_Pos 4

#define USB_DEVICE_EPINTSMRY_EPINT5_Pos 5

#define USB_DEVICE_EPINTSMRY_EPINT6_Pos 6

#define USB_DEVICE_EPINTSMRY_EPINT7_Pos 7

#define USB_DEVICE_EPINTSMRY_EPINT_Pos 0

#define USB_DESCADD_OFFSET 36

#define USB_DESCADD_DESCADD_Pos 0

#define USB_PADCAL_OFFSET 40

#define USB_PADCAL_TRANSP_Pos 0

#define USB_PADCAL_TRANSN_Pos 6

#define USB_PADCAL_TRIM_Pos 12

#define USB_DEVICE_EPCFG_OFFSET 256

#define USB_DEVICE_EPCFG_EPTYPE0_Pos 0

#define USB_DEVICE_EPCFG_EPTYPE1_Pos 4

#define USB_DEVICE_EPCFG_NYETDIS_Pos 7

#define USB_DEVICE_EPSTATUSCLR_OFFSET 260

#define USB_DEVICE_EPSTATUSCLR_DTGLOUT_Pos 0

#define USB_DEVICE_EPSTATUSCLR_DTGLIN_Pos 1

#define USB_DEVICE_EPSTATUSCLR_CURBK_Pos 2

#define USB_DEVICE_EPSTATUSCLR_STALLRQ0_Pos 4

#define USB_DEVICE_EPSTATUSCLR_STALLRQ1_Pos 5

#define USB_DEVICE_EPSTATUSCLR_STALLRQ_Pos 4

#define USB_DEVICE_EPSTATUSCLR_BK0RDY_Pos 6

#define USB_DEVICE_EPSTATUSCLR_BK1RDY_Pos 7

#define USB_DEVICE_EPSTATUSSET_OFFSET 261

#define USB_DEVICE_EPSTATUSSET_DTGLOUT_Pos 0

#define USB_DEVICE_EPSTATUSSET_DTGLIN_Pos 1

#define USB_DEVICE_EPSTATUSSET_CURBK_Pos 2

#define USB_DEVICE_EPSTATUSSET_STALLRQ0_Pos 4

#define USB_DEVICE_EPSTATUSSET_STALLRQ1_Pos 5

#define USB_DEVICE_EPSTATUSSET_STALLRQ_Pos 4

#define USB_DEVICE_EPSTATUSSET_BK0RDY_Pos 6

#define USB_DEVICE_EPSTATUSSET_BK1RDY_Pos 7

#define USB_DEVICE_EPSTATUS_OFFSET 262

#define USB_DEVICE_EPSTATUS_DTGLOUT_Pos 0

#define USB_DEVICE_EPSTATUS_DTGLIN_Pos 1

#define USB_DEVICE_EPSTATUS_CURBK_Pos 2

#define USB_DEVICE_EPSTATUS_STALLRQ0_Pos 4

#define USB_DEVICE_EPSTATUS_STALLRQ1_Pos 5

#define USB_DEVICE_EPSTATUS_STALLRQ_Pos 4

#define USB_DEVICE_EPSTATUS_BK0RDY_Pos 6

#define USB_DEVICE_EPSTATUS_BK1RDY_Pos 7

#define USB_DEVICE_EPINTFLAG_OFFSET 263

#define USB_DEVICE_EPINTFLAG_TRCPT0_Pos 0

#define USB_DEVICE_EPINTFLAG_TRCPT1_Pos 1

#define USB_DEVICE_EPINTFLAG_TRCPT_Pos 0

#define USB_DEVICE_EPINTFLAG_TRFAIL0_Pos 2

#define USB_DEVICE_EPINTFLAG_TRFAIL1_Pos 3

#define USB_DEVICE_EPINTFLAG_TRFAIL_Pos 2

#define USB_DEVICE_EPINTFLAG_RXSTP_Pos 4

#define USB_DEVICE_EPINTFLAG_STALL0_Pos 5

#define USB_DEVICE_EPINTFLAG_STALL1_Pos 6

#define USB_DEVICE_EPINTFLAG_STALL_Pos 5

#define USB_DEVICE_EPINTENCLR_OFFSET 264

#define USB_DEVICE_EPINTENCLR_TRCPT0_Pos 0

#define USB_DEVICE_EPINTENCLR_TRCPT1_Pos 1

#define USB_DEVICE_EPINTENCLR_TRCPT_Pos 0

#define USB_DEVICE_EPINTENCLR_TRFAIL0_Pos 2

#define USB_DEVICE_EPINTENCLR_TRFAIL1_Pos 3

#define USB_DEVICE_EPINTENCLR_TRFAIL_Pos 2

#define USB_DEVICE_EPINTENCLR_RXSTP_Pos 4

#define USB_DEVICE_EPINTENCLR_STALL0_Pos 5

#define USB_DEVICE_EPINTENCLR_STALL1_Pos 6

#define USB_DEVICE_EPINTENCLR_STALL_Pos 5

#define USB_DEVICE_EPINTENSET_OFFSET 265

#define USB_DEVICE_EPINTENSET_TRCPT0_Pos 0

#define USB_DEVICE_EPINTENSET_TRCPT1_Pos 1

#define USB_DEVICE_EPINTENSET_TRCPT_Pos 0

#define USB_DEVICE_EPINTENSET_TRFAIL0_Pos 2

#define USB_DEVICE_EPINTENSET_TRFAIL1_Pos 3

#define USB_DEVICE_EPINTENSET_TRFAIL_Pos 2

#define USB_DEVICE_EPINTENSET_RXSTP_Pos 4

#define USB_DEVICE_EPINTENSET_STALL0_Pos 5

#define USB_DEVICE_EPINTENSET_STALL1_Pos 6

#define USB_DEVICE_EPINTENSET_STALL_Pos 5

#define USB_DEVICE_ADDR_OFFSET 0

#define USB_DEVICE_ADDR_ADDR_Pos 0

#define USB_DEVICE_PCKSIZE_OFFSET 4

#define USB_DEVICE_PCKSIZE_BYTE_COUNT_Pos 0

#define USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE_Pos 14

#define USB_DEVICE_PCKSIZE_SIZE_Pos 28

#define USB_DEVICE_PCKSIZE_AUTO_ZLP_Pos 31

#define USB_DEVICE_EXTREG_OFFSET 8

#define USB_DEVICE_EXTREG_SUBPID_Pos 0

#define USB_DEVICE_EXTREG_VARIABLE_Pos 4

#define USB_DEVICE_STATUS_BK_OFFSET 10

#define USB_DEVICE_STATUS_BK_CRCERR_Pos 0

#define USB_DEVICE_STATUS_BK_ERRORFLOW_Pos 1

#define REV_WDT 257

#define WDT_CTRLA_OFFSET 0

#define WDT_CTRLA_ENABLE_Pos 1

#define WDT_CTRLA_WEN_Pos 2

#define WDT_CTRLA_ALWAYSON_Pos 7

#define WDT_CONFIG_OFFSET 1

#define WDT_CONFIG_PER_Pos 0

#define WDT_CONFIG_WINDOW_Pos 4

#define WDT_EWCTRL_OFFSET 2

#define WDT_EWCTRL_EWOFFSET_Pos 0

#define WDT_INTENCLR_OFFSET 4

#define WDT_INTENCLR_EW_Pos 0

#define WDT_INTENSET_OFFSET 5

#define WDT_INTENSET_EW_Pos 0

#define WDT_INTFLAG_OFFSET 6

#define WDT_INTFLAG_EW_Pos 0

#define WDT_SYNCBUSY_OFFSET 8

#define WDT_SYNCBUSY_ENABLE_Pos 1

#define WDT_SYNCBUSY_WEN_Pos 2

#define WDT_SYNCBUSY_ALWAYSON_Pos 3

#define WDT_SYNCBUSY_CLEAR_Pos 4

#define WDT_CLEAR_OFFSET 12

#define WDT_CLEAR_CLEAR_Pos 0

#define AC_COMPCTRL_MUXNEG_OPAMP 7

#define AC_GCLK_ID 26

#define AC_NUM_CMP 2

#define AC_PAIRS 1

#define ADC_DMAC_ID_RESRDY 31

#define ADC_EXTCHANNEL_MSB 19

#define ADC_GCLK_ID 25

#define ADC_INT_CH30 2

#define ADC_MASTER_SLAVE_MODE 0

#define AES_DMAC_ID_RD 36

#define AES_DMAC_ID_WR 35

#define CCL_GCLK_ID 28

#define CCL_IO_NUM 12

#define CCL_LUT_NUM 4

#define CCL_SEQ_NUM 2

#define DMAC_CH_BITS 4

#define DMAC_CH_NUM 16

#define DMAC_CLK_AHB_ID 3

#define DMAC_EVIN_NUM 4

#define DMAC_EVOUT_NUM 4

#define DMAC_LVL_BITS 2

#define DMAC_LVL_NUM 4

#define DMAC_QOSCTRL_D_RESETVALUE 2

#define DMAC_QOSCTRL_F_RESETVALUE 2

#define DMAC_QOSCTRL_WRB_RESETVALUE 2

#define DMAC_TRIG_BITS 6

#define DMAC_TRIG_NUM 40

#define DSU_CLK_AHB_ID 5

#define EIC_EXTINT_NUM 16

#define EIC_GCLK_ID 3

#define EIC_NUMBER_OF_CONFIG_REGS 2

#define EIC_NUMBER_OF_INTERRUPTS 16

#define EVSYS_CHANNELS 8

#define EVSYS_CHANNELS_BITS 3

#define EVSYS_CHANNELS_MSB 7

#define EVSYS_EXTEVT_NUM 0

#define EVSYS_GCLK_ID_0 7

#define EVSYS_GCLK_ID_1 8

#define EVSYS_GCLK_ID_2 9

#define EVSYS_GCLK_ID_3 10

#define EVSYS_GCLK_ID_4 11

#define EVSYS_GCLK_ID_5 12

#define EVSYS_GCLK_ID_6 13

#define EVSYS_GCLK_ID_7 14

#define EVSYS_GCLK_ID_LSB 7

#define EVSYS_GCLK_ID_MSB 14

#define EVSYS_GCLK_ID_SIZE 8

#define EVSYS_GENERATORS 71

#define EVSYS_GENERATORS_BITS 7

#define EVSYS_USERS 31

#define EVSYS_USERS_BITS 5

#define EVSYS_ID_GEN_OSCCTRL_XOSC_FAIL 1

#define EVSYS_ID_GEN_OSC32KCTRL_XOSC32K_FAIL 2

#define EVSYS_ID_GEN_RTC_CMP_0 3

#define EVSYS_ID_GEN_RTC_CMP_1 4

#define EVSYS_ID_GEN_RTC_TAMPER 5

#define EVSYS_ID_GEN_RTC_OVF 6

#define EVSYS_ID_GEN_RTC_PER_0 7

#define EVSYS_ID_GEN_RTC_PER_1 8

#define EVSYS_ID_GEN_RTC_PER_2 9

#define EVSYS_ID_GEN_RTC_PER_3 10

#define EVSYS_ID_GEN_RTC_PER_4 11

#define EVSYS_ID_GEN_RTC_PER_5 12

#define EVSYS_ID_GEN_RTC_PER_6 13

#define EVSYS_ID_GEN_RTC_PER_7 14

#define EVSYS_ID_GEN_EIC_EXTINT_0 15

#define EVSYS_ID_GEN_EIC_EXTINT_1 16

#define EVSYS_ID_GEN_EIC_EXTINT_2 17

#define EVSYS_ID_GEN_EIC_EXTINT_3 18

#define EVSYS_ID_GEN_EIC_EXTINT_4 19

#define EVSYS_ID_GEN_EIC_EXTINT_5 20

#define EVSYS_ID_GEN_EIC_EXTINT_6 21

#define EVSYS_ID_GEN_EIC_EXTINT_7 22

#define EVSYS_ID_GEN_EIC_EXTINT_8 23

#define EVSYS_ID_GEN_EIC_EXTINT_9 24

#define EVSYS_ID_GEN_EIC_EXTINT_10 25

#define EVSYS_ID_GEN_EIC_EXTINT_11 26

#define EVSYS_ID_GEN_EIC_EXTINT_12 27

#define EVSYS_ID_GEN_EIC_EXTINT_13 28

#define EVSYS_ID_GEN_EIC_EXTINT_14 29

#define EVSYS_ID_GEN_EIC_EXTINT_15 30

#define EVSYS_ID_GEN_DMAC_CH_0 31

#define EVSYS_ID_GEN_DMAC_CH_1 32

#define EVSYS_ID_GEN_DMAC_CH_2 33

#define EVSYS_ID_GEN_DMAC_CH_3 34

#define EVSYS_ID_GEN_TCC0_OVF 35

#define EVSYS_ID_GEN_TCC0_TRG 36

#define EVSYS_ID_GEN_TCC0_CNT 37

#define EVSYS_ID_GEN_TCC0_MCX_0 38

#define EVSYS_ID_GEN_TCC0_MCX_1 39

#define EVSYS_ID_GEN_TCC0_MCX_2 40

#define EVSYS_ID_GEN_TCC0_MCX_3 41

#define EVSYS_ID_GEN_TC0_OVF 42

#define EVSYS_ID_GEN_TC0_MCX_0 43

#define EVSYS_ID_GEN_TC0_MCX_1 44

#define EVSYS_ID_GEN_TC1_OVF 45

#define EVSYS_ID_GEN_TC1_MCX_0 46

#define EVSYS_ID_GEN_TC1_MCX_1 47

#define EVSYS_ID_GEN_TC2_OVF 48

#define EVSYS_ID_GEN_TC2_MCX_0 49

#define EVSYS_ID_GEN_TC2_MCX_1 50

#define EVSYS_ID_GEN_TC3_OVF 51

#define EVSYS_ID_GEN_TC3_MCX_0 52

#define EVSYS_ID_GEN_TC3_MCX_1 53

#define EVSYS_ID_GEN_ADC_RESRDY 54

#define EVSYS_ID_GEN_ADC_WINMON 55

#define EVSYS_ID_GEN_AC_COMP_0 56

#define EVSYS_ID_GEN_AC_COMP_1 57

#define EVSYS_ID_GEN_AC_WIN_0 58

#define EVSYS_ID_GEN_SLCD_FC0OVERFLOW 61

#define EVSYS_ID_GEN_SLCD_FC1OVERFLOW 62

#define EVSYS_ID_GEN_SLCD_FC2OVERFLOW 63

#define EVSYS_ID_GEN_SLCD_DT 64

#define EVSYS_ID_GEN_TRNG_READY 65

#define EVSYS_ID_GEN_CCL_LUTOUT_0 66

#define EVSYS_ID_GEN_CCL_LUTOUT_1 67

#define EVSYS_ID_GEN_CCL_LUTOUT_2 68

#define EVSYS_ID_GEN_CCL_LUTOUT_3 69

#define EVSYS_ID_GEN_PAC_ACCERR 70

#define EVSYS_ID_USER_RTC_TAMPER 0

#define EVSYS_ID_USER_PORT_EV_0 1

#define EVSYS_ID_USER_PORT_EV_1 2

#define EVSYS_ID_USER_PORT_EV_2 3

#define EVSYS_ID_USER_PORT_EV_3 4

#define EVSYS_ID_USER_DMAC_CH_0 5

#define EVSYS_ID_USER_DMAC_CH_1 6

#define EVSYS_ID_USER_DMAC_CH_2 7

#define EVSYS_ID_USER_DMAC_CH_3 8

#define EVSYS_ID_USER_TCC0_EV_0 9

#define EVSYS_ID_USER_TCC0_EV_1 10

#define EVSYS_ID_USER_TCC0_MC_0 11

#define EVSYS_ID_USER_TCC0_MC_1 12

#define EVSYS_ID_USER_TCC0_MC_2 13

#define EVSYS_ID_USER_TCC0_MC_3 14

#define EVSYS_ID_USER_TC0_EVU 15

#define EVSYS_ID_USER_TC1_EVU 16

#define EVSYS_ID_USER_TC2_EVU 17

#define EVSYS_ID_USER_TC3_EVU 18

#define EVSYS_ID_USER_ADC_START 19

#define EVSYS_ID_USER_ADC_SYNC 20

#define EVSYS_ID_USER_AC_SOC_0 21

#define EVSYS_ID_USER_AC_SOC_1 22

#define EVSYS_ID_USER_CCL_LUTIN_0 24

#define EVSYS_ID_USER_CCL_LUTIN_1 25

#define EVSYS_ID_USER_CCL_LUTIN_2 26

#define EVSYS_ID_USER_CCL_LUTIN_3 27

#define EVSYS_ID_USER_MTB_START 29

#define EVSYS_ID_USER_MTB_STOP 30

#define FREQM_GCLK_ID_MSR 4

#define FREQM_GCLK_ID_REF 5

#define GCLK_GENDIV_BITS 16

#define GCLK_GEN_BITS 3

#define GCLK_GEN_NUM 5

#define GCLK_GEN_NUM_MSB 4

#define GCLK_GEN_SOURCE_NUM_MSB 7

#define GCLK_NUM 30

#define GCLK_SOURCE_BITS 3

#define GCLK_SOURCE_DFLL48M 6

#define GCLK_SOURCE_DPLL96M 7

#define GCLK_SOURCE_GCLKGEN1 2

#define GCLK_SOURCE_GCLKIN 1

#define GCLK_SOURCE_NUM 8

#define GCLK_SOURCE_OSCULP32K 3

#define GCLK_SOURCE_OSC16M 5

#define GCLK_SOURCE_XOSC 0

#define GCLK_SOURCE_XOSC32K 4

#define MCLK_BUPDIV_IMPLEMENTED 1

#define MCLK_CTRLA_MCSEL_GCLK 1

#define MCLK_CTRLA_MCSEL_OSC8M 0

#define MCLK_MCLK_CLK_APB_NUM 3

#define MCLK_SYSTEM_CLOCK 1000000

#define NVMCTRL_AUX0_ADDRESS 8404992

#define NVMCTRL_AUX1_ADDRESS 8413184

#define NVMCTRL_AUX2_ADDRESS 8421376

#define NVMCTRL_AUX3_ADDRESS 8429568

#define NVMCTRL_CLK_AHB_ID 8

#define NVMCTRL_CLK_AHB_ID_PICACHU 10

#define NVMCTRL_FACTORY_WORD_IMPLEMENTED_MASK -4611685984067649537

#define NVMCTRL_FLASH_SIZE 262144

#define NVMCTRL_GCLK_ID 29

#define NVMCTRL_LOCKBIT_ADDRESS 8396800

#define NVMCTRL_PAGE_HW 32

#define NVMCTRL_PAGE_SIZE 64

#define NVMCTRL_PAGE_W 16

#define NVMCTRL_PMSB 3

#define NVMCTRL_PSZ_BITS 6

#define NVMCTRL_ROW_PAGES 4

#define NVMCTRL_ROW_SIZE 256

#define NVMCTRL_USER_PAGE_ADDRESS 8388608

#define NVMCTRL_USER_PAGE_OFFSET 8388608

#define NVMCTRL_USER_WORD_IMPLEMENTED_MASK -4602678819172646913

#define NVMCTRL_RWWEE_PAGES 128

#define NVMCTRL_RWW_EEPROM_ADDR 4194304

#define OSCCTRL_DFLL48M_COARSE_MSB 5

#define OSCCTRL_DFLL48M_FINE_MSB 9

#define OSCCTRL_GCLK_ID_DFLL48 0

#define OSCCTRL_GCLK_ID_FDPLL 1

#define OSCCTRL_GCLK_ID_FDPLL32K 2

#define OSCCTRL_CFD_VERSION 256

#define OSCCTRL_DFLL48M_VERSION 800

#define OSCCTRL_FDPLL_VERSION 529

#define OSCCTRL_OSC16M_VERSION 257

#define OSCCTRL_XOSC_VERSION 513

#define OSC32KCTRL_OSC32K_COARSE_CALIB_MSB 6

#define PAC_CLK_AHB_ID 7

#define PAC_HPB_NUM 3

#define PAC_INTFLAG_NUM 4

#define PM_BIAS_RAM_HS 1

#define PM_PD_NUM 0

#define PORT_BITS 93

#define PORT_DRVSTR 1

#define PORT_EV_NUM 4

#define PORT_ODRAIN 0

#define PORT_SLEWLIM 0

#define PTC_DMAC_ID_EOC 37

#define PTC_DMAC_ID_SEQ 38

#define PTC_DMAC_ID_WCOMP 39

#define PTC_GCLK_ID 27

#define PTC_LINES_MSB 31

#define PTC_LINES_NUM 32

#define PTC_Y_LINES_MSB 23

#define PTC_Y_LINES_NUM 24

#define RSTC_BACKUP_IMPLEMENTED 1

#define RSTC_NUMBER_OF_EXTWAKE 0

#define RTC_ALARM_NUM 1

#define RTC_BKUP_NUM 8

#define RTC_COMP16_NUM 2

#define RTC_COMP32_NUM 1

#define RTC_DMAC_ID_TIMESTAMP 1

#define RTC_GPR_NUM 2

#define RTC_PER_NUM 8

#define RTC_TAMPER_NUM 5

#define SERCOM0_DMAC_ID_RX 2

#define SERCOM0_DMAC_ID_TX 3

#define SERCOM0_GCLK_ID_CORE 16

#define SERCOM0_GCLK_ID_SLOW 15

#define SERCOM0_INT_MSB 6

#define SERCOM0_PMSB 3

#define SERCOM0_SPI 1

#define SERCOM0_TWIM 0

#define SERCOM0_TWIS 0

#define SERCOM0_TWI_HSMODE 0

#define SERCOM0_USART 1

#define SERCOM0_USART_ISO7816 1

#define SERCOM0_USART_LIN_MASTER 0

#define SERCOM0_USART_RS485 1

#define SERCOM1_DMAC_ID_RX 4

#define SERCOM1_DMAC_ID_TX 5

#define SERCOM1_GCLK_ID_CORE 17

#define SERCOM1_GCLK_ID_SLOW 15

#define SERCOM1_INT_MSB 6

#define SERCOM1_PMSB 3

#define SERCOM1_SPI 1

#define SERCOM1_TWIM 1

#define SERCOM1_TWIS 1

#define SERCOM1_TWI_HSMODE 1

#define SERCOM1_USART 1

#define SERCOM1_USART_ISO7816 1

#define SERCOM1_USART_LIN_MASTER 0

#define SERCOM1_USART_RS485 1

#define SERCOM2_DMAC_ID_RX 6

#define SERCOM2_DMAC_ID_TX 7

#define SERCOM2_GCLK_ID_CORE 18

#define SERCOM2_GCLK_ID_SLOW 15

#define SERCOM2_INT_MSB 6

#define SERCOM2_PMSB 3

#define SERCOM2_SPI 1

#define SERCOM2_TWIM 1

#define SERCOM2_TWIS 1

#define SERCOM2_TWI_HSMODE 0

#define SERCOM2_USART 1

#define SERCOM2_USART_ISO7816 1

#define SERCOM2_USART_LIN_MASTER 0

#define SERCOM2_USART_RS485 1

#define SERCOM3_DMAC_ID_RX 8

#define SERCOM3_DMAC_ID_TX 9

#define SERCOM3_GCLK_ID_CORE 19

#define SERCOM3_GCLK_ID_SLOW 15

#define SERCOM3_INT_MSB 6

#define SERCOM3_PMSB 3

#define SERCOM3_SPI 1

#define SERCOM3_TWIM 1

#define SERCOM3_TWIS 1

#define SERCOM3_TWI_HSMODE 0

#define SERCOM3_USART 1

#define SERCOM3_USART_ISO7816 1

#define SERCOM3_USART_LIN_MASTER 0

#define SERCOM3_USART_RS485 1

#define SLCD_DMAC_ID_ABMDRDY 34

#define SLCD_DMAC_ID_ACMDRDY 33

#define SLCD_DMAC_ID_DMU 32

#define SLCD_MAX_COM 8

#define SLCD_MAX_SEG 44

#define SLCD_NB_LP 52

#define SUPC_BOD12_CALIB_MSB 5

#define SUPC_BOD33_CALIB_MSB 5

#define SUPC_OUT_NUM_MSB 1

#define TC0_CC_NUM 2

#define TC0_DMAC_ID_MC_0 20

#define TC0_DMAC_ID_MC_1 21

#define TC0_DMAC_ID_MC_LSB 20

#define TC0_DMAC_ID_MC_MSB 21

#define TC0_DMAC_ID_MC_SIZE 2

#define TC0_DMAC_ID_OVF 19

#define TC0_EXT 0

#define TC0_GCLK_ID 23

#define TC0_MASTER 1

#define TC0_OW_NUM 2

#define TC1_CC_NUM 2

#define TC1_DMAC_ID_MC_0 23

#define TC1_DMAC_ID_MC_1 24

#define TC1_DMAC_ID_MC_LSB 23

#define TC1_DMAC_ID_MC_MSB 24

#define TC1_DMAC_ID_MC_SIZE 2

#define TC1_DMAC_ID_OVF 22

#define TC1_EXT 0

#define TC1_GCLK_ID 23

#define TC1_MASTER 0

#define TC1_OW_NUM 2

#define TC2_CC_NUM 2

#define TC2_DMAC_ID_MC_0 26

#define TC2_DMAC_ID_MC_1 27

#define TC2_DMAC_ID_MC_LSB 26

#define TC2_DMAC_ID_MC_MSB 27

#define TC2_DMAC_ID_MC_SIZE 2

#define TC2_DMAC_ID_OVF 25

#define TC2_EXT 0

#define TC2_GCLK_ID 24

#define TC2_MASTER 1

#define TC2_OW_NUM 2

#define TC3_CC_NUM 2

#define TC3_DMAC_ID_MC_0 29

#define TC3_DMAC_ID_MC_1 30

#define TC3_DMAC_ID_MC_LSB 29

#define TC3_DMAC_ID_MC_MSB 30

#define TC3_DMAC_ID_MC_SIZE 2

#define TC3_DMAC_ID_OVF 28

#define TC3_EXT 0

#define TC3_GCLK_ID 24

#define TC3_MASTER 0

#define TC3_OW_NUM 2

#define TCC0_CC_NUM 4

#define TCC0_DITHERING 1

#define TCC0_DMAC_ID_MC_0 15

#define TCC0_DMAC_ID_MC_1 16

#define TCC0_DMAC_ID_MC_2 17

#define TCC0_DMAC_ID_MC_3 18

#define TCC0_DMAC_ID_MC_LSB 15

#define TCC0_DMAC_ID_MC_MSB 18

#define TCC0_DMAC_ID_MC_SIZE 4

#define TCC0_DMAC_ID_OVF 14

#define TCC0_DTI 1

#define TCC0_EXT 31

#define TCC0_GCLK_ID 22

#define TCC0_OTMX 1

#define TCC0_OW_NUM 8

#define TCC0_PG 1

#define TCC0_SIZE 24

#define TCC0_SWAP 1

#define TCC0_TYPE 0

#define USB_EPT_NBR 8

#define USB_EPT_NUM 8

#define USB_GCLK_ID 6

#define USB_PIPE_NUM 0

#define ID_PAC 0

#define ID_PM 1

#define ID_MCLK 2

#define ID_RSTC 3

#define ID_OSCCTRL 4

#define ID_OSC32KCTRL 5

#define ID_SUPC 6

#define ID_GCLK 7

#define ID_WDT 8

#define ID_RTC 9

#define ID_EIC 10

#define ID_FREQM 11

#define ID_USB 32

#define ID_DSU 33

#define ID_NVMCTRL 34

#define ID_PORT 35

#define ID_DMAC 36

#define ID_MTB 37

#define ID_EVSYS 64

#define ID_SERCOM0 65

#define ID_SERCOM1 66

#define ID_SERCOM2 67

#define ID_SERCOM3 68

#define ID_TCC0 71

#define ID_TC0 72

#define ID_TC1 73

#define ID_TC2 74

#define ID_TC3 75

#define ID_ADC 76

#define ID_AC 77

#define ID_PTC 78

#define ID_SLCD 79

#define ID_AES 80

#define ID_TRNG 81

#define ID_CCL 82

#define ID_PERIPH_COUNT 83

#define AC_INST_NUM 1

#define ADC_INST_NUM 1

#define AES_INST_NUM 1

#define CCL_INST_NUM 1

#define DMAC_INST_NUM 1

#define DSU_INST_NUM 1

#define EIC_INST_NUM 1

#define EVSYS_INST_NUM 1

#define FREQM_INST_NUM 1

#define GCLK_INST_NUM 1

#define MCLK_INST_NUM 1

#define MTB_INST_NUM 1

#define NVMCTRL_CAL 8388608

#define NVMCTRL_LOCKBIT 8396800

#define NVMCTRL_OTP1 8413184

#define NVMCTRL_OTP2 8413192

#define NVMCTRL_OTP3 8413200

#define NVMCTRL_OTP4 8413208

#define NVMCTRL_OTP5 8413216

#define NVMCTRL_TEMP_LOG 8413232

#define NVMCTRL_USER 8404992

#define NVMCTRL_INST_NUM 1

#define OSCCTRL_INST_NUM 1

#define OSC32KCTRL_INST_NUM 1

#define PAC_INST_NUM 1

#define PM_INST_NUM 1

#define PORT_INST_NUM 1

#define PORT_IOBUS_INST_NUM 1

#define PTC_INST_NUM 1

#define RSTC_INST_NUM 1

#define RTC_INST_NUM 1

#define SERCOM_INST_NUM 4

#define SLCD_INST_NUM 1

#define SUPC_INST_NUM 1

#define TC_INST_NUM 4

#define TCC_INST_NUM 1

#define TRNG_INST_NUM 1

#define USB_INST_NUM 1

#define WDT_INST_NUM 1

#define PIN_PA00 0

#define PIN_PA01 1

#define PIN_PA02 2

#define PIN_PA03 3

#define PIN_PA04 4

#define PIN_PA05 5

#define PIN_PA06 6

#define PIN_PA07 7

#define PIN_PA08 8

#define PIN_PA09 9

#define PIN_PA10 10

#define PIN_PA11 11

#define PIN_PA12 12

#define PIN_PA13 13

#define PIN_PA14 14

#define PIN_PA15 15

#define PIN_PA16 16

#define PIN_PA17 17

#define PIN_PA18 18

#define PIN_PA19 19

#define PIN_PA20 20

#define PIN_PA21 21

#define PIN_PA22 22

#define PIN_PA23 23

#define PIN_PA24 24

#define PIN_PA25 25

#define PIN_PA27 27

#define PIN_PA30 30

#define PIN_PA31 31

#define PIN_PB00 32

#define PIN_PB01 33

#define PIN_PB02 34

#define PIN_PB03 35

#define PIN_PB04 36

#define PIN_PB05 37

#define PIN_PB06 38

#define PIN_PB07 39

#define PIN_PB08 40

#define PIN_PB09 41

#define PIN_PB11 43

#define PIN_PB12 44

#define PIN_PB13 45

#define PIN_PB14 46

#define PIN_PB15 47

#define PIN_PB16 48

#define PIN_PB17 49

#define PIN_PB22 54

#define PIN_PB23 55

#define PIN_PB30 62

#define PIN_PB31 63

#define FLASH_PAGE_SIZE 64

#define FLASH_NB_OF_PAGES 4096

#define FLASH_USER_PAGE_SIZE 64

#define PORT_GROUPS 2

#define ERR_NONE 0

#define ERR_INVALID_DATA -1

#define ERR_NO_CHANGE -2

#define ERR_ABORTED -3

#define ERR_BUSY -4

#define ERR_SUSPEND -5

#define ERR_IO -6

#define ERR_REQ_FLUSHED -7

#define ERR_TIMEOUT -8

#define ERR_BAD_DATA -9

#define ERR_NOT_FOUND -10

#define ERR_UNSUPPORTED_DEV -11

#define ERR_NO_MEMORY -12

#define ERR_INVALID_ARG -13

#define ERR_BAD_ADDRESS -14

#define ERR_BAD_FORMAT -15

#define ERR_BAD_FRQ -16

#define ERR_DENIED -17

#define ERR_ALREADY_INITIALIZED -18

#define ERR_OVERFLOW -19

#define ERR_NOT_INITIALIZED -20

#define ERR_SAMPLERATE_UNAVAILABLE -21

#define ERR_RESOLUTION_UNAVAILABLE -22

#define ERR_BAUDRATE_UNAVAILABLE -23

#define ERR_PACKET_COLLISION -24

#define ERR_PROTOCOL -25

#define ERR_PIN_MUX_INVALID -26

#define ERR_UNSUPPORTED_OP -27

#define ERR_NO_RESOURCE -28

#define ERR_NOT_READY -29

#define ERR_FAILURE -30

#define ERR_WRONG_LENGTH -31

#define GPIO_PIN_FUNCTION_OFF 4294967295

#define CONF_PORT_EVCTRL_PORT_0 0

#define CONF_PORTA_EVCTRL_PORTEI_0 0

#define CONF_PORTA_EVCTRL_PID_0 0

#define CONF_PORTA_EVCTRL_EVACT_0 0

#define CONF_PORTB_EVCTRL_PORTEI_0 0

#define CONF_PORTB_EVCTRL_PID_0 0

#define CONF_PORTB_EVCTRL_EVACT_0 0

#define CONF_PORT_EVCTRL_PORT_1 0

#define CONF_PORTA_EVCTRL_PORTEI_1 0

#define CONF_PORTA_EVCTRL_PID_1 0

#define CONF_PORTA_EVCTRL_EVACT_1 0

#define CONF_PORTB_EVCTRL_PORTEI_1 0

#define CONF_PORTB_EVCTRL_PID_1 0

#define CONF_PORTB_EVCTRL_EVACT_1 0

#define CONF_PORT_EVCTRL_PORT_2 0

#define CONF_PORTA_EVCTRL_PORTEI_2 0

#define CONF_PORTA_EVCTRL_PID_2 0

#define CONF_PORTA_EVCTRL_EVACT_2 0

#define CONF_PORTB_EVCTRL_PORTEI_2 0

#define CONF_PORTB_EVCTRL_PID_2 0

#define CONF_PORTB_EVCTRL_EVACT_2 0

#define CONF_PORT_EVCTRL_PORT_3 0

#define CONF_PORTA_EVCTRL_PORTEI_3 0

#define CONF_PORTA_EVCTRL_PID_3 0

#define CONF_PORTA_EVCTRL_EVACT_3 0

#define CONF_PORTB_EVCTRL_PORTEI_3 0

#define CONF_PORTB_EVCTRL_PID_3 0

#define CONF_PORTB_EVCTRL_EVACT_3 0

#define I2C_M_RD 1

#define I2C_M_BUSY 256

#define I2C_M_TEN 1024

#define I2C_M_SEVEN 2048

#define I2C_M_FAIL 4096

#define I2C_M_STOP 32768

#define I2C_OK 0

#define I2C_ACK -1

#define I2C_NACK -2

#define I2C_ERR_ARBLOST -3

#define I2C_ERR_BAD_ADDRESS -4

#define I2C_ERR_BUS -5

#define I2C_ERR_BUSY -6

#define I2c_ERR_PACKAGE_COLLISION -7

#define I2C_STANDARD_MODE 0

#define I2C_FASTMODE 1

#define I2C_HIGHSPEED_MODE 2

#define I2C_M_MAX_RETRY 1

#define SPI_DUMMY_CHAR 511

#define WATCH_RTC_REFERENCE_YEAR 2020

typedef struct movement_settings_t__bindgen_ty_1 movement_settings_t__bindgen_ty_1;

typedef struct usart_flow_control_state__bindgen_ty_1 usart_flow_control_state__bindgen_ty_1;

typedef struct watch_date_time__bindgen_ty_1 watch_date_time__bindgen_ty_1;

typedef struct movement_event_t {
  uint8_t event_type;
  uint8_t subsecond;
} movement_event_t;

typedef struct _IO_marker {
  uint8_t _unused[0];
} _IO_marker;

typedef long __off_t;

typedef void _IO_lock_t;

typedef long __off64_t;

typedef struct _IO_codecvt {
  uint8_t _unused[0];
} _IO_codecvt;

typedef struct _IO_wide_data {
  uint8_t _unused[0];
} _IO_wide_data;

typedef struct _IO_FILE {
  int _flags;
  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;
  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;
  int _flags2;
  __off_t _old_offset;
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  __off64_t _offset;
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  uintptr_t __pad5;
  int _mode;
  char _unused2[20];
} _IO_FILE;

typedef struct _IO_FILE FILE;

typedef struct __va_list_tag {
  unsigned int gp_offset;
  unsigned int fp_offset;
  void *overflow_arg_area;
  void *reg_save_area;
} __va_list_tag;

typedef long __ssize_t;

typedef union __mbstate_t__bindgen_ty_1 {
  unsigned int __wch;
  char __wchb[4];
} __mbstate_t__bindgen_ty_1;

typedef struct __mbstate_t {
  int __count;
  union __mbstate_t__bindgen_ty_1 __value;
} __mbstate_t;

typedef struct _G_fpos_t {
  __off_t __pos;
  struct __mbstate_t __state;
} _G_fpos_t;

typedef struct _G_fpos_t __fpos_t;

typedef __fpos_t fpos_t;

/**
 * \brief Type for the register holding global interrupt enable flag
 */
typedef uint32_t hal_atomic_t;

/**
 * \brief IRQ descriptor
 */
typedef struct _irq_descriptor {
  void (*handler)(void *parameter);
  void *parameter;
} _irq_descriptor;

/**
 * \brief Reset reason enumeration
 *
 * The list of possible reset reasons.
 */
typedef unsigned int reset_reason;

/**
 * \brief I/O write function pointer type
 */
typedef int32_t (*io_write_t)(struct io_descriptor *io_descr, const uint8_t *buf, uint16_t length);

/**
 * \brief I/O read function pointer type
 */
typedef int32_t (*io_read_t)(struct io_descriptor *io_descr, uint8_t *buf, uint16_t length);

/**
 * \brief I/O descriptor
 *
 * The I/O descriptor forward declaration.
 */
typedef struct io_descriptor {
  io_write_t write;
  /**
   * The write function pointer.
   */
  io_read_t read;
} io_descriptor;

/**
 * \brief External IRQ callback type
 */
typedef void (*ext_irq_cb_t)(void);

/**
 * \brief i2c master message structure
 */
typedef struct _i2c_m_msg {
  uint16_t addr;
  uint16_t flags;
  int32_t len;
  uint8_t *buffer;
} _i2c_m_msg;

/**
 * \brief i2c master service
 */
typedef struct _i2c_m_service {
  struct _i2c_m_msg msg;
  uint16_t mode;
  uint16_t trise;
} _i2c_m_service;

/**
 * \brief i2c sync master device structure
 */
typedef struct _i2c_m_sync_device {
  struct _i2c_m_service service;
  void *hw;
} _i2c_m_sync_device;

/**
 * \brief I2C descriptor structure, embed i2c_device & i2c_interface
 */
typedef struct i2c_m_sync_desc {
  struct _i2c_m_sync_device device;
  struct io_descriptor io;
  uint16_t periph_addr;
} i2c_m_sync_desc;

/**
 * SPI generic driver.
 */
typedef struct spi_dev {
  /**
   * Pointer to the hardware base or private data for special device.
   */
  void *prvt;
  /**
   * Reference start of sync/async variables
   */
  uint32_t sync_async_misc[1];
} spi_dev;

/**
 * SPI driver to support sync HAL
 */
typedef struct _spi_sync_dev {
  /**
   * Pointer to the hardware base or private data for special device.
   */
  void *prvt;
  /**
   * Data size, number of bytes for each character
   */
  uint8_t char_size;
  /**
   * Dummy byte used in master mode when reading the slave
   */
  uint16_t dummy_byte;
} _spi_sync_dev;

/**
 *  \brief SPI transfer modes   SPI transfer mode controls clock polarity and clock phase.   Mode 0: leading edge is rising edge, data sample on leading edge.   Mode 1: leading edge is rising edge, data sample on trailing edge.   Mode 2: leading edge is falling edge, data sample on leading edge.   Mode 3: leading edge is falling edge, data sample on trailing edge.
 */
typedef unsigned int spi_transfer_mode;

/**
 *  \brief SPI character sizes   The character size influence the way the data is sent/received.   For char size <= 8 data is stored byte by byte.   For char size between 9 ~ 16 data is stored in 2-byte length.   Note that the default and recommended char size is 8 bit since it's   supported by all system.
 */
typedef unsigned int spi_char_size;

/**
 *  \brief SPI data order
 */
typedef unsigned int spi_data_order;

typedef struct spi_msg {
  /**
   * Pointer to the output data buffer
   */
  uint8_t *txbuf;
  /**
   * Pointer to the input data buffer
   */
  uint8_t *rxbuf;
  /**
   * Size of the message data in SPI characters
   */
  uint32_t size;
} spi_msg;

typedef struct _spi_m_sync_hpl_interface {
  uint8_t _address;
} _spi_m_sync_hpl_interface;

/**
 * \brief SPI HAL driver struct for polling mode
 */
typedef struct spi_m_sync_descriptor {
  struct _spi_m_sync_hpl_interface *func;
  /**
   * SPI device instance
   */
  struct _spi_sync_dev dev;
  /**
   * I/O read/write
   */
  struct io_descriptor io;
  /**
   * Flags for HAL driver
   */
  uint16_t flags;
} spi_m_sync_descriptor;

/**
 * \brief Transfer descriptor for SPI   Transfer descriptor holds TX and RX buffers
 */
typedef struct spi_xfer {
  /**
   * Pointer to data buffer to TX
   */
  uint8_t *txbuf;
  /**
   * Pointer to data buffer to RX
   */
  uint8_t *rxbuf;
  /**
   * Size of data characters to TX & RX
   */
  uint32_t size;
} spi_xfer;

/**
 * \brief USART descriptor device structure
 */
typedef struct _usart_sync_device {
  void *hw;
} _usart_sync_device;

/**
 * \brief USART baud rate mode
 */
typedef unsigned int usart_baud_rate_mode;

/**
 * \brief USART data order
 */
typedef unsigned int usart_data_order;

/**
 * \brief USART mode
 */
typedef unsigned int usart_mode;

/**
 * \brief USART parity
 */
typedef unsigned int usart_parity;

/**
 * \brief USART stop bits mode
 */
typedef unsigned int usart_stop_bits;

/**
 * \brief USART character size
 */
typedef unsigned int usart_character_size;

/**
 * \brief USART flow control state
 */
typedef union usart_flow_control_state {
  struct usart_flow_control_state__bindgen_ty_1 bit;
  uint8_t value;
} usart_flow_control_state;

/**
 * \brief Synchronous USART descriptor
 */
typedef struct usart_sync_descriptor {
  struct io_descriptor io;
  struct _usart_sync_device device;
} usart_sync_descriptor;

/**
 * \brief SLCD sync device structure
 *
 * The SLCD device structure forward declaration.
 */
typedef struct _slcd_sync_device {
  /**
   *< Hardware module instance handler
   */
  void *hw;
} _slcd_sync_device;

/**
 * \addtogroup doc_driver_hal_slcd_sync
 *
 *@{
 */
typedef struct slcd_sync_descriptor {
  /**
   *< SLCD HPL device descriptor
   */
  struct _slcd_sync_device dev;
} slcd_sync_descriptor;

typedef union watch_date_time {
  struct watch_date_time__bindgen_ty_1 unit;
  uint32_t reg;
} watch_date_time;

typedef unsigned int watch_rtc_alarm_match;

/**
 * An enum listing the icons and indicators available on the watch.
 */
typedef unsigned int WatchIndicatorSegment;

/**
 *@brief An enum defining the types of interrupt trigger you wish to scan for.
 */
typedef unsigned int watch_interrupt_trigger;

/**
 * @brief 87 notes for use with watch_buzzer_play_note
 */
typedef unsigned int BuzzerNote;

typedef unsigned int watch_adc_reference_voltage;

typedef union movement_settings_t {
  struct movement_settings_t__bindgen_ty_1 bit;
  uint32_t reg;
} movement_settings_t;

/**
 * Interrupt Number Definition
 */
typedef int IRQn;

/**
 * \brief PORT pull mode settings
 */
typedef unsigned int gpio_pull_mode;

/**
 * \brief PORT direction settins
 */
typedef unsigned int gpio_direction;

/**
 * \brief PORT group abstraction
 */
typedef unsigned int gpio_port;

typedef unsigned int movement_event_type_t;

/**
 *<  2 Non Maskable Interrupt
 */
#define IRQn_NonMaskableInt_IRQn -14

/**
 *<  3 Hard Fault Interrupt
 */
#define IRQn_HardFault_IRQn -13

/**
 *< 11 SV Call Interrupt
 */
#define IRQn_SVCall_IRQn -5

/**
 *< 14 Pend SV Interrupt
 */
#define IRQn_PendSV_IRQn -2

/**
 *< 15 System Tick Interrupt
 */
#define IRQn_SysTick_IRQn -1

/**
 *<  0 SAML22J18A System Interrupts
 */
#define IRQn_SYSTEM_IRQn 0

/**
 *<  1 SAML22J18A Watchdog Timer (WDT)
 */
#define IRQn_WDT_IRQn 1

/**
 *<  2 SAML22J18A Real-Time Counter (RTC)
 */
#define IRQn_RTC_IRQn 2

/**
 *<  3 SAML22J18A External Interrupt Controller (EIC)
 */
#define IRQn_EIC_IRQn 3

/**
 *<  4 SAML22J18A Frequency Meter (FREQM)
 */
#define IRQn_FREQM_IRQn 4

/**
 *<  5 SAML22J18A Universal Serial Bus (USB)
 */
#define IRQn_USB_IRQn 5

/**
 *<  6 SAML22J18A Non-Volatile Memory Controller (NVMCTRL)
 */
#define IRQn_NVMCTRL_IRQn 6

/**
 *<  7 SAML22J18A Direct Memory Access Controller (DMAC)
 */
#define IRQn_DMAC_IRQn 7

/**
 *<  8 SAML22J18A Event System Interface (EVSYS)
 */
#define IRQn_EVSYS_IRQn 8

/**
 *<  9 SAML22J18A Serial Communication Interface 0 (SERCOM0)
 */
#define IRQn_SERCOM0_IRQn 9

/**
 *< 10 SAML22J18A Serial Communication Interface 1 (SERCOM1)
 */
#define IRQn_SERCOM1_IRQn 10

/**
 *< 11 SAML22J18A Serial Communication Interface 2 (SERCOM2)
 */
#define IRQn_SERCOM2_IRQn 11

/**
 *< 12 SAML22J18A Serial Communication Interface 3 (SERCOM3)
 */
#define IRQn_SERCOM3_IRQn 12

/**
 *< 15 SAML22J18A Timer Counter Control (TCC0)
 */
#define IRQn_TCC0_IRQn 15

/**
 *< 16 SAML22J18A Basic Timer Counter 0 (TC0)
 */
#define IRQn_TC0_IRQn 16

/**
 *< 17 SAML22J18A Basic Timer Counter 1 (TC1)
 */
#define IRQn_TC1_IRQn 17

/**
 *< 18 SAML22J18A Basic Timer Counter 2 (TC2)
 */
#define IRQn_TC2_IRQn 18

/**
 *< 19 SAML22J18A Basic Timer Counter 3 (TC3)
 */
#define IRQn_TC3_IRQn 19

/**
 *< 20 SAML22J18A Analog Digital Converter (ADC)
 */
#define IRQn_ADC_IRQn 20

/**
 *< 21 SAML22J18A Analog Comparators (AC)
 */
#define IRQn_AC_IRQn 21

/**
 *< 22 SAML22J18A Peripheral Touch Controller (PTC)
 */
#define IRQn_PTC_IRQn 22

/**
 *< 23 SAML22J18A Segment Liquid Crystal Display Controller (SLCD)
 */
#define IRQn_SLCD_IRQn 23

/**
 *< 24 SAML22J18A Advanced Encryption Standard (AES)
 */
#define IRQn_AES_IRQn 24

/**
 *< 25 SAML22J18A True Random Generator (TRNG)
 */
#define IRQn_TRNG_IRQn 25

/**
 *< Number of peripheral IDs
 */
#define IRQn_PERIPH_COUNT_IRQn 26

#define reset_reason_RESET_REASON_POR 1

#define reset_reason_RESET_REASON_BOD12 2

#define reset_reason_RESET_REASON_BOD33 4

#define reset_reason_RESET_REASON_EXT 16

#define reset_reason_RESET_REASON_WDT 32

#define reset_reason_RESET_REASON_SYST 64

#define reset_reason_RESET_REASON_BACKUP 128

#define gpio_pull_mode_GPIO_PULL_OFF 0

#define gpio_pull_mode_GPIO_PULL_UP 1

#define gpio_pull_mode_GPIO_PULL_DOWN 2

#define gpio_direction_GPIO_DIRECTION_OFF 0

#define gpio_direction_GPIO_DIRECTION_IN 1

#define gpio_direction_GPIO_DIRECTION_OUT 2

#define gpio_port_GPIO_PORTA 0

#define gpio_port_GPIO_PORTB 1

#define gpio_port_GPIO_PORTC 2

#define gpio_port_GPIO_PORTD 3

#define gpio_port_GPIO_PORTE 4

/**
 * Leading edge is rising edge, data sample on leading edge.
 */
#define spi_transfer_mode_SPI_MODE_0 0

/**
 * Leading edge is rising edge, data sample on trailing edge.
 */
#define spi_transfer_mode_SPI_MODE_1 1

/**
 * Leading edge is falling edge, data sample on leading edge.
 */
#define spi_transfer_mode_SPI_MODE_2 2

/**
 * Leading edge is falling edge, data sample on trailing edge.
 */
#define spi_transfer_mode_SPI_MODE_3 3

/**
 * Character size is 8 bit.
 */
#define spi_char_size_SPI_CHAR_SIZE_8 0

/**
 * Character size is 9 bit.
 */
#define spi_char_size_SPI_CHAR_SIZE_9 1

/**
 * Character size is 10 bit.
 */
#define spi_char_size_SPI_CHAR_SIZE_10 2

/**
 * Character size is 11 bit.
 */
#define spi_char_size_SPI_CHAR_SIZE_11 3

/**
 * Character size is 12 bit.
 */
#define spi_char_size_SPI_CHAR_SIZE_12 4

/**
 * Character size is 13 bit.
 */
#define spi_char_size_SPI_CHAR_SIZE_13 5

/**
 * Character size is 14 bit.
 */
#define spi_char_size_SPI_CHAR_SIZE_14 6

/**
 * Character size is 15 bit.
 */
#define spi_char_size_SPI_CHAR_SIZE_15 7

/**
 * Character size is 16 bit.
 */
#define spi_char_size_SPI_CHAR_SIZE_16 8

/**
 * MSB goes first.
 */
#define spi_data_order_SPI_DATA_ORDER_MSB_1ST 0

/**
 * LSB goes first.
 */
#define spi_data_order_SPI_DATA_ORDER_LSB_1ST 1

#define usart_baud_rate_mode_USART_BAUDRATE_ASYNCH_ARITHMETIC 0

#define usart_baud_rate_mode_USART_BAUDRATE_ASYNCH_FRACTIONAL 1

#define usart_baud_rate_mode_USART_BAUDRATE_SYNCH 2

#define usart_data_order_USART_DATA_ORDER_MSB 0

#define usart_data_order_USART_DATA_ORDER_LSB 1

#define usart_mode_USART_MODE_ASYNCHRONOUS 0

#define usart_mode_USART_MODE_SYNCHRONOUS 1

#define usart_parity_USART_PARITY_EVEN 0

#define usart_parity_USART_PARITY_ODD 1

#define usart_parity_USART_PARITY_NONE 2

#define usart_parity_USART_PARITY_SPACE 3

#define usart_parity_USART_PARITY_MARK 4

#define usart_stop_bits_USART_STOP_BITS_ONE 0

#define usart_stop_bits_USART_STOP_BITS_TWO 1

#define usart_stop_bits_USART_STOP_BITS_ONE_P_FIVE 2

#define usart_character_size_USART_CHARACTER_SIZE_8BITS 0

#define usart_character_size_USART_CHARACTER_SIZE_9BITS 1

#define usart_character_size_USART_CHARACTER_SIZE_5BITS 5

#define usart_character_size_USART_CHARACTER_SIZE_6BITS 6

#define usart_character_size_USART_CHARACTER_SIZE_7BITS 7

#define watch_rtc_alarm_match_ALARM_MATCH_DISABLED 0

#define watch_rtc_alarm_match_ALARM_MATCH_SS 1

#define watch_rtc_alarm_match_ALARM_MATCH_MMSS 2

#define watch_rtc_alarm_match_ALARM_MATCH_HHMMSS 3

/**
 *< The hourly signal indicator; also useful for indicating that sensors are on.
 */
#define WatchIndicatorSegment_WATCH_INDICATOR_SIGNAL 0

/**
 *< The small bell indicating that an alarm is set.
 */
#define WatchIndicatorSegment_WATCH_INDICATOR_BELL 1

/**
 *< The PM indicator, indicating that a time is in the afternoon.
 */
#define WatchIndicatorSegment_WATCH_INDICATOR_PM 2

/**
 *< The 24H indicator, indicating that the watch is in a 24-hour mode.
 */
#define WatchIndicatorSegment_WATCH_INDICATOR_24H 3

/**
 *< The LAP indicator; the F-91W uses this in its stopwatch UI.
 */
#define WatchIndicatorSegment_WATCH_INDICATOR_LAP 4

#define watch_interrupt_trigger_INTERRUPT_TRIGGER_NONE 0

#define watch_interrupt_trigger_INTERRUPT_TRIGGER_RISING 1

#define watch_interrupt_trigger_INTERRUPT_TRIGGER_FALLING 2

#define watch_interrupt_trigger_INTERRUPT_TRIGGER_BOTH 3

/**
 *< 55.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A1 0

/**
 *< 58.27 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A1SHARP_B1FLAT 1

/**
 *< 61.74 Hz
 */
#define BuzzerNote_BUZZER_NOTE_B1 2

/**
 *< 65.41 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C2 3

/**
 *< 69.30 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C2SHARP_D2FLAT 4

/**
 *< 73.42 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D2 5

/**
 *< 77.78 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D2SHARP_E2FLAT 6

/**
 *< 82.41 Hz
 */
#define BuzzerNote_BUZZER_NOTE_E2 7

/**
 *< 87.31 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F2 8

/**
 *< 92.50 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F2SHARP_G2FLAT 9

/**
 *< 98.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G2 10

/**
 *< 103.83 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G2SHARP_A2FLAT 11

/**
 *< 110.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A2 12

/**
 *< 116.54 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A2SHARP_B2FLAT 13

/**
 *< 123.47 Hz
 */
#define BuzzerNote_BUZZER_NOTE_B2 14

/**
 *< 130.81 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C3 15

/**
 *< 138.59 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C3SHARP_D3FLAT 16

/**
 *< 146.83 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D3 17

/**
 *< 155.56 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D3SHARP_E3FLAT 18

/**
 *< 164.81 Hz
 */
#define BuzzerNote_BUZZER_NOTE_E3 19

/**
 *< 174.61 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F3 20

/**
 *< 185.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F3SHARP_G3FLAT 21

/**
 *< 196.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G3 22

/**
 *< 207.65 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G3SHARP_A3FLAT 23

/**
 *< 220.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A3 24

/**
 *< 233.08 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A3SHARP_B3FLAT 25

/**
 *< 246.94 Hz
 */
#define BuzzerNote_BUZZER_NOTE_B3 26

/**
 *< 261.63 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C4 27

/**
 *< 277.18 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C4SHARP_D4FLAT 28

/**
 *< 293.66 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D4 29

/**
 *< 311.13 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D4SHARP_E4FLAT 30

/**
 *< 329.63 Hz
 */
#define BuzzerNote_BUZZER_NOTE_E4 31

/**
 *< 349.23 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F4 32

/**
 *< 369.99 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F4SHARP_G4FLAT 33

/**
 *< 392.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G4 34

/**
 *< 415.30 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G4SHARP_A4FLAT 35

/**
 *< 440.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A4 36

/**
 *< 466.16 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A4SHARP_B4FLAT 37

/**
 *< 493.88 Hz
 */
#define BuzzerNote_BUZZER_NOTE_B4 38

/**
 *< 523.25 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C5 39

/**
 *< 554.37 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C5SHARP_D5FLAT 40

/**
 *< 587.33 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D5 41

/**
 *< 622.25 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D5SHARP_E5FLAT 42

/**
 *< 659.25 Hz
 */
#define BuzzerNote_BUZZER_NOTE_E5 43

/**
 *< 698.46 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F5 44

/**
 *< 739.99 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F5SHARP_G5FLAT 45

/**
 *< 783.99 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G5 46

/**
 *< 830.61 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G5SHARP_A5FLAT 47

/**
 *< 880.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A5 48

/**
 *< 932.33 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A5SHARP_B5FLAT 49

/**
 *< 987.77 Hz
 */
#define BuzzerNote_BUZZER_NOTE_B5 50

/**
 *< 1046.50 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C6 51

/**
 *< 1108.73 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C6SHARP_D6FLAT 52

/**
 *< 1174.66 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D6 53

/**
 *< 1244.51 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D6SHARP_E6FLAT 54

/**
 *< 1318.51 Hz
 */
#define BuzzerNote_BUZZER_NOTE_E6 55

/**
 *< 1396.91 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F6 56

/**
 *< 1479.98 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F6SHARP_G6FLAT 57

/**
 *< 1567.98 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G6 58

/**
 *< 1661.22 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G6SHARP_A6FLAT 59

/**
 *< 1760.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A6 60

/**
 *< 1864.66 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A6SHARP_B6FLAT 61

/**
 *< 1975.53 Hz
 */
#define BuzzerNote_BUZZER_NOTE_B6 62

/**
 *< 2093.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C7 63

/**
 *< 2217.46 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C7SHARP_D7FLAT 64

/**
 *< 2349.32 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D7 65

/**
 *< 2489.02 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D7SHARP_E7FLAT 66

/**
 *< 2637.02 Hz
 */
#define BuzzerNote_BUZZER_NOTE_E7 67

/**
 *< 2793.83 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F7 68

/**
 *< 2959.96 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F7SHARP_G7FLAT 69

/**
 *< 3135.96 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G7 70

/**
 *< 3322.44 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G7SHARP_A7FLAT 71

/**
 *< 3520.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A7 72

/**
 *< 3729.31 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A7SHARP_B7FLAT 73

/**
 *< 3951.07 Hz
 */
#define BuzzerNote_BUZZER_NOTE_B7 74

/**
 *< 4186.01 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C8 75

/**
 *< 4434.92 Hz
 */
#define BuzzerNote_BUZZER_NOTE_C8SHARP_D8FLAT 76

/**
 *< 4698.63 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D8 77

/**
 *< 4978.03 Hz
 */
#define BuzzerNote_BUZZER_NOTE_D8SHARP_E8FLAT 78

/**
 *< 5274.04 Hz
 */
#define BuzzerNote_BUZZER_NOTE_E8 79

/**
 *< 5587.65 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F8 80

/**
 *< 5919.91 Hz
 */
#define BuzzerNote_BUZZER_NOTE_F8SHARP_G8FLAT 81

/**
 *< 6271.93 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G8 82

/**
 *< 6644.88 Hz
 */
#define BuzzerNote_BUZZER_NOTE_G8SHARP_A8FLAT 83

/**
 *< 7040.00 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A8 84

/**
 *< 7458.62 Hz
 */
#define BuzzerNote_BUZZER_NOTE_A8SHARP_B8FLAT 85

/**
 *< 7902.13 Hz
 */
#define BuzzerNote_BUZZER_NOTE_B8 86

/**
 *< no sound
 */
#define BuzzerNote_BUZZER_NOTE_REST 87

#define watch_adc_reference_voltage_ADC_REFERENCE_INTREF 0

#define watch_adc_reference_voltage_ADC_REFERENCE_VCC_DIV1POINT6 1

#define watch_adc_reference_voltage_ADC_REFERENCE_VCC_DIV2 2

#define watch_adc_reference_voltage_ADC_REFERENCE_VCC 3

#define movement_event_type_t_EVENT_NONE 0

#define movement_event_type_t_EVENT_ACTIVATE 1

#define movement_event_type_t_EVENT_TICK 2

#define movement_event_type_t_EVENT_LOW_ENERGY_UPDATE 3

#define movement_event_type_t_EVENT_BACKGROUND_TASK 4

#define movement_event_type_t_EVENT_TIMEOUT 5

#define movement_event_type_t_EVENT_LIGHT_BUTTON_DOWN 6

#define movement_event_type_t_EVENT_LIGHT_BUTTON_UP 7

#define movement_event_type_t_EVENT_LIGHT_LONG_PRESS 8

#define movement_event_type_t_EVENT_LIGHT_LONG_UP 9

#define movement_event_type_t_EVENT_MODE_BUTTON_DOWN 10

#define movement_event_type_t_EVENT_MODE_BUTTON_UP 11

#define movement_event_type_t_EVENT_MODE_LONG_PRESS 12

#define movement_event_type_t_EVENT_MODE_LONG_UP 13

#define movement_event_type_t_EVENT_ALARM_BUTTON_DOWN 14

#define movement_event_type_t_EVENT_ALARM_BUTTON_UP 15

#define movement_event_type_t_EVENT_ALARM_LONG_PRESS 16

#define movement_event_type_t_EVENT_ALARM_LONG_UP 17

uint32_t rust_add(uint32_t left, uint32_t right);

void corrosion_face_loop(struct movement_event_t event);

extern int remove(const char *__filename);

extern int rename(const char *__old, const char *__new);

extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new);

extern FILE *tmpfile(void);

extern char *tmpnam(char *__s);

extern char *tmpnam_r(char *__s);

extern char *tempnam(const char *__dir, const char *__pfx);

extern int fclose(FILE *__stream);

extern int fflush(FILE *__stream);

extern int fflush_unlocked(FILE *__stream);

extern FILE *fopen(const char *__filename, const char *__modes);

extern FILE *freopen(const char *__filename, const char *__modes, FILE *__stream);

extern FILE *fdopen(int __fd, const char *__modes);

extern FILE *fmemopen(void *__s, uintptr_t __len, const char *__modes);

extern FILE *open_memstream(char **__bufloc, uintptr_t *__sizeloc);

extern void setbuf(FILE *__stream, char *__buf);

extern int setvbuf(FILE *__stream, char *__buf, int __modes, uintptr_t __n);

extern void setbuffer(FILE *__stream, char *__buf, uintptr_t __size);

extern void setlinebuf(FILE *__stream);

extern int fprintf(FILE *__stream, const char *__format);

extern int printf(const char *__format);

extern int sprintf(char *__s, const char *__format);

extern int vfprintf(FILE *__s, const char *__format, struct __va_list_tag *__arg);

extern int vprintf(const char *__format, struct __va_list_tag *__arg);

extern int vsprintf(char *__s, const char *__format, struct __va_list_tag *__arg);

extern int snprintf(char *__s, unsigned long __maxlen, const char *__format);

extern int vsnprintf(char *__s,
                     unsigned long __maxlen,
                     const char *__format,
                     struct __va_list_tag *__arg);

extern int vdprintf(int __fd, const char *__fmt, struct __va_list_tag *__arg);

extern int dprintf(int __fd, const char *__fmt);

extern int fscanf(FILE *__stream, const char *__format);

extern int scanf(const char *__format);

extern int sscanf(const char *__s, const char *__format);

extern int fscanf1(FILE *__stream, const char *__format);

extern int scanf1(const char *__format);

extern int sscanf1(const char *__s, const char *__format);

extern int vfscanf(FILE *__s, const char *__format, struct __va_list_tag *__arg);

extern int vscanf(const char *__format, struct __va_list_tag *__arg);

extern int vsscanf(const char *__s, const char *__format, struct __va_list_tag *__arg);

extern int vfscanf1(FILE *__s, const char *__format, struct __va_list_tag *__arg);

extern int vscanf1(const char *__format, struct __va_list_tag *__arg);

extern int vsscanf1(const char *__s, const char *__format, struct __va_list_tag *__arg);

extern int fgetc(FILE *__stream);

extern int getc(FILE *__stream);

extern int getchar(void);

extern int getc_unlocked(FILE *__stream);

extern int getchar_unlocked(void);

extern int fgetc_unlocked(FILE *__stream);

extern int fputc(int __c, FILE *__stream);

extern int putc(int __c, FILE *__stream);

extern int putchar(int __c);

extern int fputc_unlocked(int __c, FILE *__stream);

extern int putc_unlocked(int __c, FILE *__stream);

extern int putchar_unlocked(int __c);

extern int getw(FILE *__stream);

extern int putw(int __w, FILE *__stream);

extern char *fgets(char *__s, int __n, FILE *__stream);

extern __ssize_t __getdelim(char **__lineptr, uintptr_t *__n, int __delimiter, FILE *__stream);

extern __ssize_t getdelim(char **__lineptr, uintptr_t *__n, int __delimiter, FILE *__stream);

extern __ssize_t getline(char **__lineptr, uintptr_t *__n, FILE *__stream);

extern int fputs(const char *__s, FILE *__stream);

extern int puts(const char *__s);

extern int ungetc(int __c, FILE *__stream);

extern unsigned long fread(void *__ptr, unsigned long __size, unsigned long __n, FILE *__stream);

extern unsigned long fwrite(const void *__ptr, unsigned long __size, unsigned long __n, FILE *__s);

extern uintptr_t fread_unlocked(void *__ptr, uintptr_t __size, uintptr_t __n, FILE *__stream);

extern uintptr_t fwrite_unlocked(const void *__ptr,
                                 uintptr_t __size,
                                 uintptr_t __n,
                                 FILE *__stream);

extern int fseek(FILE *__stream, long __off, int __whence);

extern long ftell(FILE *__stream);

extern void rewind(FILE *__stream);

extern int fseeko(FILE *__stream, __off_t __off, int __whence);

extern __off_t ftello(FILE *__stream);

extern int fgetpos(FILE *__stream, fpos_t *__pos);

extern int fsetpos(FILE *__stream, const fpos_t *__pos);

extern void clearerr(FILE *__stream);

extern int feof(FILE *__stream);

extern int ferror(FILE *__stream);

extern void clearerr_unlocked(FILE *__stream);

extern int feof_unlocked(FILE *__stream);

extern int ferror_unlocked(FILE *__stream);

extern void perror(const char *__s);

extern int fileno(FILE *__stream);

extern int fileno_unlocked(FILE *__stream);

extern FILE *popen(const char *__command, const char *__modes);

extern int pclose(FILE *__stream);

extern char *ctermid(char *__s);

extern void flockfile(FILE *__stream);

extern int ftrylockfile(FILE *__stream);

extern void funlockfile(FILE *__stream);

extern int __uflow(FILE *arg1);

extern int __overflow(FILE *arg1, int arg2);

extern void Reset_Handler(void);

extern void NonMaskableInt_Handler(void);

extern void HardFault_Handler(void);

extern void SVCall_Handler(void);

extern void PendSV_Handler(void);

extern void SysTick_Handler(void);

extern void SYSTEM_Handler(void);

extern void WDT_Handler(void);

extern void RTC_Handler(void);

extern void EIC_Handler(void);

extern void FREQM_Handler(void);

extern void USB_Handler(void);

extern void NVMCTRL_Handler(void);

extern void DMAC_Handler(void);

extern void EVSYS_Handler(void);

extern void SERCOM0_Handler(void);

extern void SERCOM1_Handler(void);

extern void SERCOM2_Handler(void);

extern void SERCOM3_Handler(void);

extern void TCC0_Handler(void);

extern void TC0_Handler(void);

extern void TC1_Handler(void);

extern void TC2_Handler(void);

extern void TC3_Handler(void);

extern void ADC_Handler(void);

extern void AC_Handler(void);

extern void PTC_Handler(void);

extern void SLCD_Handler(void);

extern void AES_Handler(void);

extern void TRNG_Handler(void);

extern void SystemInit(void);

extern void SystemCoreClockUpdate(void);

/**
 * \brief Disable interrupts, enter critical section
 *
 * Disables global interrupts. Supports nested critical sections,  so that global interrupts are only re-enabled  upon leaving the outermost nested critical section.
 *
 * \param[out] atomic The pointer to a variable to store the value of global  interrupt enable flag
 */
extern void atomic_enter_critical(hal_atomic_t *atomic);

/**
 * \brief Exit atomic section
 *
 * Enables global interrupts. Supports nested critical sections,  so that global interrupts are only re-enabled  upon leaving the outermost nested critical section.
 *
 * \param[in] atomic The pointer to a variable, which stores the latest stored  value of the global interrupt enable flag
 */
extern void atomic_leave_critical(hal_atomic_t *atomic);

/**
 * \brief Retrieve the current driver version
 *
 * \return Current driver version.
 */
extern uint32_t atomic_get_version(void);

/**
 * \brief Retrieve current IRQ number
 *
 * \return The current IRQ number
 */
extern uint8_t _irq_get_current(void);

/**
 * \brief Disable the given IRQ
 *
 * \param[in] n The number of IRQ to disable
 */
extern void _irq_disable(uint8_t n);

/**
 * \brief Set the given IRQ
 *
 * \param[in] n The number of IRQ to set
 */
extern void _irq_set(uint8_t n);

/**
 * \brief Clear the given IRQ
 *
 * \param[in] n The number of IRQ to clear
 */
extern void _irq_clear(uint8_t n);

/**
 * \brief Enable the given IRQ
 *
 * \param[in] n The number of IRQ to enable
 */
extern void _irq_enable(uint8_t n);

/**
 * \brief Register IRQ handler
 *
 * \param[in] number The number registered IRQ  \param[in] irq The pointer to irq handler to register
 *
 * \return The status of IRQ handler registering  \retval -1 Passed parameters were invalid  \retval 0 The registering is completed successfully
 */
extern void _irq_register(uint8_t number,
                          struct _irq_descriptor *irq);

/**
 * \brief Retrieve the reset reason
 *
 * Retrieves the reset reason of the last MCU reset.
 *
 *\return An enum value indicating the reason of the last reset.
 */
extern reset_reason _get_reset_reason(void);

/**
 * \brief Reset MCU
 */
extern void _reset_mcu(void);

/**
 * \brief Set the sleep mode for the device
 *
 * This function sets the sleep mode for the device.  For an overview of which systems are disabled in sleep for the different  sleep modes see datasheet.
 *
 * \param[in] mode Sleep mode to use
 *
 * \return the status of a sleep request  \retval -1 The requested sleep mode was invalid  \retval  0 The operation completed successfully, sleep mode is set
 */
extern int32_t _set_sleep_mode(uint8_t mode);

/**
 * \brief Put MCU to sleep
 */
extern void _go_to_sleep(void);

/**
 * \brief Initialize Delay driver
 *
 * \param[in] hw The pointer to hardware instance
 */
extern void delay_init(void *hw);

/**
 * \brief Perform delay in us
 *
 * This function performs delay for the given amount of microseconds.
 *
 * \param[in] us The amount delay in us
 */
extern void delay_us(uint16_t us);

/**
 * \brief Perform delay in ms
 *
 * This function performs delay for the given amount of milliseconds.
 *
 * \param[in] ms The amount delay in ms
 */
extern void delay_ms(uint16_t ms);

/**
 * \brief Retrieve the current driver version
 *
 * \return Current driver version.
 */
extern uint32_t delay_get_version(void);

/**
 * \brief Port initialization function
 *
 * Port initialization function should setup the port module based  on a static configuration file, this function should normally  not be called directly, but is a part of hal_init()
 */
extern void _gpio_init(void);

/**
 * \brief Assert function
 *
 * This function is used to throw asserts.
 *
 * \param[in] condition A condition to be checked; assert is thrown if the given                       condition is false  \param[in] file File name  \param[in] line Line number
 */
extern void assert(bool condition,
                   const char *file,
                   int line);

/**
 * \brief Get current driver version
 */
extern uint32_t gpio_get_version(void);

/**
 * \brief Initializes clock sources
 */
extern void _sysctrl_init_sources(void);

/**
 * \brief Initializes Power Manager
 */
extern void _pm_init(void);

/**
 * \brief Initialize generators
 */
extern void _gclk_init_generators(void);

/**
 * \brief Initialize 32 kHz clock sources
 */
extern void _osc32kctrl_init_sources(void);

/**
 * \brief Initialize clock sources
 */
extern void _oscctrl_init_sources(void);

/**
 * \brief Initialize clock sources that need input reference clocks
 */
extern void _sysctrl_init_referenced_generators(void);

/**
 * \brief Initialize clock sources that need input reference clocks
 */
extern void _oscctrl_init_referenced_generators(void);

/**
 * \brief Initialize master clock generator
 */
extern void _mclk_init(void);

/**
 * \brief Initialize clock generator
 */
extern void _lpmcu_misc_regs_init(void);

/**
 * \brief Initialize clock generator
 */
extern void _pmc_init(void);

/**
 * \brief Set performance level
 *
 * \param[in] level The performance level to set
 */
extern void _set_performance_level(uint8_t level);

/**
 * \brief Initialize the chip
 */
extern void _init_chip(void);

/**
 * \brief Retrieve the current driver version
 *
 * \return Current driver version.
 */
extern uint32_t init_get_version(void);

/**
 * \brief I/O write interface
 *
 * This function writes up to \p length of bytes to a given I/O descriptor.  It returns the number of bytes actually write.
 *
 * \param[in] descr  An I/O descriptor to write  \param[in] buf    The buffer pointer to story the write data  \param[in] length The number of bytes to write
 *
 * \return The number of bytes written
 */
extern int32_t io_write(struct io_descriptor *io_descr,
                        const uint8_t *buf,
                        uint16_t length);

/**
 * \brief I/O read interface
 *
 * This function reads up to \p length bytes from a given I/O descriptor, and  stores it in the buffer pointed to by \p buf. It returns the number of bytes  actually read.
 *
 * \param[in] descr  An I/O descriptor to read  \param[in] buf    The buffer pointer to story the read data  \param[in] length The number of bytes to read
 *
 * \return The number of bytes actually read. This number can be less than the          requested length. E.g., in a driver that uses ring buffer for          reception, it may depend on the availability of data in the          ring buffer.
 */
extern int32_t io_read(struct io_descriptor *io_descr,
                       uint8_t *buf,
                       uint16_t length);

/**
 * \brief Set the sleep mode of the device and put the MCU to sleep
 *
 * For an overview of which systems are disabled in sleep for the different  sleep modes, see the data sheet.
 *
 * \param[in] mode Sleep mode to use
 *
 * \return The status of a sleep request  \retval -1 The requested sleep mode was invalid or not available  \retval  0 The operation completed successfully, returned after leaving the             sleep
 */
extern int sleep(uint8_t mode);

/**
 * \brief Retrieve the current driver version
 *
 * \return Current driver version.
 */
extern uint32_t sleep_get_version(void);

/**
 * \brief Initialize external interrupt module
 *
 * This function does low level external interrupt configuration.
 *
 * \param[in] cb The pointer to callback function from external interrupt
 *
 * \return Initialization status.  \retval -1 External irq module is already initialized  \retval 0 The initialization is completed successfully
 */
extern int32_t _ext_irq_init(void (*cb)(uint32_t pin));

/**
 * \brief Deinitialize external interrupt module
 *
 * \return Initialization status.  \retval -1 External irq module is already deinitialized  \retval 0 The de-initialization is completed successfully
 */
extern int32_t _ext_irq_deinit(void);

/**
 * \brief Enable / disable external irq
 *
 * \param[in] pin Pin to enable external irq on  \param[in] enable True to enable, false to disable
 *
 * \return Status of external irq enabling / disabling  \retval -1 External irq module can't be enabled / disabled  \retval 0 External irq module is enabled / disabled successfully
 */
extern int32_t _ext_irq_enable(uint32_t pin,
                               bool enable);

/**
 * \brief Initialize external IRQ component, if any
 *
 * \return Initialization status.  \retval -1 External IRQ module is already initialized  \retval 0 The initialization is completed successfully
 */
extern int32_t ext_irq_init(void);

/**
 * \brief Deinitialize external IRQ, if any
 *
 * \return De-initialization status.  \retval -1 External IRQ module is already deinitialized  \retval 0 The de-initialization is completed successfully
 */
extern int32_t ext_irq_deinit(void);

/**
 * \brief Register callback for the given external interrupt
 *
 * \param[in] pin Pin to enable external IRQ on  \param[in] cb Callback function
 *
 * \return Registration status.  \retval -1 Passed parameters were invalid  \retval 0 The callback registration is completed successfully
 */
extern int32_t ext_irq_register(uint32_t pin,
                                ext_irq_cb_t cb);

/**
 * \brief Enable external IRQ
 *
 * \param[in] pin Pin to enable external IRQ on
 *
 * \return Enabling status.  \retval -1 Passed parameters were invalid  \retval 0 The enabling is completed successfully
 */
extern int32_t ext_irq_enable(uint32_t pin);

/**
 * \brief Disable external IRQ
 *
 * \param[in] pin Pin to enable external IRQ on
 *
 * \return Disabling status.  \retval -1 Passed parameters were invalid  \retval 0 The disabling is completed successfully
 */
extern int32_t ext_irq_disable(uint32_t pin);

/**
 * \brief Retrieve the current driver version
 *
 * \return Current driver version.
 */
extern uint32_t ext_irq_get_version(void);

/**
 * \brief Initialize I2C
 *
 * This function does low level I2C configuration.
 *
 * \param[in] i2c_dev The pointer to i2c device structure  \param[in] hw The pointer to hardware instance
 *
 * \return Return 0 for success and negative value for error
 */
extern int32_t _i2c_m_sync_init(struct _i2c_m_sync_device *i2c_dev,
                                void *hw);

/**
 * \brief Deinitialize I2C
 *
 * \param[in] i2c_dev The pointer to i2c device structure
 *
 * \return Return 0 for success and negative value for error
 */
extern int32_t _i2c_m_sync_deinit(struct _i2c_m_sync_device *i2c_dev);

/**
 * \brief Enable I2C module
 *
 * This function does low level I2C enable.
 *
 * \param[in] i2c_dev The pointer to i2c device structure
 *
 * \return Return 0 for success and negative value for error
 */
extern int32_t _i2c_m_sync_enable(struct _i2c_m_sync_device *i2c_dev);

/**
 * \brief Disable I2C module
 *
 * This function does low level I2C disable.
 *
 * \param[in] i2c_dev The pointer to i2c device structure
 *
 * \return Return 0 for success and negative value for error
 */
extern int32_t _i2c_m_sync_disable(struct _i2c_m_sync_device *i2c_dev);

/**
 * \brief Transfer data by I2C
 *
 * This function does low level I2C data transfer.
 *
 * \param[in] i2c_dev The pointer to i2c device structure  \param[in] msg The pointer to i2c msg structure
 *
 * \return Return 0 for success and negative value for error
 */
extern int32_t _i2c_m_sync_transfer(struct _i2c_m_sync_device *i2c_dev,
                                    struct _i2c_m_msg *msg);

/**
 * \brief Set baud rate of I2C
 *
 * This function does low level I2C set baud rate.
 *
 * \param[in] i2c_dev The pointer to i2c device structure  \param[in] clkrate The clock rate(KHz) input to i2c module  \param[in] baudrate The demand baud rate(KHz) of i2c module
 *
 * \return Return 0 for success and negative value for error
 */
extern int32_t _i2c_m_sync_set_baudrate(struct _i2c_m_sync_device *i2c_dev,
                                        uint32_t clkrate,
                                        uint32_t baudrate);

/**
 * \brief Send send condition on the I2C bus
 *
 * This function will generate a stop condition on the I2C bus
 *
 * \param[in] i2c_dev The pointer to i2c device struct
 *
 * \return Return 0 for success and negative value for error
 */
extern int32_t _i2c_m_sync_send_stop(struct _i2c_m_sync_device *i2c_dev);

/**
 * \brief Initialize synchronous I2C interface
 *
 * This function initializes the given I/O descriptor to be used as a  synchronous I2C interface descriptor.  It checks if the given hardware is not initialized and if the given hardware  is permitted to be initialized.
 *
 * \param[in] i2c An I2C descriptor, which is used to communicate through I2C  \param[in] hw The pointer to hardware instance
 *
 * \return Initialization status.  \retval -1 The passed parameters were invalid or the interface is already initialized  \retval 0 The initialization is completed successfully
 */
extern int32_t i2c_m_sync_init(struct i2c_m_sync_desc *i2c,
                               void *hw);

/**
 * \brief Deinitialize I2C interface
 *
 * This function deinitializes the given I/O descriptor.  It checks if the given hardware is initialized and if the given hardware is permitted to be deinitialized.
 *
 * \param[in] i2c An I2C descriptor, which is used to communicate through I2C
 *
 * \return Uninitialization status.  \retval -1 The passed parameters were invalid or the interface is already deinitialized  \retval 0 The de-initialization is completed successfully
 */
extern int32_t i2c_m_sync_deinit(struct i2c_m_sync_desc *i2c);

/**
 * \brief Set the peripheral device address
 *
 * This function sets the next transfer target peripheral I2C device address.  It takes no effect to any already started access.
 *
 * \param[in] i2c An I2C descriptor, which is used to communicate through I2C  \param[in] addr The peripheral address to access  \param[in] addr_len The peripheral address length, can be I2C_M_TEN or I2C_M_SEVEN
 *
 * \return Masked peripheral address. The mask is a maximum 10-bit address, and 10th          bit is set if a 10-bit address is used
 */
extern int32_t i2c_m_sync_set_periphaddr(struct i2c_m_sync_desc *i2c,
                                         int16_t addr,
                                         int32_t addr_len);

/**
 * \brief Set baudrate
 *
 * This function sets the I2C device to the specified baudrate.  It only takes effect when the hardware is disabled.
 *
 * \param[in] i2c An I2C descriptor, which is used to communicate through I2C  \param[in] clkrate Unused parameter. Should always be 0  \param[in] baudrate The baudrate value set to controller
 *
 * \return Whether successfully set the baudrate  \retval -1 The passed parameters were invalid or the device is already enabled  \retval 0 The baudrate set is completed successfully
 */
extern int32_t i2c_m_sync_set_baudrate(struct i2c_m_sync_desc *i2c,
                                       uint32_t clkrate,
                                       uint32_t baudrate);

/**
 * \brief Sync version of enable hardware
 *
 * This function enables the I2C device, and then waits for this enabling operation to be done
 *
 * \param[in] i2c An I2C descriptor, which is used to communicate through I2C
 *
 * \return Whether successfully enable the device  \retval -1 The passed parameters were invalid or the device enable failed  \retval 0 The hardware enabling is completed successfully
 */
extern int32_t i2c_m_sync_enable(struct i2c_m_sync_desc *i2c);

/**
 * \brief Sync version of disable hardware
 *
 * This function disables the I2C device and then waits for this disabling operation to be done
 *
 * \param[in] i2c An I2C descriptor, which is used to communicate through I2C
 *
 * \return Whether successfully disable the device  \retval -1 The passed parameters were invalid or the device disable failed  \retval 0 The hardware disabling is completed successfully
 */
extern int32_t i2c_m_sync_disable(struct i2c_m_sync_desc *i2c);

/**
 * \brief Sync version of write command to I2C peripheral
 *
 * This function will write the value to a specified register in the I2C peripheral device and  then wait for this operation to be done.
 *
 * The sequence of this routine is  sta->address(write)->ack->reg address->ack->resta->address(write)->ack->reg value->nack->stt
 *
 * \param[in] i2c An I2C descriptor, which is used to communicate through I2C  \param[in] reg The internal address/register of the I2C peripheral device  \param[in] buffer The buffer holding data to write to the I2C peripheral device  \param[in] length The length (in bytes) to write to the I2C peripheral device
 *
 * \return Whether successfully write to the device  \retval <0 The passed parameters were invalid or write fail  \retval 0 Writing to register is completed successfully
 */
extern int32_t i2c_m_sync_cmd_write(struct i2c_m_sync_desc *i2c,
                                    uint8_t reg,
                                    uint8_t *buffer,
                                    uint8_t length);

/**
 * \brief Sync version of read register value from I2C peripheral
 *
 * This function will read a byte value from a specified register in the I2C peripheral device and  then wait for this operation to be done.
 *
 * The sequence of this routine is  sta->address(write)->ack->reg address->ack->resta->address(read)->ack->reg value->nack->stt
 *
 * \param[in] i2c An I2C descriptor, which is used to communicate through I2C  \param[in] reg The internal address/register of the I2C peripheral device  \param[in] buffer The buffer to hold the read data from the I2C peripheral device  \param[in] length The length (in bytes) to read from the I2C peripheral device
 *
 * \return Whether successfully read from the device  \retval <0 The passed parameters were invalid or read fail  \retval 0 Reading from register is completed successfully
 */
extern int32_t i2c_m_sync_cmd_read(struct i2c_m_sync_desc *i2c,
                                   uint8_t reg,
                                   uint8_t *buffer,
                                   uint8_t length);

/**
 * \brief Sync version of transfer message to/from the I2C peripheral
 *
 * This function will transfer a message between the I2C peripheral and the controller.  This function will wait for the operation to be done.
 *
 * \param[in] i2c An I2C descriptor, which is used to communicate through I2C  \param[in] msg  An i2c_m_msg struct
 *
 * \return The status of the operation  \retval 0 Operation completed successfully  \retval <0 Operation failed
 */
extern int32_t i2c_m_sync_transfer(struct i2c_m_sync_desc *i2c,
                                   struct _i2c_m_msg *msg);

/**
 * \brief Sync version of send stop condition on the i2c bus
 *
 * This function will create a stop condition on the i2c bus to release the bus
 *
 * \param[in] i2c An I2C descriptor, which is used to communicate through I2C
 *
 * \return The status of the operation  \retval 0 Operation completed successfully  \retval <0 Operation failed
 */
extern int32_t i2c_m_sync_send_stop(struct i2c_m_sync_desc *i2c);

/**
 * \brief Return I/O descriptor for this I2C instance
 *
 * This function will return a I/O instance for this I2C driver instance
 *
 * \param[in] i2c_m_sync_desc An I2C descriptor, which is used to communicate through I2C  \param[in] io_descriptor A pointer to an I/O descriptor pointer type
 *
 * \return Error code  \retval 0 No error detected  \retval <0 Error code
 */
extern int32_t i2c_m_sync_get_io_descriptor(struct i2c_m_sync_desc *i2c,
                                            struct io_descriptor **io);

/**
 * \brief Retrieve the current driver version
 *
 * \return Current driver version.
 */
extern uint32_t i2c_m_sync_get_version(void);

/**
 *  \brief Calculate the baudrate value for hardware to use to set baudrate   \param[in, out] dev Pointer to the SPI device instance.   \param[in] clk Clock frequency (Hz) for baudrate generation.   \param[in] baud Target baudrate (bps).   \return Error or baudrate value.   \retval >0 Baudrate value.   \retval ERR_INVALID_ARG Calculation fail.
 */
extern int32_t _spi_calc_baud_val(struct spi_dev *dev,
                                  uint32_t clk,
                                  uint32_t baud);

/**
 *  \brief Initialize SPI for access without interrupts   It will load default hardware configuration and software struct.   \param[in, out] dev Pointer to the SPI device instance.   \param[in] hw Pointer to the hardware base.   \return Operation status.   \retval ERR_INVALID_ARG Input parameter problem.   \retval ERR_BUSY SPI hardware not ready (resetting).   \retval ERR_DENIED SPI has been enabled.   \retval 0 Operation done successfully.
 */
extern int32_t _spi_m_sync_init(struct _spi_sync_dev *dev,
                                void *hw);

/**
 *  \brief Deinitialize SPI   Disable, reset the hardware and the software struct.   \param[in, out] dev Pointer to the SPI device instance.   \return Operation status.   \retval 0 Operation done successfully.
 */
extern int32_t _spi_m_sync_deinit(struct _spi_sync_dev *dev);

/**
 *  \brief Enable SPI for access without interrupts   \param[in, out] dev Pointer to the SPI device instance.   \return Operation status.   \retval ERR_BUSY SPI hardware not ready (resetting).   \retval 0 Operation done successfully.
 */
extern int32_t _spi_m_sync_enable(struct _spi_sync_dev *dev);

/**
 *  \brief Disable SPI for access without interrupts   Disable SPI. Deactivate all CS pins if works as master.   \param[in, out] dev Pointer to the SPI device instance.   \return Operation status.   \retval 0 Operation done successfully.
 */
extern int32_t _spi_m_sync_disable(struct _spi_sync_dev *dev);

/**
 *  \brief Set SPI transfer mode   Set SPI transfer mode (\ref spi_transfer_mode),   which controls clock polarity and clock phase.   Mode 0: leading edge is rising edge, data sample on leading edge.   Mode 1: leading edge is rising edge, data sample on trailing edge.   Mode 2: leading edge is falling edge, data sample on leading edge.   Mode 3: leading edge is falling edge, data sample on trailing edge.   \param[in, out] dev Pointer to the SPI device instance.   \param[in] mode The SPI transfer mode.   \return Operation status.   \retval ERR_BUSY SPI is not ready to accept new setting.   \retval 0 Operation done successfully.
 */
extern int32_t _spi_m_sync_set_mode(struct _spi_sync_dev *dev,
                                    spi_transfer_mode mode);

/**
 *  \brief Set SPI baudrate   \param[in, out] dev Pointer to the SPI device instance.   \param[in] baud_val The SPI baudrate value, see \ref _spi_calc_baud_val() on                   how it's generated.   \return Operation status.   \retval ERR_BUSY SPI is not ready to accept new setting.   \retval 0 Operation done successfully.
 */
extern int32_t _spi_m_sync_set_baudrate(struct _spi_sync_dev *dev,
                                        uint32_t baud_val);

/**
 *  \brief Set SPI char size   \param[in, out] dev Pointer to the SPI device instance.   \param[in] char_size The character size, see \ref spi_char_size.   \return Operation status.   \retval ERR_INVALID_ARG The character size is not supported.   \retval ERR_BUSY SPI is not ready to accept new setting.   \retval 0 Operation done successfully.
 */
extern int32_t _spi_m_sync_set_char_size(struct _spi_sync_dev *dev,
                                         spi_char_size char_size);

/**
 *  \brief Set SPI data order   \param[in, out] dev Pointer to the SPI device instance.   \param[in] dord SPI data order (LSB/MSB first).   \return Operation status.   \retval ERR_INVALID_ARG The character size is not supported.   \retval ERR_BUSY SPI is not ready to accept new setting.   \retval 0 Operation done successfully.
 */
extern int32_t _spi_m_sync_set_data_order(struct _spi_sync_dev *dev,
                                          spi_data_order dord);

/**
 *  \brief Transfer the whole message without interrupt   Transfer the message, it will keep waiting until the message finish or   error.   \param[in, out] dev Pointer to the SPI device instance.   \param[in] msg Pointer to the message instance to process.   \return Error or number of characters transferred.   \retval ERR_BUSY SPI hardware is not ready to start transfer (not                    enabled, busy applying settings, ...).   \retval SPI_ERR_OVERFLOW Overflow error.   \retval >=0 Number of characters transferred.
 */
extern int32_t _spi_m_sync_trans(struct _spi_sync_dev *dev,
                                 const struct spi_msg *msg);

/**
 * \brief Set the SPI HAL instance function pointer for HPL APIs.
 *
 *  Set SPI HAL instance function pointer for HPL APIs.
 *
 *  \param[in] spi Pointer to the HAL SPI instance.   \param[in] func Pointer to the HPL api structure.
 */
extern void spi_m_sync_set_func_ptr(struct spi_m_sync_descriptor *spi,
                                    void *func);

/**
 * \brief Initialize SPI HAL instance and hardware for polling mode
 *
 *  Initialize SPI HAL with polling mode.
 *
 *  \param[in] spi Pointer to the HAL SPI instance.   \param[in] hw Pointer to the hardware base.
 *
 *  \return Operation status.   \retval ERR_NONE Success.   \retval ERR_INVALID_DATA Error, initialized.
 */
extern int32_t spi_m_sync_init(struct spi_m_sync_descriptor *spi,
                               void *hw);

/**
 * \brief Deinitialize the SPI HAL instance and hardware
 *
 *  Abort transfer, disable and reset SPI, deinit software.
 *
 *  \param[in] spi Pointer to the HAL SPI instance.
 *
 *  \return Operation status.   \retval ERR_NONE Success.   \retval <0 Error code.
 */
extern void spi_m_sync_deinit(struct spi_m_sync_descriptor *spi);

/**
 * \brief Enable SPI
 *
 *  \param[in] spi Pointer to the HAL SPI instance.
 *
 *  \return Operation status.   \retval ERR_NONE Success.   \retval <0 Error code.
 */
extern void spi_m_sync_enable(struct spi_m_sync_descriptor *spi);

/**
 * \brief Disable SPI
 *
 *  \param[in] spi Pointer to the HAL SPI instance.
 *
 *  \return Operation status.   \retval ERR_NONE Success.   \retval <0 Error code.
 */
extern void spi_m_sync_disable(struct spi_m_sync_descriptor *spi);

/**
 * \brief Set SPI baudrate
 *
 *  Works if SPI is initialized as master, it sets the baudrate.
 *
 *  \param[in] spi Pointer to the HAL SPI instance.   \param[in] baud_val The target baudrate value                   (see "baudrate calculation" for calculating the value).
 *
 *  \return Operation status.   \retval ERR_NONE Success.   \retval ERR_BUSY Busy   \retval ERR_INVALID_ARG The baudrate is not supported.
 */
extern int32_t spi_m_sync_set_baudrate(struct spi_m_sync_descriptor *spi,
                                       uint32_t baud_val);

/**
 * \brief Set SPI mode
 *
 *  Set the SPI transfer mode (\ref spi_transfer_mode),   which controls the clock polarity and clock phase:   - Mode 0: leading edge is rising edge, data sample on leading edge.   - Mode 1: leading edge is rising edge, data sample on trailing edge.   - Mode 2: leading edge is falling edge, data sample on leading edge.   - Mode 3: leading edge is falling edge, data sample on trailing edge.
 *
 *  \param[in] spi Pointer to the HAL SPI instance.   \param[in] mode The mode (0~3).
 *
 *  \return Operation status.   \retval ERR_NONE Success.   \retval ERR_BUSY Busy   \retval ERR_INVALID_ARG The mode is not supported.
 */
extern int32_t spi_m_sync_set_mode(struct spi_m_sync_descriptor *spi,
                                   spi_transfer_mode mode);

/**
 * \brief Set SPI transfer character size in number of bits
 *
 *  The character size (\ref spi_char_size) influence the way the data is   sent/received.   For char size <= 8-bit, data is stored byte by byte.   For char size between 9-bit ~ 16-bit, data is stored in 2-byte length.   Note that the default and recommended char size is 8-bit since it's   supported by all system.
 *
 *  \param[in] spi Pointer to the HAL SPI instance.   \param[in] char_size The char size (~16, recommended 8).
 *
 *  \return Operation status.   \retval ERR_NONE Success.   \retval ERR_BUSY Busy   \retval ERR_INVALID_ARG The char size is not supported.
 */
extern int32_t spi_m_sync_set_char_size(struct spi_m_sync_descriptor *spi,
                                        spi_char_size char_size);

/**
 * \brief Set SPI transfer data order
 *
 *  \param[in] spi Pointer to the HAL SPI instance.   \param[in] dord The data order: send LSB/MSB first.
 *
 *  \return Operation status.   \retval ERR_NONE Success.   \retval ERR_BUSY Busy   \retval ERR_INVALID_ARG The data order is not supported.
 */
extern int32_t spi_m_sync_set_data_order(struct spi_m_sync_descriptor *spi,
                                         spi_data_order dord);

/**
 * \brief Perform the SPI data transfer (TX and RX) in polling way
 *
 *  Activate CS, do TX and RX and deactivate CS. It blocks.
 *
 *  \param[in, out] spi Pointer to the HAL SPI instance.   \param[in] xfer Pointer to the transfer information (\ref spi_xfer).
 *
 *  \retval size Success.   \retval >=0 Timeout, with number of characters transferred.   \retval ERR_BUSY SPI is busy
 */
extern int32_t spi_m_sync_transfer(struct spi_m_sync_descriptor *spi,
                                   const struct spi_xfer *xfer);

/**
 * \brief Return the I/O descriptor for this SPI instance
 *
 * This function will return an I/O instance for this SPI driver instance.
 *
 * \param[in] spi An SPI master descriptor, which is used to communicate through                 SPI  \param[in, out] io A pointer to an I/O descriptor pointer type
 *
 * \retval ERR_NONE
 */
extern int32_t spi_m_sync_get_io_descriptor(struct spi_m_sync_descriptor *spi,
                                            struct io_descriptor **io);

/**
 * \brief Retrieve the current driver version
 *
 *  \return Current driver version.
 */
extern uint32_t spi_m_sync_get_version(void);

/**
 * \brief Initialize synchronous USART
 *
 * This function does low level USART configuration.
 *
 * \param[in] device The pointer to USART device instance  \param[in] hw The pointer to hardware instance
 *
 * \return Initialization status
 */
extern int32_t _usart_sync_init(struct _usart_sync_device *device,
                                void *hw);

/**
 * \brief Deinitialize USART
 *
 * This function closes the given USART by disabling its clock.
 *
 * \param[in] device The pointer to USART device instance
 */
extern void _usart_sync_deinit(struct _usart_sync_device *device);

/**
 * \brief Enable usart module
 *
 * This function will enable the usart module
 *
 * \param[in] device The pointer to USART device instance
 */
extern void _usart_sync_enable(struct _usart_sync_device *device);

/**
 * \brief Disable usart module
 *
 * This function will disable the usart module
 *
 * \param[in] device The pointer to USART device instance
 */
extern void _usart_sync_disable(struct _usart_sync_device *device);

/**
 * \brief Calculate baud rate register value
 *
 * \param[in] baud Required baud rate  \param[in] clock_rate clock frequency  \param[in] samples The number of samples  \param[in] mode USART mode  \param[in] fraction A fraction value
 *
 * \return Calculated baud rate register value
 */
extern uint16_t _usart_sync_calculate_baud_rate(uint32_t baud,
                                                uint32_t clock_rate,
                                                uint8_t samples,
                                                usart_baud_rate_mode mode,
                                                uint8_t fraction);

/**
 * \brief Set baud rate
 *
 * \param[in] device The pointer to USART device instance  \param[in] baud_rate A baud rate to set
 */
extern void _usart_sync_set_baud_rate(struct _usart_sync_device *device, uint32_t baud_rate);

/**
 * \brief Set data order
 *
 * \param[in] device The pointer to USART device instance  \param[in] order A data order to set
 */
extern void _usart_sync_set_data_order(struct _usart_sync_device *device, usart_data_order order);

/**
 * \brief Set mode
 *
 * \param[in] device The pointer to USART device instance  \param[in] mode A mode to set
 */
extern void _usart_sync_set_mode(struct _usart_sync_device *device, usart_mode mode);

/**
 * \brief Set parity
 *
 * \param[in] device The pointer to USART device instance  \param[in] parity A parity to set
 */
extern void _usart_sync_set_parity(struct _usart_sync_device *device, usart_parity parity);

/**
 * \brief Set stop bits mode
 *
 * \param[in] device The pointer to USART device instance  \param[in] stop_bits A stop bits mode to set
 */
extern void _usart_sync_set_stop_bits(struct _usart_sync_device *device,
                                      usart_stop_bits stop_bits);

/**
 * \brief Set character size
 *
 * \param[in] device The pointer to USART device instance  \param[in] size A character size to set
 */
extern void _usart_sync_set_character_size(struct _usart_sync_device *device,
                                           usart_character_size size);

/**
 * \brief Retrieve usart status
 *
 * \param[in] device The pointer to USART device instance
 */
extern uint32_t _usart_sync_get_status(const struct _usart_sync_device *device);

/**
 * \brief Write a byte to the given USART instance
 *
 * \param[in] device The pointer to USART device instance  \param[in] data Data to write
 */
extern void _usart_sync_write_byte(struct _usart_sync_device *device, uint8_t data);

/**
 * \brief Read a byte from the given USART instance
 *
 * \param[in] device The pointer to USART device instance  \param[in] data Data to write
 *
 * \return Data received via USART interface.
 */
extern uint8_t _usart_sync_read_byte(const struct _usart_sync_device *device);

/**
 * \brief Check if USART is ready to send next byte
 *
 * \param[in] device The pointer to USART device instance
 *
 * \return Status of the ready check.  \retval true if the USART is ready to send next byte  \retval false if the USART is not ready to send next byte
 */
extern bool _usart_sync_is_ready_to_send(const struct _usart_sync_device *device);

/**
 * \brief Check if USART transmitter has sent the byte
 *
 * \param[in] device The pointer to USART device instance
 *
 * \return Status of the ready check.  \retval true if the USART transmitter has sent the byte  \retval false if the USART transmitter has not send the byte
 */
extern bool _usart_sync_is_transmit_done(const struct _usart_sync_device *device);

/**
 * \brief Check if there is data received by USART
 *
 * \param[in] device The pointer to USART device instance
 *
 * \return Status of the data received check.  \retval true if the USART has received a byte  \retval false if the USART has not received a byte
 */
extern bool _usart_sync_is_byte_received(const struct _usart_sync_device *device);

/**
 * \brief Set the state of flow control pins
 *
 * \param[in] device The pointer to USART device instance  \param[in] state - A state of flow control pins to set
 */
extern void _usart_sync_set_flow_control_state(struct _usart_sync_device *device,
                                               union usart_flow_control_state state);

/**
 * \brief Retrieve the state of flow control pins
 *
 * This function retrieves the of flow control pins.
 *
 * \return USART_FLOW_CONTROL_STATE_UNAVAILABLE.
 */
extern union usart_flow_control_state _usart_sync_get_flow_control_state(const struct _usart_sync_device *device);

/**
 * \brief Retrieve ordinal number of the given USART hardware instance
 *
 * \param[in] device The pointer to USART device instance
 *
 * \return The ordinal number of the given USART hardware instance
 */
extern uint8_t _usart_sync_get_hardware_index(const struct _usart_sync_device *device);

/**
 * \brief Initialize USART interface
 *
 * This function initializes the given I/O descriptor to be used  as USART interface descriptor.  It checks if the given hardware is not initialized and  if the given hardware is permitted to be initialized.
 *
 * \param[out] descr A USART descriptor which is used to communicate via USART  \param[in] hw The pointer to hardware instance  \param[in] func The pointer to as set of functions pointers
 *
 * \return Initialization status.
 */
extern int32_t usart_sync_init(struct usart_sync_descriptor *descr,
                               void *hw,
                               void *func);

/**
 * \brief Deinitialize USART interface
 *
 * This function deinitializes the given I/O descriptor.  It checks if the given hardware is initialized and  if the given hardware is permitted to be deinitialized.
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART
 *
 * \return De-initialization status.
 */
extern int32_t usart_sync_deinit(struct usart_sync_descriptor *descr);

/**
 * \brief Enable USART interface
 *
 * Enables the USART interface
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART
 *
 * \return Enabling status.
 */
extern int32_t usart_sync_enable(struct usart_sync_descriptor *descr);

/**
 * \brief Disable USART interface
 *
 * Disables the USART interface
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART
 *
 * \return Disabling status.
 */
extern int32_t usart_sync_disable(struct usart_sync_descriptor *descr);

/**
 * \brief Retrieve I/O descriptor
 *
 * This function retrieves the I/O descriptor of the given USART descriptor.
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART  \param[out] io An I/O descriptor to retrieve
 *
 * \return The status of the I/O descriptor retrieving.
 */
extern int32_t usart_sync_get_io_descriptor(struct usart_sync_descriptor *descr,
                                            struct io_descriptor **io);

/**
 * \brief Specify action for flow control pins
 *
 * This function sets the action (or state) for the flow control pins  if the flow control is enabled.  It sets the state of flow control pins only if the automatic support of  the flow control is not supported by the hardware.
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART  \param[in] state A state to set the flow control pins
 *
 * \return The status of flow control action setup.
 */
extern int32_t usart_sync_set_flow_control(struct usart_sync_descriptor *descr,
                                           union usart_flow_control_state state);

/**
 * \brief Set USART baud rate
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART  \param[in] baud_rate A baud rate to set
 *
 * \return The status of baud rate setting.
 */
extern int32_t usart_sync_set_baud_rate(struct usart_sync_descriptor *descr,
                                        uint32_t baud_rate);

/**
 * \brief Set USART data order
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART  \param[in] data_order A data order to set
 *
 * \return The status of data order setting.
 */
extern int32_t usart_sync_set_data_order(struct usart_sync_descriptor *descr,
                                         usart_data_order data_order);

/**
 * \brief Set USART mode
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART  \param[in] mode A mode to set
 *
 * \return The status of mode setting.
 */
extern int32_t usart_sync_set_mode(struct usart_sync_descriptor *descr,
                                   usart_mode mode);

/**
 * \brief Set USART parity
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART  \param[in] parity A parity to set
 *
 * \return The status of parity setting.
 */
extern int32_t usart_sync_set_parity(struct usart_sync_descriptor *descr,
                                     usart_parity parity);

/**
 * \brief Set USART stop bits
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART  \param[in] stop_bits Stop bits to set
 *
 * \return The status of stop bits setting.
 */
extern int32_t usart_sync_set_stopbits(struct usart_sync_descriptor *descr,
                                       usart_stop_bits stop_bits);

/**
 * \brief Set USART character size
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART  \param[in] size A character size to set
 *
 * \return The status of character size setting.
 */
extern int32_t usart_sync_set_character_size(struct usart_sync_descriptor *descr,
                                             usart_character_size size);

/**
 * \brief Retrieve the state of flow control pins
 *
 * This function retrieves the of flow control pins  if the flow control is enabled.  Function can return USART_FLOW_CONTROL_STATE_UNAVAILABLE in case  if the flow control is done by the hardware  and the pins state cannot be read out.
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART  \param[out] state The state of flow control pins
 *
 * \return The status of flow control state reading.
 */
extern int32_t usart_sync_flow_control_status(const struct usart_sync_descriptor *descr,
                                              union usart_flow_control_state *state);

/**
 * \brief Check if the USART transmitter is empty
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART
 *
 * \return The status of USART TX empty checking.  \retval 0 The USART transmitter is not empty  \retval 1 The USART transmitter is empty
 */
extern int32_t usart_sync_is_tx_empty(const struct usart_sync_descriptor *descr);

/**
 * \brief Check if the USART receiver is not empty
 *
 * \param[in] descr A USART descriptor which is used to communicate via USART
 *
 * \return The status of USART RX empty checking.  \retval 1 The USART receiver is not empty  \retval 0 The USART receiver is empty
 */
extern int32_t usart_sync_is_rx_not_empty(const struct usart_sync_descriptor *descr);

/**
 * \brief Retrieve the current driver version
 *
 * \return Current driver version.
 */
extern uint32_t usart_sync_get_version(void);

/**
 * \brief              Initialize SLCD Device Descriptor
 *
 * \param[in] desc     SLCD descriptor to be initialized  \param[in] hw       The pointer to hardware instance
 */
extern int32_t _slcd_sync_init(struct _slcd_sync_device *dev,
                               void *hw);

/**
 * \brief              Deinitialize SLCD Device Descriptor
 *
 * \param[in] desc     SLCD device descriptor to be deinitialized
 */
extern int32_t _slcd_sync_deinit(struct _slcd_sync_device *dev);

/**
 * \brief              Enable SLCD driver
 *
 * \param[in] dev      SLCD device descriptor to be enabled
 */
extern int32_t _slcd_sync_enable(struct _slcd_sync_device *dev);

/**
 * \brief              Disable SLCD driver
 *
 * \param[in] dev      SLCD Device descriptor to be disabled
 */
extern int32_t _slcd_sync_disable(struct _slcd_sync_device *dev);

/**
 * \brief               Turn on a Segment
 *
 * \param[in] dev       SLCD Device descriptor  \param[in] seg       Segment id                       value is (common terminals << 16 | segment terminal)
 */
extern int32_t _slcd_sync_seg_on(struct _slcd_sync_device *dev,
                                 uint32_t seg);

/**
 * \brief               Turn off a Segment
 *
 * \param[in] dev       SLCD Device descriptor  \param[in] seg       Segment id                       value is (common terminals << 16 | segment terminal)
 */
extern int32_t _slcd_sync_seg_off(struct _slcd_sync_device *dev,
                                  uint32_t seg);

/**
 * \brief               Blink a Segment
 *
 * \param[in] dev       SLCD Device descriptor  \param[in] seg       Segment index                       value is (common terminals << 16 | segment terminal)  \param[in] period  Blink period, unit is million second
 */
extern int32_t _slcd_sync_seg_blink(struct _slcd_sync_device *dev,
                                    uint32_t seg,
                                    uint32_t period);

/**
 * \brief              Displays a character
 *
 * \param[in] dev       SLCD Device descriptor  \param[in] character Character to be displayed  \param[in] index     Index of Character Mapping Group
 */
extern int32_t _slcd_sync_write_char(struct _slcd_sync_device *dev,
                                     uint8_t character,
                                     uint32_t index);

/**
 * \brief               Start animation play by a segment array
 *
 * \param[in] dev       SLCD Device descriptor  \param[in] segs      Segment array  \param[in] len       Length of the segment array  \param[in] period    Period(milliseconds) of the each segment to animation
 */
extern int32_t _slcd_sync_start_animation(struct _slcd_sync_device *dev,
                                          const uint32_t *segs,
                                          uint32_t len,
                                          uint32_t period);

/**
 * \brief               Stop animation play by a segment array
 *
 * \param[in] dev       SLCD device descriptor  \param[in] segs      Segment array  \param[in] len       Length of the segment array
 */
extern int32_t _slcd_sync_stop_animation(struct _slcd_sync_device *dev,
                                         const uint32_t *segs,
                                         uint32_t len);

/**
 * \brief               Set animation Frequency
 *
 * \param[in] dev       SLCD Device descriptor  \param[in] period    Period(million second) of the each segment to animation
 */
extern int32_t _slcd_sync_set_animation_period(struct _slcd_sync_device *dev,
                                               uint32_t period);

/**
 * \brief               Initialize SLCD Descriptor
 *
 * \param[in] descr     SLCD descriptor to be initialized  \param[in] hw        The pointer to hardware instance
 */
extern int32_t slcd_sync_init(struct slcd_sync_descriptor *descr,
                              void *hw);

/**
 * \brief               Deinitialize SLCD Descriptor
 *
 * \param[in] descr      SLCD descriptor to be deinitialized
 */
extern int32_t slcd_sync_deinit(struct slcd_sync_descriptor *descr);

/**
 * \brief               Enable SLCD driver
 *
 * \param[in] descr     SLCD descriptor to be initialized
 */
extern int32_t slcd_sync_enable(struct slcd_sync_descriptor *descr);

/**
 * \brief               Disable SLCD driver
 *
 * \param[in] descr     SLCD descriptor to be disabled
 */
extern int32_t slcd_sync_disable(struct slcd_sync_descriptor *descr);

/**
 * \brief               Turn on a Segment
 *
 * \param[in] descr     SLCD descriptor to be enabled  \param[in] seg       Segment index. The segment index is by the combination                       of common and segment terminal index. The                       SLCD_SEGID(com, seg) macro can generate the index.
 */
extern int32_t slcd_sync_seg_on(struct slcd_sync_descriptor *descr,
                                uint32_t seg);

/**
 * \brief               Turn off a Segment
 *
 * \param[in] descr     SLCD descriptor  \param[in] seg       Segment index                       value is "(common terminals << 16 | segment terminal)"
 */
extern int32_t slcd_sync_seg_off(struct slcd_sync_descriptor *descr,
                                 uint32_t seg);

/**
 * \brief               Blink a Segment
 *
 * \param[in] descr     SLCD descriptor  \param[in] seg       Segment index                       value is "(common terminals << 16 | segment terminal)"  \param[in] period    Blink period, unit is millisecond
 */
extern int32_t slcd_sync_seg_blink(struct slcd_sync_descriptor *descr,
                                   uint32_t seg,
                                   uint32_t period);

/**
 * \brief               Displays a character
 *
 * \param[in] descr     SLCD descriptor  \param[in] character Character to be displayed  \param[in] index     Index of the character Mapping Group
 */
extern int32_t slcd_sync_write_char(struct slcd_sync_descriptor *descr,
                                    uint8_t character,
                                    uint32_t index);

/**
 * \brief               Displays character string string
 *
 * \param[in] descr     SLCD descriptor  \param[in] str       String to be displayed, 0 will turn off the                       corresponding char to display  \param[in] len       Length of the string array  \param[in] index     Index of the character Mapping Group
 */
extern int32_t slcd_sync_write_string(struct slcd_sync_descriptor *descr,
                                      uint8_t *str_,
                                      uint32_t len,
                                      uint32_t index);

/**
 * \brief               Start animation play by a segment array
 *
 * \param[in] descr     SLCD descriptor  \param[in] segs      Segment array  \param[in] len       Length of the segment array  \param[in] period    Period (milliseconds) of each segment to animation
 */
extern int32_t slcd_sync_start_animation(struct slcd_sync_descriptor *descr,
                                         const uint32_t *segs,
                                         uint32_t len,
                                         uint32_t period);

/**
 * \brief               Stop animation play by a segment array
 *
 * \param[in] descr     SLCD descriptor  \param[in] segs      Segment array  \param[in] len       Length of the segment array
 */
extern int32_t slcd_sync_stop_animation(struct slcd_sync_descriptor *descr,
                                        const uint32_t *segs,
                                        uint32_t len);

/**
 * \brief               Set animation Frequency
 *
 * \param[in] descr     SLCD descriptor  \param[in] period    Period (million second) of each segment to animation
 */
extern int32_t slcd_sync_set_animation_period(struct slcd_sync_descriptor *descr,
                                              uint32_t period);

extern void I2C_0_CLOCK_init(void);

extern void I2C_0_init(void);

extern void I2C_0_PORT_init(void);

extern void SPI_0_PORT_init(void);

extern void SPI_0_CLOCK_init(void);

extern void SPI_0_init(void);

extern void delay_driver_init(void);

extern void EXTERNAL_IRQ_0_init(void);

extern void SEGMENT_LCD_0_PORT_init(void);

extern void SEGMENT_LCD_0_init(void);

/**
 * @addtogroup app Application Framework  @brief This section covers the functions that you will implement in your app.c file when designing a Sensor Watch app.  @details You should be able to write a watch app by simply implementing these functions and declaring callbacks for           various GPIO and peripheral interrupts. The main.c file takes care of calling these functions for you. The           general flow:
 *
 *            1. Your app_init() function is called.                - This method should only be used to set your initial application state.             2. If your app is waking from BACKUP, app_wake_from_backup() is called.                - If you saved state in the RTC's backup registers, you can restore it here.             3. Your app_setup() method is called.                - You may wish to enable some functionality and peripherals here.                - You should definitely set up some interrupts here.             4. The main run loop begins: your app_loop() function is called.                - Run code and update your UI here.                - Return true if your app is prepared to enter STANDBY mode.             5. This step differs depending on the value returned by app_loop:                - If you returned false, execution resumes at (4).                - If you returned true, app_prepare_for_standby() is called; execution moves on to (6).             6. The microcontroller enters STANDBY mode.                - No user code will run, and the watch will enter a low power mode.                - The watch will remain in this state until an interrupt wakes it.             7. Once woken from STANDBY, your app_wake_from_standby() function is called.                - After this, execution resumes at (4). / /// @{ /** @brief A function you will implement to initialize your application state. The app_init function is called before         anything else. Use it to set up any internal data structures or application state required by your app,         but don't configure any peripherals just yet.
 */
extern void app_init(void);

/**
 * @brief A function you will implement to wake from BACKUP mode, which wipes the system's RAM, and with it, your         application's state. You may have chosen to store some important application state in the RTC's backup         registers prior to entering this mode. You may restore that state here.
 */
extern void app_wake_from_backup(void);

/**
 * @brief A function you will implement to set up your application. The app_setup function is like setup() in Arduino.         It is called once when the program begins. You should set pin modes and enable any peripherals you want to         set up (real-time clock, I2C, etc.) Depending on your application, you may or may not want to configure         sensors on your sensor board here. For example, a low-power accelerometer that will run at all times should         be configured here, whereas you may want to enable a more power-hungry sensor only when you need it.  @note If your app enters the ultra-low power BACKUP sleep mode, this function will be called again when it wakes        from that deep sleep state. In this state, the RTC will still be configured with the correct date and time.
 */
extern void app_setup(void);

/**
 * @brief A function you will implement to serve as the app's main run loop. This method will be called repeatedly, or if you enter STANDBY mode, as soon as the device wakes from sleep.  @return You should return true if your app is prepared to enter STANDBY mode. If you return false, your app's          app_loop method will be called again immediately. Note that in STANDBY mode, the watch will consume only          about 95 microamperes of power, whereas if you return false and keep the app awake, it will consume about          355 microamperes. This is the difference between months of battery life and days. As much as possible,          you should limit the amount of time your app spends awake.  @note Only the RTC, the segment LCD controller and the external interrupt controller run in STANDBY mode. If you        are using, e.g. the PWM function to set a custom LED color, you should return false here until you are        finished with that operation. Note however that the peripherals will continue running after waking up,        so e.g. the I2C controller, if configured, will sleep in STANDBY. But you can use it again as soon as your        app wakes up.
 */
extern bool app_loop(void);

/**
 * @brief A function you will implement to prepare to enter STANDBY mode. The app_prepare_for_standby function is          called after your app_loop function returns true, and just before the watch enters STANDBY mode. In this          mode most peripherals are shut down, and no code will run until the watch receives an interrupt (generally          either the 1Hz tick or a press on one of the buttons).  @note If you are PWM'ing the LED or playing a sound on the buzzer, the TC/TCC peripherals that drive those operations        will not run in STANDBY. BUT! the output pins will retain the state they had when entering standby. This means        you could end up entering standby with an LED on and draining power, or with a DC potential across the piezo        buzzer that could damage it if left in this state. If your app_loop does not prevent sleep during these        activities, you should make sure to disable these outputs in app_prepare_for_standby.
 */
extern void app_prepare_for_standby(void);

/**
 * @brief A method you will implement to configure the app after waking from STANDBY mode.
 */
extern void app_wake_from_standby(void);

/**
 * @brief Called by main.c to check if the RTC is enabled.  You may call this function, but outside of app_init, it should always return true.
 */
extern bool _watch_rtc_is_enabled(void);

/**
 * @brief Sets the date and time.  @param date_time The date and time you wish to set, with a year value from 0-63 representing 2020-2083.  @note The SAM L22 stores the year as six bits representing a value from 0 to 63. It treats this as a year        offset from a reference year, which must be a leap year. Since 2020 was a leap year, and it allows        useful dates through 2083, it is assumed that watch apps will use 2020 as the reference year; thus        1 means 2021, 2 means 2022, etc. **You will be responsible for handling this offset in your code**,        if the calendar year is needed for timestamp calculation logic or display purposes.
 */
extern void watch_rtc_set_date_time(union watch_date_time date_time);

/**
 * @brief Returns the date and time.  @return A watch_date_time with the current date and time, with a year value from 0-63 representing 2020-2083.  @see watch_rtc_set_date_time for notes about how the year is stored.
 */
extern union watch_date_time watch_rtc_get_date_time(void);

/**
 * @brief Registers an alarm callback that will be called when the RTC time matches the target time, as masked         by the provided mask.  @param callback The function you wish to have called when the alarm fires. If this value is NULL, the alarm                  interrupt will still be enabled, but no callback function will be called.  @param alarm_time The time that you wish to match. The date is currently ignored.  @param mask One of the values in watch_rtc_alarm_match indicating which values to check.  @details The alarm interrupt is a versatile tool for scheduling events in the future, especially since it can           wake the device from all sleep modes. The key to its versatility is the mask parameter.           Suppose we set an alarm for midnight, 00:00:00.            * if mask is ALARM_MATCH_SS, the alarm will fire every minute when the clock ticks to seconds == 0.            * with ALARM_MATCH_MMSS, the alarm will once an hour, at the top of each hour.            * with ALARM_MATCH_HHMMSS, the alarm will fire at midnight every day.           In theory the SAM L22's alarm function can match on days, months and even years, but I have not had           success with this yet; as such, I am omitting these options for now.
 */
extern void watch_rtc_register_alarm_callback(ext_irq_cb_t callback,
                                              union watch_date_time alarm_time,
                                              watch_rtc_alarm_match mask);

/**
 * @brief Disables the alarm callback.
 */
extern void watch_rtc_disable_alarm_callback(void);

/**
 * @brief Registers a "tick" callback that will be called once per second.  @param callback The function you wish to have called when the clock ticks. If you pass in NULL, the tick                  interrupt will still be enabled, but no callback function will be called.  @note this is equivalent to calling watch_rtc_register_periodic_callback with a frequency of 1. It can be        disabled with either watch_rtc_disable_tick_callback() or watch_rtc_disable_periodic_callback(1),        and will also be disabled when watch_rtc_disable_all_periodic_callbacks is called.
 */
extern void watch_rtc_register_tick_callback(ext_irq_cb_t callback);

/**
 * @brief Disables the tick callback for the given period.
 */
extern void watch_rtc_disable_tick_callback(void);

/**
 * @brief Registers a callback that will be called at a configurable period.  @param callback The function you wish to have called at the specified period. If you pass in NULL, the periodic                  interrupt will still be enabled, but no callback function will be called.  @param frequency The frequency of the tick in Hz. **Must be a power of 2**, from 1 to 128 inclusive.  @note A 1 Hz tick (@see watch_rtc_register_tick_callback) is suitable for most applications, in that it gives you a        chance to update the display once a second  an ideal update rate for a watch! If however you are displaying        a value (such as an accelerometer output) that updates more frequently than once per second, you may want to        tick at 16 or 32 Hz to update the screen more quickly. Just remember that the more frequent the tick, the more        power your app will consume. Ideally you should enable the fast tick only when the user requires it (i.e. in        response to an input event), and move back to the slow tick after some time.
 *
 *       Also note that the RTC peripheral does not have sub-second resolution, so even if you set a 2 or 4 Hz interval,        the system will not have any way of telling you where you are within a given second; watch_rtc_get_date_time        will return the exact same timestamp until the second ticks over.
 */
extern void watch_rtc_register_periodic_callback(ext_irq_cb_t callback,
                                                 uint8_t frequency);

/**
 * @brief Disables the tick callback for the given period.  @param frequency The frequency of the tick you wish to disable, in Hz. **Must be a power of 2**, from 1 to 128.
 */
extern void watch_rtc_disable_periodic_callback(uint8_t frequency);

/**
 * @brief Disables tick callbacks for the given periods (as a bitmask).  @param mask The frequencies of tick callbacks you wish to disable, in Hz.  The 128 Hz callback is 0b1, the 64 Hz callback is 0b10, the 32 Hz callback is 0b100, etc.
 */
extern void watch_rtc_disable_matching_periodic_callbacks(uint8_t mask);

/**
 * @brief Disables all periodic callbacks, including the once-per-second tick callback.
 */
extern void watch_rtc_disable_all_periodic_callbacks(void);

/**
 * @brief Enable/disable RTC while in-flight. This is quite dangerous operation, so we repeat writing register twice.  Used when temporarily pausing RTC when adjusting subsecond, which are not accessible otherwise.
 */
extern void watch_rtc_enable(bool en);

/**
 * @brief Adjusts frequency correction in single register write. Not waiting for syncronisation to save power - if you won't write new  correction value in the same ~millisecond - will not cause issue.
 */
extern void watch_rtc_freqcorr_write(int16_t value,
                                     int16_t sign);

/**
 * @brief Enables the Segment LCD display.  Call this before attempting to set pixels or display strings.
 */
extern void watch_enable_display(void);

/**
 * @brief Sets a pixel. Use this to manually set a pixel with a given common and segment number.         See <a href="segmap.html">segmap.html</a>.  @param com the common pin, numbered from 0-2.  @param seg the segment pin, numbered from 0-23.
 */
extern void watch_set_pixel(uint8_t com,
                            uint8_t seg);

/**
 * @brief Clears a pixel. Use this to manually clear a pixel with a given common and segment number.         See <a href="segmap.html">segmap.html</a>.  @param com the common pin, numbered from 0-2.  @param seg the segment pin, numbered from 0-23.
 */
extern void watch_clear_pixel(uint8_t com,
                              uint8_t seg);

/**
 * @brief Clears all segments of the display, including incicators and the colon.
 */
extern void watch_clear_display(void);

/**
 * @brief Displays a string at the given position, starting from the top left. There are ten digits. A space in any position will clear that digit.  @param string A null-terminated string.  @param position The position where you wish to start displaying the string. The day of week digits                  are positions 0 and 1; the day of month digits are positions 2 and 3, and the main                  clock line occupies positions 4-9.  @note This method does not clear the display; if for example you display a two-character string at position 0, positions 2-9 will retain whatever state they were previously displaying.
 */
extern void watch_display_string(char *string,
                                 uint8_t position);

/**
 * @brief Turns the colon segment on.
 */
extern void watch_set_colon(void);

/**
 * @brief Turns the colon segment off.
 */
extern void watch_clear_colon(void);

/**
 * @brief Sets an indicator on the LCD. Use this to turn on one of the indicator segments.  @param indicator One of the indicator segments from the enum. @see WatchIndicatorSegment
 */
extern void watch_set_indicator(WatchIndicatorSegment indicator);

/**
 * @brief Clears an indicator on the LCD. Use this to turn off one of the indicator segments.  @param indicator One of the indicator segments from the enum. @see WatchIndicatorSegment
 */
extern void watch_clear_indicator(WatchIndicatorSegment indicator);

/**
 * @brief Clears all indicator segments.  @see WatchIndicatorSegment
 */
extern void watch_clear_all_indicators(void);

/**
 * @brief Blinks a single character in position 7. Does not affect other positions.  @details Six of the seven segments in position 7 (and only position 7) are capable of autonomous           blinking. This blinking does not require any CPU resources, and will continue even in           STANDBY and Sleep mode (but not Deep Sleep mode, since that mode turns off the LCD).  @param character The character you wish to blink.  @param duration The duration of the on/off cycle in milliseconds, from 50 to ~4250 ms.  @note Segment B of position 7 cannot blink autonomously, so not all characters will work well.        Supported characters for blinking:         * Punctuation: underscore, apostrophe, comma, hyphen, equals sign, tilde (top segment only)         * Numbers: 5, 6, ampersand (lowercase 7)         * Letters: b, C, c, E, F, h, i, L, l, n, o, S, t
 */
extern void watch_start_character_blink(char character,
                                        uint32_t duration);

/**
 * @brief Stops and clears all blinking segments.  @details This will stop all blinking in position 7, and clear all segments in that digit.
 */
extern void watch_stop_blink(void);

/**
 * @brief Begins a two-segment "tick-tock" animation in position 8.  @details Six of the seven segments in position 8 (and only position 8) are capable of autonomous           animation. This animation is very basic, and consists of moving a bit pattern forward           or backward in a shift register whose positions map to fixed segments on the LCD. Given           this constraint, an animation across all six segments does not make sense; so the watch           library offers only a simple "tick/tock" in segments D and E. This animation does not           require any CPU resources, and will continue even in STANDBY and Sleep mode (but not Deep           Sleep mode, since that mode turns off the LCD).  @param duration The duration of each frame in ms. 500 milliseconds produces a classic tick/tock.
 */
extern void watch_start_tick_animation(uint32_t duration);

/**
 * @brief Checks if the tick animation is currently running.  @return true if the animation is running; false otherwise.
 */
extern bool watch_tick_animation_is_running(void);

/**
 * @brief Stops the tick/tock animation and clears all animating segments.  @details This will stop the animation and clear all segments in position 8.
 */
extern void watch_stop_tick_animation(void);

/**
 * @brief Enables the external interrupt controller.
 */
extern void watch_enable_external_interrupts(void);

/**
 * @brief Disables the external interrupt controller.
 */
extern void watch_disable_external_interrupts(void);

/**
 * @brief Configures an external interrupt callback on one of the external interrupt pins.  @details You can set one interrupt callback per pin, and you can monitor for a rising condition,           a falling condition, or both. If you just want to detect a button press, register your           interrupt with INTERRUPT_TRIGGER_RISING; if you want to detect an active-low interrupt           signal from a device on the nine-pin connector, use INTERRUPT_TRIGGER_FALLING. If you           want to detect both rising and falling conditions (i.e. button down and button up), use           INTERRUPT_TRIGGER_BOTH and use watch_get_pin_level to check the pin level in your callback           to determine which condition caused the interrupt.  @param pin One of BTN_LIGHT, BTN_MODE, BTN_ALARM, A0, A1, A3 or A4. If the pin parameter matches one of             the three button pins, this function will also enable an internal pull-down resistor. If             the pin parameter is A0-A4, you are responsible for setting any required pull configuration             using watch_enable_pull_up or watch_enable_pull_down.  @param callback The function you wish to have called when the button is pressed.  @param trigger The condition on which you wish to trigger: rising, falling or both.  @note Pins A2 and A4 can also generate interrupts via the watch_register_extwake_callback function, which        will allow them to trigger even when the watch is in deep sleep mode.  @warning As of now, A2 is not usable via the watch_register_interrupt_callback function. To enable an           external interrupt on pin A2, use the watch_register_extwake_callback function. This issue will be           addressed in a future revision of the watch library.
 */
extern void watch_register_interrupt_callback(uint8_t pin,
                                              ext_irq_cb_t callback,
                                              watch_interrupt_trigger trigger);

/**
 * @addtogroup led LED Control  @brief This section covers functions related to the bi-color red/green LED mounted behind the LCD.  @details The SAM L22 is an exceedingly power efficient chip, whereas the LED's are relatively power-           hungry. The green LED, at full power, consumes more power than the whole chip in active mode,           and the red LED consumes about twelve times as much power! The LED's should thus be used only           sparingly in order to preserve battery life.  @note Some watches use a red/blue LED instead of a red/green LED. You will be able to determine this        easily when you double tap the reset button: if the pulsing bootloader LED is red, you have a        red/green edition; if it is blue, you have a red/blue edition. For red/blue watches, build your        project with the command `make LED=BLUE`, and the watch library will automatically swap the pins        so that watch_set_led_red sets the red LED, and watch_set_led_green sets the blue one. / /// @{ /** @brief Enables the bi-color LED.  @note The TCC peripheral that drives the LEDs does not run in STANDBY mode  but the outputs do! This        means that if you set either red, green or both LEDs to full power, they will shine even when        your app is asleep. If, however, you set a custom color using watch_set_led_color, the color will        not display correctly in STANDBY mode. You will need to keep your app running while the LED is on.
 */
extern void watch_enable_leds(void);

/**
 * @brief Disables the LEDs.  @note This method will also disable the buzzer, since the buzzer and LED both make use of the same        peripheral to drive their PWM behavior.
 */
extern void watch_disable_leds(void);

/**
 * @brief Sets the LED to a custom color by modulating each output's duty cycle.  @param red The red value from 0-255.  @param green The green value from 0-255. If your watch has a red/blue LED, this will be the blue value.  @note If you are displaying a custom color, you will need to prevent your app from going to sleep        while the LED is on; otherwise, the color will not display correctly. You can do this by        returning false in your app_loop method.
 */
extern void watch_set_led_color(uint8_t red,
                                uint8_t green);

/**
 * @brief Sets the red LED to full brightness, and turns the green LED off.  @details Of the two LED's in the RG bi-color LED, the red LED is the less power-efficient one (~4.5 mA).
 */
extern void watch_set_led_red(void);

/**
 * @brief Sets the green LED to full brightness, and turns the red LED off.  @details Of the two LED's in the RG bi-color LED, the green LED is the more power-efficient one (~0.44 mA).  @note If your watch has a red/blue LED, this method will set the LED to blue.
 */
extern void watch_set_led_green(void);

/**
 * @brief Sets both red and green LEDs to full brightness.  @details The total current draw between the two LED's in this mode will be ~5 mA, which is more than the           watch draws in any other mode. Take care not to drain the battery.  @note If your watch has a red/blue LED, this method will set the LED to pink.
 */
extern void watch_set_led_yellow(void);

/**
 * @brief Turns both the red and the green LEDs off.
 */
extern void watch_set_led_off(void);

/**
 * @addtogroup buzzer Buzzer  @brief This section covers functions related to the piezo buzzer embedded in the F-91W's back plate. / /// @{ /** @brief Enables the TCC peripheral, which drives the buzzer.
 */
extern void watch_enable_buzzer(void);

/**
 * @brief Sets the period of the buzzer.  @param period The period of a single cycle for the TCC peripheral. You can determine the period for                a desired frequency with the following formula: period = 1000000 / freq
 */
extern void watch_set_buzzer_period(uint32_t period);

/**
 * @brief Disables the TCC peripheral that drives the buzzer.  @note If you are using PWM to set custom LED colors, this method will also disable the LED PWM driver,        since the buzzer and LED both make use of the same peripheral to drive their PWM behavior.
 */
extern void watch_disable_buzzer(void);

/**
 * @brief Turns the buzzer output on. It will emit a continuous sound at the given frequency.  @note The TCC peripheral that drives the buzzer does not run in standby mode; if you wish for buzzer        output to continue, you should prevent your app from going to sleep.
 */
extern void watch_set_buzzer_on(void);

/**
 * @brief Turns the buzzer output off.
 */
extern void watch_set_buzzer_off(void);

/**
 * @brief Plays the given note for a set duration.  @param note The note you wish to play, or BUZZER_NOTE_REST to disable output for the given duration.  @param duration_ms The duration of the note.  @note Note that this will block your UI for the duration of the note's play time, and it will        after this call, the buzzer period will be set to the period of this note.
 */
extern void watch_buzzer_play_note(BuzzerNote note,
                                   uint16_t duration_ms);

/**
 * @brief Plays the given sequence of notes in a non-blocking way.  @param note_sequence A pointer to the sequence of buzzer note & duration tuples, ending with a zero. A simple         RLE logic is implemented: a negative number instead of a buzzer note means that the sequence         is rewound by the given number of notes. The byte following a negative number determines the number         of loops. I.e. if you want to repeat the last three notes of the sequence one time, you should provide         the tuple -3, 1. The repeated notes must not contain any other repeat markers, or you will end up with         an eternal loop.  @param callback_on_end A pointer to a callback function to be invoked when the sequence has finished playing.  @note This function plays the sequence asynchronously, so the UI will not be blocked.        Hint: It is not possible to play the lowest note BUZZER_NOTE_A1 (55.00 Hz). The note is represented by a        zero byte, which is used here as the end-of-sequence marker. But hey, a frequency that low cannot be        played properly by the watch's buzzer, anyway.
 */
extern void watch_buzzer_play_sequence(int8_t *note_sequence,
                                       void (*callback_on_end)(void));

/**
 * @brief Aborts a playing sequence.
 */
extern void watch_buzzer_abort_sequence(void);

/**
 * @addtogroup adc Analog Input  @brief This section covers functions related to the SAM L22's analog-to-digital converter,         as well as configuring and reading values from the five analog-capable pins on the         9-pin connector. / /// @{ /** @brief Enables the ADC peripheral. You must call this before attempting to read a value         from an analog pin.
 */
extern void watch_enable_adc(void);

/**
 * @brief Configures the selected pin for analog input.  @param pin One of pins A0-A4.
 */
extern void watch_enable_analog_input(uint8_t pin);

/**
 * @brief Reads an analog value from one of the pins.  @param pin One of pins A0-A4.  @return a 16-bit unsigned integer from 0-65535 representing the sampled value, unless you          have changed the number of samples. @see watch_set_num_analog_samples for details          on how that function changes the values returned from this one.
 */
extern uint16_t watch_get_analog_pin_level(uint8_t pin);

/**
 * @brief Sets the number of samples to accumulate when measuring a pin level. Default is 16.  @param samples A power of 2 <= 1024. Specifically: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512 or 1024. Any other value will be ignored.  @details The SAM L22's ADC has a resolution of 12 bits. By default, the watch configures           the ADC to take 16 samples of the analog input and accumulate them in the result           register; this effectively gives us a 16-bit resolution, at the cost of taking 16           ADC cycles to complete a measurement. If you are measuring a slowly changing signal           like a thermistor output or an ambient light sensor this is probably fine, even           desirable. If you are measuring something a bit more fast-paced, like an analog           accelerometer, you may wish to exchange precision for speed. In this case you may           call this function to configure the ADC to accumulate fewer samples. HOWEVER! Note           that this may change the range of values returned from watch_get_analog_pin_level:             - For watch_set_num_analog_samples(1), the returned value will be 12 bits (0-4095).             - For watch_set_num_analog_samples(2), the returned value will be 13 bits (0-8191).             - For watch_set_num_analog_samples(4), the returned value will be 14 bits (0-16383).             - For watch_set_num_analog_samples(8), the returned value will be 15 bits (0-32767).          For sampling values over 16, the returned value will still be 16 bits (0-65535); the          ADC will automatically divide the measured value by whatever factor is necessary to fit          the result in 16 bits.  @see watch_get_analog_pin_level
 */
extern void watch_set_analog_num_samples(uint16_t samples);

/**
 * @brief Sets the length of time spent sampling, which allows measurement of higher impedance inputs.         Default is 1.  @param cycles The number of ADC cycles to sample, between 1 and 64.  @see this article by Thea Flowers: https://blog.thea.codes/getting-the-most-out-of-the-samd21-adc/       which is where I learned all of this.  @details To measure an analog value, the SAM L22 must charge a capacitor to the analog voltage           presented at the input. This takes time. Importantly, the higher the input impedance,           the more time this takes. As a basic example: if you are using a thermistor tied to           VCC to measure temperature, the capacitor has to charge through the thermistor. The           higher the resistor value, the higher the input impedance, and the more time we need           to allow for the measurement. By default, the ADC is configured to run on a 500 kHz           clock with a sample time of one cycle. This is appropriate for an input impedance up           to about 28k. Setting the sampling time to 4 cycles allows for an input impedance up           to 123k. Setting the sampling time to the maximum of 64 cycles theoretically allows           for input impedance up to 2 M. (I based these numbers on the calculator in the linked           blog post; it also has a ton of great info on the SAM D21 ADC, which is similar to the           SAM L22's).
 */
extern void watch_set_analog_sampling_length(uint8_t cycles);

/**
 * @brief Selects the reference voltage to use for analog readings. Default is ADC_REFERENCE_VCC.  @param reference One of ADC_REFERENCE_VCC, ADC_REFERENCE_VCC_DIV1POINT6, ADC_REFERENCE_VCC_DIV2                   or ADC_REFERENCE_INTREF.  @details In order to turn an analog voltage into a 16-bit integer, the ADC needs to compare the           measured voltage to a reference point. For example, if you were powering the watch with           VCC == 3.0V and you had two 10K resistors connected in series from 3V to GND, you could           expect to get 3 volts when you measure the top of the voltage divider, 0 volts at the           bottom, and 1.5 volts in the middle. If you read these values uising a reference voltage           of ADC_REFERENCE_VCC, the top value would be about 65535, the bottom about 0, and the           middle about 32768. However! If we used ADC_REFERENCE_VCC_DIV2 as our reference, we would           expect to get 65535 both at the top and the middle, because the largest value the ADC can           measure in this configutation is 1.5V (VCC / 2).
 *
 *          By changing the reference voltage from ADC_REFERENCE_VCC to ADC_REFERENCE_VCC_DIV1POINT6           or ADC_REFERENCE_VCC_DIV2, you can get more resolution when measuring small voltages (i.e.           a phototransistor circuit in low light).
 *
 *          There is also a special reference voltage called ADC_REFERENCE_INTREF. The SAM L22's           Supply Controller provides a selectable voltage reference (by default, 1.024 V) that you           can select as a reference voltage for ADC conversions. Unlike the three references we           talked about in the last paragraph, this reference voltage does not depend on VCC, which           makes it very useful for measuring the battery voltage (since you can't really compare           VCC to itself). You can change the INTREF voltage to 2.048 or 4.096 V by poking at the           supply controller's VREF register, but the watch library does not support this use case.
 */
extern void watch_set_analog_reference_voltage(watch_adc_reference_voltage reference);

/**
 * @brief Returns the voltage of the VCC supply in millivolts (i.e. 3000 mV == 3.0 V). If running on         a coin cell, this will be the battery voltage.  @details Unlike other ADC functions, this function does not return a raw value from the ADC, but           rather scales it to an actual number of millivolts. This is because the ADC doesn't let           us measure VCC per se; it instead lets us measure VCC / 4, and we choose to measure it           against the internal reference voltage of 1.024 V. In short, the ADC gives us a number           that's complicated to deal with, so we just turn it into a useful number for you :)  @note This function depends on INTREF being 1.024V. If you have changed it by poking at the supply        controller's VREF.SEL bits, this function will return inaccurate values.
 */
extern uint16_t watch_get_vcc_voltage(void);

/**
 * @brief Disables the analog circuitry on the selected pin.  @param pin One of pins A0-A4.
 */
extern void watch_disable_analog_input(uint8_t pin);

/**
 * @brief Disables the ADC peripheral.  @note You will need to call watch_enable_adc to re-enable the ADC peripheral. When you do, it will        have the default settings of 16 samples and 1 measurement cycle; if you customized these        parameters, you will need to set them up again.
 */
extern void watch_disable_adc(void);

/**
 * @addtogroup gpio Digital Input and Output  @brief This section covers functions related to general-purpose input and output signals. / /// @{ /** @brief Configures the selected pin for digital input.  @param pin The pin that you wish to act as an input.
 */
extern void watch_enable_digital_input(uint8_t pin);

/**
 * @brief Disables any digital input, along with any pull-up or pull-down configuration.  @param pin The pin that you wish to disable.
 */
extern void watch_disable_digital_input(uint8_t pin);

/**
 * @brief Enables a pull-up resistor on the selected pin.  @param pin The pin that you wish to configure.
 */
extern void watch_enable_pull_up(uint8_t pin);

/**
 * @brief Enables a pull-down resistor on the selected pin.  @param pin The pin that you wish to configure.
 */
extern void watch_enable_pull_down(uint8_t pin);

/**
 * @brief Gets the level of the selected pin.  @param pin The pin whose value you wish to read.  @return true if the pin was logic high; otherwise, false.
 */
extern bool watch_get_pin_level(uint8_t pin);

/**
 * @brief Configures the selected pin for digital output.  @param pin The pin that you wish to act as an output.
 */
extern void watch_enable_digital_output(uint8_t pin);

/**
 * @brief Disables digital output on the selected pin.  @param pin The pin that you wish disable.
 */
extern void watch_disable_digital_output(uint8_t pin);

/**
 * @brief Sets the level of the selected pin.  @param pin The pin whose value you wish to set.  @param level The level you wish to set: true for high, false for low.
 */
extern void watch_set_pin_level(uint8_t pin,
                                bool level);

/**
 * @addtogroup i2c I2C Controller Driver  @brief This section covers functions related to the SAM L22's built-I2C driver, including         configuring the I2C bus, putting values directly on the bus and reading data from         registers on I2C devices. / /// @{ /** @brief Enables the I2C peripheral. Call this before attempting to interface with I2C devices.
 */
extern void watch_enable_i2c(void);

/**
 * @brief Disables the I2C peripheral.
 */
extern void watch_disable_i2c(void);

/**
 * @brief Sends a series of values to a device on the I2C bus.  @param addr The address of the device you wish to talk to.  @param buf A series of unsigned bytes; the data you wish to transmit.  @param length The number of bytes in buf that you wish to send.
 */
extern void watch_i2c_send(int16_t addr,
                           uint8_t *buf,
                           uint16_t length);

/**
 * @brief Receives a series of values from a device on the I2C bus.  @param addr The address of the device you wish to hear from.  @param buf Storage for the incoming bytes; on return, it will contain the received data.  @param length The number of bytes that you wish to receive.
 */
extern void watch_i2c_receive(int16_t addr,
                              uint8_t *buf,
                              uint16_t length);

/**
 * @brief Writes a byte to a register in an I2C device.  @param addr The address of the device you wish to address.  @param reg The register on the device that you wish to set.  @param data The value that you wish to set the register to.
 */
extern void watch_i2c_write8(int16_t addr,
                             uint8_t reg,
                             uint8_t data);

/**
 * @brief Reads a byte from a register in an I2C device.  @param addr The address of the device you wish to address.  @param reg The register on the device that you wish to read.  @return An unsigned byte representing the value of the register that was read.
 */
extern uint8_t watch_i2c_read8(int16_t addr,
                               uint8_t reg);

/**
 * @brief Reads an unsigned little-endian word from a register in an I2C device.  @param addr The address of the device you wish to address.  @param reg The register on the device that you wish to read.  @return An unsigned word representing the value of the register that was read.  @note This reads two bytes into the word in bus order. If the device returns the LSB first and then the MSB, you can use this value as returned. If the device returns the data in big-endian order or uses some other kind of fancy bit packing, you may need to shuffle some bits around.
 */
extern uint16_t watch_i2c_read16(int16_t addr,
                                 uint8_t reg);

/**
 * @brief Reads three bytes as an unsigned little-endian int from a register in an I2C device.  @param addr The address of the device you wish to address.  @param reg The register on the device that you wish to read.  @return An unsigned word representing the value of the register that was read.  @note This reads three bytes into the word in bus order. If the device returns these bytes LSB first, you can use this value as returned. If there is a sign bit, the device returns the data in big-endian order, or it uses some other kind of fancy bit packing, you may need to shuffle some bits around.
 */
extern uint32_t watch_i2c_read24(int16_t addr,
                                 uint8_t reg);

/**
 * @brief Reads an unsigned little-endian int from a register in an I2C device.  @param addr The address of the device you wish to address.  @param reg The register on the device that you wish to read.  @return An unsigned word representing the value of the register that was read.  @note This reads three bytes into the word in bus order. If the device returns these bytes LSB first, you can use this value as returned. If the device returns the data in big-endian order, or it uses some other kind of fancy bit packing, you may need to shuffle some bits around.
 */
extern uint32_t watch_i2c_read32(int16_t addr,
                                 uint8_t reg);

/**
 * @addtogroup spi SPI Controller Driver  @brief This section covers functions related to the SAM L22's built-in SPI driver, including         configuring the SPI bus and writing to / reading from devices. / /// @{ /** @brief Enables the SPI peripheral. Call this before attempting to interface with SPI devices.
 */
extern void watch_enable_spi(void);

/**
 * @brief Disables the SPI peripheral.
 */
extern void watch_disable_spi(void);

/**
 * @brief Writes a series of values to a device on the SPI bus.  @param buf A series of unsigned bytes; the data you wish to transmit.  @param length The number of bytes in buf that you wish to send.  @note This function does not manage the chip select pin (usually A3).
 */
extern bool watch_spi_write(const uint8_t *buf,
                            uint16_t length);

/**
 * @brief Reads a series of values from a device on the SPI bus.  @param buf Storage for the incoming bytes; on return, it will contain the received data.  @param length The number of bytes that you wish to receive.  @note This function does not manage the chip select pin (usually A3).
 */
extern bool watch_spi_read(uint8_t *buf,
                           uint16_t length);

/**
 * @brief Reads a series of values from a device on the SPI bus.  @param data_out Storage for outgoing bytes.  @param data_in Storage for incoming bytes.  @param length The number of bytes to transfer.  @note This function does not manage the chip select pin (usually A3).
 */
extern bool watch_spi_transfer(const uint8_t *data_out,
                               uint8_t *data_in,
                               uint16_t length);

/**
 * @brief Initializes the debug UART.  @param tx_pin The pin the watch will use to transmit, or 0 for a receive-only UART.                If specified, must be either A2 or A4.  @param rx_pin The pin the watch will use to receive, or 0 for a transmit-only UART.                If specified, must be A1, A2, A3 or A4 (pin A0 cannot receive UART data).  @param baud The baud rate for the UART. A typical value is 19200.
 */
extern void watch_enable_uart(uint8_t tx_pin,
                              uint8_t rx_pin,
                              uint32_t baud);

/**
 * @brief Transmits a string of bytes on the UART's TX pin.  @param s A null-terminated string containing the bytes you wish to transmit.
 */
extern void watch_uart_puts(char *s);

/**
 * @brief Receives a single byte from the UART's RX pin.  @return the received byte.  @note This method will block until a byte is received!
 */
extern char watch_uart_getc(void);

/**
 * @addtogroup storage Flash Storage  @brief This section covers functions related to the SAM L22's 8 kilobyte EEPROM emulation area.  @details The SAM L22 inside Sensor Watch has a 256 kilobyte Flash memory array that can be           programmed with whatever data we want. We use most of it to store the bootloader           and the application code that runs on your wrist. The bootloader region is read-only,           and the main application area is only writable by the bootloader (when you drag new           code onto the WATCHBOOT drive). However! there's also a special 8 kilobyte region           at the end of the Flash memory called the EEPROM Emulation Area. This EEPROM emulation           area can be written or erased while the main Flash array is being read. This makes it           super easy to work with, and useful for storing a small amount of non-volatile data that           persists across reboots, even when power is lost.           The functions in this section are very basic, and only cover reading and writing data           in this area. The region is laid out as 32 rows consisting of 4 pages of 64 bytes.           32*4*64 = 8192 bytes. The area can be written one page at a time, but it can only be           erased one row at a time. You can read at arbitrary word-aligned offsets within a row.
 *
 *                            Row 0     64 bytes      64 bytes      64 bytes      64 bytes                                Row 1     64 bytes      64 bytes      64 bytes      64 bytes                                 ...                                                                                        Row 31    64 bytes      64 bytes      64 bytes      64 bytes                      / /// @{ /** @brief Reads a range of bytes from the storage area.  @param row The row you want to read.  @param offset The offset from the beginning of the row.  @param buffer A buffer of at least `size` bytes.  @param size The number of bytes you wish to read.
 */
extern bool watch_storage_read(uint32_t row,
                               uint32_t offset,
                               uint8_t *buffer,
                               uint32_t size);

/**
 * @brief Writes bytes to a page in the storage area. Note that the row should already be erased before writing.  @param row The row containing the page you want to write.  @param offset The offset from the beginning of the row. Must be a multiple of 64.  @param buffer The buffer containing the bytes you wish to set.  @param size The number of bytes you wish to write.
 */
extern bool watch_storage_write(uint32_t row,
                                uint32_t offset,
                                const uint8_t *buffer,
                                uint32_t size);

/**
 * @brief Erases a row in the storage area, setting all its bytes to 0xFF.  @param row The row you want to erase.
 */
extern bool watch_storage_erase(uint32_t row);

/**
 * @brief Waits for any pending writes to complete.
 */
extern bool watch_storage_sync(void);

/**
 * @brief Registers a callback on one of the RTC's external wake pins, which can wake the device         from Sleep, Deep Sleep and BACKUP modes (but see warning re: BACKUP mode).  @param pin Either pin BTN_ALARM, A2, or A4. These are the three external wake pins. If the pin             is BTN_ALARM, this function also enables an internal pull down on that pin.  @param callback The callback to be called if this pin triggers outside of BACKUP mode. If this is                  NULL, no callback will be called even in normal modes, but the interrupt will                  still be enabled so that it can wake the device.  @param level The level you wish to scan for: true for rising, false for falling. Note that you               cannot scan for both rising and falling edges like you can with the external interrupt               pins; with the external wake interrupt, you can only get one or the other.  @note When in ACTIVE, STANDBY and Sleep / Deep sleep modes, this will function much like a standard        external interrupt situation: these pins will wake the device, and your callback will be        called. However, if the device enters BACKUP mode and one of these pins wakes the device, your        callback WILL NOT be called, as the device is basically waking from reset at that point.  @warning As of the current SAM L22 silicon revision (rev B), the BTN_ALARM pin cannot wake the           device from BACKUP mode. You can still use this function to register a BTN_ALARM interrupt           in normal or deep sleep mode, but to wake from BACKUP, you will need to use pin A2 or A4.
 */
extern void watch_register_extwake_callback(uint8_t pin,
                                            ext_irq_cb_t callback,
                                            bool level);

/**
 * @brief Unregisters the RTC interrupt on one of the EXTWAKE pins. This will prevent a value change on         one of these pins from waking the device.  @param pin Either pin BTN_ALARM, A2, or A4. If the pin is BTN_ALARM, this function DOES NOT disable             the internal pull down on that pin.
 */
extern void watch_disable_extwake_interrupt(uint8_t pin);

/**
 * @brief Stores data in one of the RTC's backup registers, which retain their data in BACKUP mode.  @param data An unsigned 32 bit integer with the data you wish to store.  @param reg A register from 0-7.
 */
extern void watch_store_backup_data(uint32_t data,
                                    uint8_t reg);

/**
 * @brief Gets 32 bits of data from the RTC's BACKUP register.  @param reg A register from 0-7.  @return An unsigned 32 bit integer with the from the backup register.
 */
extern uint32_t watch_get_backup_data(uint8_t reg);

/**
 * @brief enters Sleep Mode by disabling all pins and peripherals except the RTC and the LCD.  @details This sleep mode is not the lowest power mode available, but it has the benefit of allowing you           to display a message to the user while asleep. You can also set an alarm interrupt to wake at a           configfurable interval (every minute, hour or day) to update the display. You can wake from this           mode by pressing the ALARM button, if you registered an extwake callback on the ALARM button.           Also note that when your app wakes from this sleep mode, your app_setup method will be called           again, since this function will have disabled things you set up there.
 *
 *          Note that to wake from either the ALARM button, the A2 interrupt or the A4 interrupt, you           must first configure this by calling watch_register_extwake_callback.
 *
 *          Power consumption depends on temperature, but as a rough estimate, this mode will consume:            * 6.0 ~ 7.5A while at normal room temperatures            * 9.5A while worn on a wrist (temperature  31 C)
 */
extern void watch_enter_sleep_mode(void);

/**
 * @brief enters Deep Sleep Mode by disabling all pins and peripherals except the RTC.  @details Short of BACKUP mode, this is the lowest power mode you can enter while retaining your           application state (and the ability to wake with the alarm button). Just note that the display           will be completely off, so you should document to the user of your application that they will           need to press the alarm button to wake the device, or use a sensor board with support for           an external wake pin.
 *
 *          All notes from watch_enter_sleep_mode apply here, except for power consumption. You can estimate           the power consumption of this mode to be on the order of 4A at room temperature.
 */
extern void watch_enter_deep_sleep_mode(void);

/**
 * @brief Enters the SAM L22's lowest-power mode, BACKUP.  @details This function does some housekeeping before entering BACKUP mode. It first disables all pins           and peripherals except for the RTC, and disables the tick interrupt (since that would wake           us up from BACKUP mode). Once again, if you wish to wake from the A2 or the A4 interrupt,           you must first configure this by calling watch_register_extwake_callback.  @note If you have a callback set for an external wake interrupt, it will be called if triggered while        in ACTIVE, STANDBY, Sleep and Deep Sleep modes, but it *will not be called* when waking from        BACKUP mode. Waking from backup is effectively like waking from reset, except that your        @ref app_wake_from_backup function will be called.  @warning On current revisions of the SAM L22 silicon, the ALARM_BTN pin (PA02 RTC/IN2) cannot wake           the device from deep sleep mode. There is an errata note (Reference: 15010) that says that           due to a silicon bug, RTC/IN2 is not functional in BACKUP. As a result, you should not call           this function unless you have a device on the nine-pin connector with an external interrupt           on pin A2 or A4 (i.e. an accelerometer with an interrupt pin).
 */
extern void watch_enter_backup_mode(void);

/**
 * Called by main.c while setting up the app. You should not call this from your app.
 */
extern void _watch_init(void);

/**
 * Initializes the real-time clock peripheral.
 */
extern void _watch_rtc_init(void);

/**
 * Called by buzzer and LED setup functions. You should not call this from your app.
 */
extern void _watch_enable_tcc(void);

/**
 * Called by buzzer and LED teardown functions. You should not call this from your app.
 */
extern void _watch_disable_tcc(void);

/**
 * Called by main.c if plugged in to USB. You should not call this from your app.
 */
extern void _watch_enable_usb(void);

extern int _write(int file, char *ptr, int len);

extern int _read(int file, char *ptr, int len);

/**
 * @brief Returns true if either the buzzer or the LED driver is enabled.  @details Both the buzzer and the LED use the TCC peripheral to drive their behavior. This function returns true if that           peripheral is enabled. You can use this function to determine whether you need to call the watch_disable_leds or           or watch_enable_buzzer functions before using these peripherals.
 */
extern bool watch_is_buzzer_or_led_enabled(void);

/**
 * @brief Returns true if USB is enabled.
 */
extern bool watch_is_usb_enabled(void);

/**
 * @brief Resets in the UF2 bootloader mode
 */
extern void watch_reset_to_bootloader(void);

/**
 * @brief Reads up to len bytes from the USB serial.  @param file ignored, you can pass in 0  @param ptr pointer to a buffer of at least len bytes  @param len the number of bytes you wish to read, max 256.  @return The number of bytes read, or zero if no bytes were read.
 */
extern int read(int file,
                char *ptr,
                int len);

extern void movement_move_to_face(uint8_t watch_face_index);

extern void movement_move_to_next_face(void);

extern bool movement_default_loop_handler(struct movement_event_t event,
                                          union movement_settings_t *settings);

extern void movement_illuminate_led(void);

extern void movement_request_tick_frequency(uint8_t freq);

extern void movement_schedule_background_task(union watch_date_time date_time);

extern void movement_cancel_background_task(void);

extern void movement_schedule_background_task_for_face(uint8_t watch_face_index,
                                                       union watch_date_time date_time);

extern void movement_cancel_background_task_for_face(uint8_t watch_face_index);

extern void movement_request_wake(void);

extern void movement_play_signal(void);

extern void movement_play_alarm(void);

extern void movement_play_alarm_beeps(uint8_t rounds, BuzzerNote alarm_note);

extern uint8_t movement_claim_backup_register(void);
