/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const GPIO_PIN_FUNCTION_A: u32 = 0;
pub const GPIO_PIN_FUNCTION_B: u32 = 1;
pub const GPIO_PIN_FUNCTION_C: u32 = 2;
pub const GPIO_PIN_FUNCTION_D: u32 = 3;
pub const GPIO_PIN_FUNCTION_E: u32 = 4;
pub const GPIO_PIN_FUNCTION_F: u32 = 5;
pub const GPIO_PIN_FUNCTION_G: u32 = 6;
pub const GPIO_PIN_FUNCTION_H: u32 = 7;
pub const GPIO_PIN_FUNCTION_I: u32 = 8;
pub const WATCH_BTN_ALARM_EIC_CHANNEL: u32 = 2;
pub const WATCH_BTN_LIGHT_EIC_CHANNEL: u32 = 6;
pub const WATCH_BTN_MODE_EIC_CHANNEL: u32 = 7;
pub const WATCH_BUZZER_TCC_CHANNEL: u32 = 1;
pub const WATCH_RED_TCC_CHANNEL: u32 = 2;
pub const WATCH_GREEN_TCC_CHANNEL: u32 = 3;
pub const WATCH_A0_EIC_CHANNEL: u32 = 4;
pub const WATCH_A1_EIC_CHANNEL: u32 = 1;
pub const WATCH_A2_EIC_CHANNEL: u32 = 2;
pub const WATCH_A3_EIC_CHANNEL: u32 = 3;
pub const WATCH_A4_EIC_CHANNEL: u32 = 0;
pub const __CM0PLUS_REV: u32 = 1;
pub const __MPU_PRESENT: u32 = 1;
pub const __NVIC_PRIO_BITS: u32 = 2;
pub const __VTOR_PRESENT: u32 = 1;
pub const __Vendor_SysTickConfig: u32 = 0;
pub const __CM0PLUS_CMSIS_VERSION_MAIN: u32 = 4;
pub const __CM0PLUS_CMSIS_VERSION_SUB: u32 = 0;
pub const __CM0PLUS_CMSIS_VERSION: u32 = 262144;
pub const __CORTEX_M: u32 = 0;
pub const __FPU_USED: u32 = 0;
pub const SCB_CPUID_IMPLEMENTER_Pos: u32 = 24;
pub const SCB_CPUID_IMPLEMENTER_Msk: u32 = 4278190080;
pub const SCB_CPUID_VARIANT_Pos: u32 = 20;
pub const SCB_CPUID_VARIANT_Msk: u32 = 15728640;
pub const SCB_CPUID_ARCHITECTURE_Pos: u32 = 16;
pub const SCB_CPUID_ARCHITECTURE_Msk: u32 = 983040;
pub const SCB_CPUID_PARTNO_Pos: u32 = 4;
pub const SCB_CPUID_PARTNO_Msk: u32 = 65520;
pub const SCB_CPUID_REVISION_Pos: u32 = 0;
pub const SCB_CPUID_REVISION_Msk: u32 = 15;
pub const SCB_ICSR_NMIPENDSET_Pos: u32 = 31;
pub const SCB_ICSR_NMIPENDSET_Msk: u32 = 2147483648;
pub const SCB_ICSR_PENDSVSET_Pos: u32 = 28;
pub const SCB_ICSR_PENDSVSET_Msk: u32 = 268435456;
pub const SCB_ICSR_PENDSVCLR_Pos: u32 = 27;
pub const SCB_ICSR_PENDSVCLR_Msk: u32 = 134217728;
pub const SCB_ICSR_PENDSTSET_Pos: u32 = 26;
pub const SCB_ICSR_PENDSTSET_Msk: u32 = 67108864;
pub const SCB_ICSR_PENDSTCLR_Pos: u32 = 25;
pub const SCB_ICSR_PENDSTCLR_Msk: u32 = 33554432;
pub const SCB_ICSR_ISRPREEMPT_Pos: u32 = 23;
pub const SCB_ICSR_ISRPREEMPT_Msk: u32 = 8388608;
pub const SCB_ICSR_ISRPENDING_Pos: u32 = 22;
pub const SCB_ICSR_ISRPENDING_Msk: u32 = 4194304;
pub const SCB_ICSR_VECTPENDING_Pos: u32 = 12;
pub const SCB_ICSR_VECTPENDING_Msk: u32 = 2093056;
pub const SCB_ICSR_VECTACTIVE_Pos: u32 = 0;
pub const SCB_ICSR_VECTACTIVE_Msk: u32 = 511;
pub const SCB_VTOR_TBLOFF_Pos: u32 = 8;
pub const SCB_VTOR_TBLOFF_Msk: u32 = 4294967040;
pub const SCB_AIRCR_VECTKEY_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEY_Msk: u32 = 4294901760;
pub const SCB_AIRCR_VECTKEYSTAT_Pos: u32 = 16;
pub const SCB_AIRCR_VECTKEYSTAT_Msk: u32 = 4294901760;
pub const SCB_AIRCR_ENDIANESS_Pos: u32 = 15;
pub const SCB_AIRCR_ENDIANESS_Msk: u32 = 32768;
pub const SCB_AIRCR_SYSRESETREQ_Pos: u32 = 2;
pub const SCB_AIRCR_SYSRESETREQ_Msk: u32 = 4;
pub const SCB_AIRCR_VECTCLRACTIVE_Pos: u32 = 1;
pub const SCB_AIRCR_VECTCLRACTIVE_Msk: u32 = 2;
pub const SCB_SCR_SEVONPEND_Pos: u32 = 4;
pub const SCB_SCR_SEVONPEND_Msk: u32 = 16;
pub const SCB_SCR_SLEEPDEEP_Pos: u32 = 2;
pub const SCB_SCR_SLEEPDEEP_Msk: u32 = 4;
pub const SCB_SCR_SLEEPONEXIT_Pos: u32 = 1;
pub const SCB_SCR_SLEEPONEXIT_Msk: u32 = 2;
pub const SCB_CCR_STKALIGN_Pos: u32 = 9;
pub const SCB_CCR_STKALIGN_Msk: u32 = 512;
pub const SCB_CCR_UNALIGN_TRP_Pos: u32 = 3;
pub const SCB_CCR_UNALIGN_TRP_Msk: u32 = 8;
pub const SCB_SHCSR_SVCALLPENDED_Pos: u32 = 15;
pub const SCB_SHCSR_SVCALLPENDED_Msk: u32 = 32768;
pub const SysTick_CTRL_COUNTFLAG_Pos: u32 = 16;
pub const SysTick_CTRL_COUNTFLAG_Msk: u32 = 65536;
pub const SysTick_CTRL_CLKSOURCE_Pos: u32 = 2;
pub const SysTick_CTRL_CLKSOURCE_Msk: u32 = 4;
pub const SysTick_CTRL_TICKINT_Pos: u32 = 1;
pub const SysTick_CTRL_TICKINT_Msk: u32 = 2;
pub const SysTick_CTRL_ENABLE_Pos: u32 = 0;
pub const SysTick_CTRL_ENABLE_Msk: u32 = 1;
pub const SysTick_LOAD_RELOAD_Pos: u32 = 0;
pub const SysTick_LOAD_RELOAD_Msk: u32 = 16777215;
pub const SysTick_VAL_CURRENT_Pos: u32 = 0;
pub const SysTick_VAL_CURRENT_Msk: u32 = 16777215;
pub const SysTick_CALIB_NOREF_Pos: u32 = 31;
pub const SysTick_CALIB_NOREF_Msk: u32 = 2147483648;
pub const SysTick_CALIB_SKEW_Pos: u32 = 30;
pub const SysTick_CALIB_SKEW_Msk: u32 = 1073741824;
pub const SysTick_CALIB_TENMS_Pos: u32 = 0;
pub const SysTick_CALIB_TENMS_Msk: u32 = 16777215;
pub const MPU_TYPE_IREGION_Pos: u32 = 16;
pub const MPU_TYPE_IREGION_Msk: u32 = 16711680;
pub const MPU_TYPE_DREGION_Pos: u32 = 8;
pub const MPU_TYPE_DREGION_Msk: u32 = 65280;
pub const MPU_TYPE_SEPARATE_Pos: u32 = 0;
pub const MPU_TYPE_SEPARATE_Msk: u32 = 1;
pub const MPU_CTRL_PRIVDEFENA_Pos: u32 = 2;
pub const MPU_CTRL_PRIVDEFENA_Msk: u32 = 4;
pub const MPU_CTRL_HFNMIENA_Pos: u32 = 1;
pub const MPU_CTRL_HFNMIENA_Msk: u32 = 2;
pub const MPU_CTRL_ENABLE_Pos: u32 = 0;
pub const MPU_CTRL_ENABLE_Msk: u32 = 1;
pub const MPU_RNR_REGION_Pos: u32 = 0;
pub const MPU_RNR_REGION_Msk: u32 = 255;
pub const MPU_RBAR_ADDR_Pos: u32 = 8;
pub const MPU_RBAR_ADDR_Msk: u32 = 4294967040;
pub const MPU_RBAR_VALID_Pos: u32 = 4;
pub const MPU_RBAR_VALID_Msk: u32 = 16;
pub const MPU_RBAR_REGION_Pos: u32 = 0;
pub const MPU_RBAR_REGION_Msk: u32 = 15;
pub const MPU_RASR_ATTRS_Pos: u32 = 16;
pub const MPU_RASR_ATTRS_Msk: u32 = 4294901760;
pub const MPU_RASR_XN_Pos: u32 = 28;
pub const MPU_RASR_XN_Msk: u32 = 268435456;
pub const MPU_RASR_AP_Pos: u32 = 24;
pub const MPU_RASR_AP_Msk: u32 = 117440512;
pub const MPU_RASR_TEX_Pos: u32 = 19;
pub const MPU_RASR_TEX_Msk: u32 = 3670016;
pub const MPU_RASR_S_Pos: u32 = 18;
pub const MPU_RASR_S_Msk: u32 = 262144;
pub const MPU_RASR_C_Pos: u32 = 17;
pub const MPU_RASR_C_Msk: u32 = 131072;
pub const MPU_RASR_B_Pos: u32 = 16;
pub const MPU_RASR_B_Msk: u32 = 65536;
pub const MPU_RASR_SRD_Pos: u32 = 8;
pub const MPU_RASR_SRD_Msk: u32 = 65280;
pub const MPU_RASR_SIZE_Pos: u32 = 1;
pub const MPU_RASR_SIZE_Msk: u32 = 62;
pub const MPU_RASR_ENABLE_Pos: u32 = 0;
pub const MPU_RASR_ENABLE_Msk: u32 = 1;
pub const SCS_BASE: u32 = 3758153728;
pub const SysTick_BASE: u32 = 3758153744;
pub const NVIC_BASE: u32 = 3758153984;
pub const SCB_BASE: u32 = 3758157056;
pub const MPU_BASE: u32 = 3758157200;
pub const REV_AC: u32 = 257;
pub const AC_CTRLA_OFFSET: u32 = 0;
pub const AC_CTRLA_SWRST_Pos: u32 = 0;
pub const AC_CTRLA_ENABLE_Pos: u32 = 1;
pub const AC_CTRLB_OFFSET: u32 = 1;
pub const AC_CTRLB_START0_Pos: u32 = 0;
pub const AC_CTRLB_START1_Pos: u32 = 1;
pub const AC_CTRLB_START_Pos: u32 = 0;
pub const AC_EVCTRL_OFFSET: u32 = 2;
pub const AC_EVCTRL_COMPEO0_Pos: u32 = 0;
pub const AC_EVCTRL_COMPEO1_Pos: u32 = 1;
pub const AC_EVCTRL_COMPEO_Pos: u32 = 0;
pub const AC_EVCTRL_WINEO0_Pos: u32 = 4;
pub const AC_EVCTRL_WINEO_Pos: u32 = 4;
pub const AC_EVCTRL_COMPEI0_Pos: u32 = 8;
pub const AC_EVCTRL_COMPEI1_Pos: u32 = 9;
pub const AC_EVCTRL_COMPEI_Pos: u32 = 8;
pub const AC_EVCTRL_INVEI0_Pos: u32 = 12;
pub const AC_EVCTRL_INVEI1_Pos: u32 = 13;
pub const AC_EVCTRL_INVEI_Pos: u32 = 12;
pub const AC_INTENCLR_OFFSET: u32 = 4;
pub const AC_INTENCLR_COMP0_Pos: u32 = 0;
pub const AC_INTENCLR_COMP1_Pos: u32 = 1;
pub const AC_INTENCLR_COMP_Pos: u32 = 0;
pub const AC_INTENCLR_WIN0_Pos: u32 = 4;
pub const AC_INTENCLR_WIN_Pos: u32 = 4;
pub const AC_INTENSET_OFFSET: u32 = 5;
pub const AC_INTENSET_COMP0_Pos: u32 = 0;
pub const AC_INTENSET_COMP1_Pos: u32 = 1;
pub const AC_INTENSET_COMP_Pos: u32 = 0;
pub const AC_INTENSET_WIN0_Pos: u32 = 4;
pub const AC_INTENSET_WIN_Pos: u32 = 4;
pub const AC_INTFLAG_OFFSET: u32 = 6;
pub const AC_INTFLAG_COMP0_Pos: u32 = 0;
pub const AC_INTFLAG_COMP1_Pos: u32 = 1;
pub const AC_INTFLAG_COMP_Pos: u32 = 0;
pub const AC_INTFLAG_WIN0_Pos: u32 = 4;
pub const AC_INTFLAG_WIN_Pos: u32 = 4;
pub const AC_STATUSA_OFFSET: u32 = 7;
pub const AC_STATUSA_STATE0_Pos: u32 = 0;
pub const AC_STATUSA_STATE1_Pos: u32 = 1;
pub const AC_STATUSA_STATE_Pos: u32 = 0;
pub const AC_STATUSA_WSTATE0_Pos: u32 = 4;
pub const AC_STATUSB_OFFSET: u32 = 8;
pub const AC_STATUSB_READY0_Pos: u32 = 0;
pub const AC_STATUSB_READY1_Pos: u32 = 1;
pub const AC_STATUSB_READY_Pos: u32 = 0;
pub const AC_DBGCTRL_OFFSET: u32 = 9;
pub const AC_DBGCTRL_DBGRUN_Pos: u32 = 0;
pub const AC_WINCTRL_OFFSET: u32 = 10;
pub const AC_WINCTRL_WEN0_Pos: u32 = 0;
pub const AC_WINCTRL_WINTSEL0_Pos: u32 = 1;
pub const AC_SCALER_OFFSET: u32 = 12;
pub const AC_SCALER_VALUE_Pos: u32 = 0;
pub const AC_COMPCTRL_OFFSET: u32 = 16;
pub const AC_COMPCTRL_ENABLE_Pos: u32 = 1;
pub const AC_COMPCTRL_SINGLE_Pos: u32 = 2;
pub const AC_COMPCTRL_INTSEL_Pos: u32 = 3;
pub const AC_COMPCTRL_RUNSTDBY_Pos: u32 = 6;
pub const AC_COMPCTRL_MUXNEG_Pos: u32 = 8;
pub const AC_COMPCTRL_MUXPOS_Pos: u32 = 12;
pub const AC_COMPCTRL_SWAP_Pos: u32 = 15;
pub const AC_COMPCTRL_SPEED_Pos: u32 = 16;
pub const AC_COMPCTRL_HYSTEN_Pos: u32 = 19;
pub const AC_COMPCTRL_HYST_Pos: u32 = 20;
pub const AC_COMPCTRL_FLEN_Pos: u32 = 24;
pub const AC_COMPCTRL_OUT_Pos: u32 = 28;
pub const AC_SYNCBUSY_OFFSET: u32 = 32;
pub const AC_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const AC_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const AC_SYNCBUSY_WINCTRL_Pos: u32 = 2;
pub const AC_SYNCBUSY_COMPCTRL0_Pos: u32 = 3;
pub const AC_SYNCBUSY_COMPCTRL1_Pos: u32 = 4;
pub const AC_SYNCBUSY_COMPCTRL_Pos: u32 = 3;
pub const REV_ADC: u32 = 528;
pub const ADC_CTRLA_OFFSET: u32 = 0;
pub const ADC_CTRLA_SWRST_Pos: u32 = 0;
pub const ADC_CTRLA_ENABLE_Pos: u32 = 1;
pub const ADC_CTRLA_RUNSTDBY_Pos: u32 = 6;
pub const ADC_CTRLA_ONDEMAND_Pos: u32 = 7;
pub const ADC_CTRLB_OFFSET: u32 = 1;
pub const ADC_CTRLB_PRESCALER_Pos: u32 = 0;
pub const ADC_REFCTRL_OFFSET: u32 = 2;
pub const ADC_REFCTRL_REFSEL_Pos: u32 = 0;
pub const ADC_REFCTRL_REFCOMP_Pos: u32 = 7;
pub const ADC_EVCTRL_OFFSET: u32 = 3;
pub const ADC_EVCTRL_FLUSHEI_Pos: u32 = 0;
pub const ADC_EVCTRL_STARTEI_Pos: u32 = 1;
pub const ADC_EVCTRL_FLUSHINV_Pos: u32 = 2;
pub const ADC_EVCTRL_STARTINV_Pos: u32 = 3;
pub const ADC_EVCTRL_RESRDYEO_Pos: u32 = 4;
pub const ADC_EVCTRL_WINMONEO_Pos: u32 = 5;
pub const ADC_INTENCLR_OFFSET: u32 = 4;
pub const ADC_INTENCLR_RESRDY_Pos: u32 = 0;
pub const ADC_INTENCLR_OVERRUN_Pos: u32 = 1;
pub const ADC_INTENCLR_WINMON_Pos: u32 = 2;
pub const ADC_INTENSET_OFFSET: u32 = 5;
pub const ADC_INTENSET_RESRDY_Pos: u32 = 0;
pub const ADC_INTENSET_OVERRUN_Pos: u32 = 1;
pub const ADC_INTENSET_WINMON_Pos: u32 = 2;
pub const ADC_INTFLAG_OFFSET: u32 = 6;
pub const ADC_INTFLAG_RESRDY_Pos: u32 = 0;
pub const ADC_INTFLAG_OVERRUN_Pos: u32 = 1;
pub const ADC_INTFLAG_WINMON_Pos: u32 = 2;
pub const ADC_SEQSTATUS_OFFSET: u32 = 7;
pub const ADC_SEQSTATUS_SEQSTATE_Pos: u32 = 0;
pub const ADC_SEQSTATUS_SEQBUSY_Pos: u32 = 7;
pub const ADC_INPUTCTRL_OFFSET: u32 = 8;
pub const ADC_INPUTCTRL_MUXPOS_Pos: u32 = 0;
pub const ADC_INPUTCTRL_MUXNEG_Pos: u32 = 8;
pub const ADC_CTRLC_OFFSET: u32 = 10;
pub const ADC_CTRLC_DIFFMODE_Pos: u32 = 0;
pub const ADC_CTRLC_LEFTADJ_Pos: u32 = 1;
pub const ADC_CTRLC_FREERUN_Pos: u32 = 2;
pub const ADC_CTRLC_CORREN_Pos: u32 = 3;
pub const ADC_CTRLC_RESSEL_Pos: u32 = 4;
pub const ADC_CTRLC_R2R_Pos: u32 = 7;
pub const ADC_CTRLC_WINMODE_Pos: u32 = 8;
pub const ADC_CTRLC_DUALSEL_Pos: u32 = 12;
pub const ADC_AVGCTRL_OFFSET: u32 = 12;
pub const ADC_AVGCTRL_SAMPLENUM_Pos: u32 = 0;
pub const ADC_AVGCTRL_ADJRES_Pos: u32 = 4;
pub const ADC_SAMPCTRL_OFFSET: u32 = 13;
pub const ADC_SAMPCTRL_SAMPLEN_Pos: u32 = 0;
pub const ADC_SAMPCTRL_OFFCOMP_Pos: u32 = 7;
pub const ADC_WINLT_OFFSET: u32 = 14;
pub const ADC_WINLT_WINLT_Pos: u32 = 0;
pub const ADC_WINUT_OFFSET: u32 = 16;
pub const ADC_WINUT_WINUT_Pos: u32 = 0;
pub const ADC_GAINCORR_OFFSET: u32 = 18;
pub const ADC_GAINCORR_GAINCORR_Pos: u32 = 0;
pub const ADC_OFFSETCORR_OFFSET: u32 = 20;
pub const ADC_OFFSETCORR_OFFSETCORR_Pos: u32 = 0;
pub const ADC_SWTRIG_OFFSET: u32 = 24;
pub const ADC_SWTRIG_FLUSH_Pos: u32 = 0;
pub const ADC_SWTRIG_START_Pos: u32 = 1;
pub const ADC_DBGCTRL_OFFSET: u32 = 28;
pub const ADC_DBGCTRL_DBGRUN_Pos: u32 = 0;
pub const ADC_SYNCBUSY_OFFSET: u32 = 32;
pub const ADC_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const ADC_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const ADC_SYNCBUSY_INPUTCTRL_Pos: u32 = 2;
pub const ADC_SYNCBUSY_CTRLC_Pos: u32 = 3;
pub const ADC_SYNCBUSY_AVGCTRL_Pos: u32 = 4;
pub const ADC_SYNCBUSY_SAMPCTRL_Pos: u32 = 5;
pub const ADC_SYNCBUSY_WINLT_Pos: u32 = 6;
pub const ADC_SYNCBUSY_WINUT_Pos: u32 = 7;
pub const ADC_SYNCBUSY_GAINCORR_Pos: u32 = 8;
pub const ADC_SYNCBUSY_OFFSETCORR_Pos: u32 = 9;
pub const ADC_SYNCBUSY_SWTRIG_Pos: u32 = 10;
pub const ADC_RESULT_OFFSET: u32 = 36;
pub const ADC_RESULT_RESULT_Pos: u32 = 0;
pub const ADC_SEQCTRL_OFFSET: u32 = 40;
pub const ADC_SEQCTRL_SEQEN_Pos: u32 = 0;
pub const ADC_CALIB_OFFSET: u32 = 44;
pub const ADC_CALIB_BIASCOMP_Pos: u32 = 0;
pub const ADC_CALIB_BIASREFBUF_Pos: u32 = 8;
pub const REV_AES: u32 = 528;
pub const AES_CTRLA_OFFSET: u32 = 0;
pub const AES_CTRLA_SWRST_Pos: u32 = 0;
pub const AES_CTRLA_ENABLE_Pos: u32 = 1;
pub const AES_CTRLA_AESMODE_Pos: u32 = 2;
pub const AES_CTRLA_CFBS_Pos: u32 = 5;
pub const AES_CTRLA_KEYSIZE_Pos: u32 = 8;
pub const AES_CTRLA_CIPHER_Pos: u32 = 10;
pub const AES_CTRLA_STARTMODE_Pos: u32 = 11;
pub const AES_CTRLA_LOD_Pos: u32 = 12;
pub const AES_CTRLA_KEYGEN_Pos: u32 = 13;
pub const AES_CTRLA_XORKEY_Pos: u32 = 14;
pub const AES_CTRLA_CTYPE_Pos: u32 = 16;
pub const AES_CTRLB_OFFSET: u32 = 4;
pub const AES_CTRLB_START_Pos: u32 = 0;
pub const AES_CTRLB_NEWMSG_Pos: u32 = 1;
pub const AES_CTRLB_EOM_Pos: u32 = 2;
pub const AES_CTRLB_GFMUL_Pos: u32 = 3;
pub const AES_INTENCLR_OFFSET: u32 = 5;
pub const AES_INTENCLR_ENCCMP_Pos: u32 = 0;
pub const AES_INTENCLR_GFMCMP_Pos: u32 = 1;
pub const AES_INTENSET_OFFSET: u32 = 6;
pub const AES_INTENSET_ENCCMP_Pos: u32 = 0;
pub const AES_INTENSET_GFMCMP_Pos: u32 = 1;
pub const AES_INTFLAG_OFFSET: u32 = 7;
pub const AES_INTFLAG_ENCCMP_Pos: u32 = 0;
pub const AES_INTFLAG_GFMCMP_Pos: u32 = 1;
pub const AES_DATABUFPTR_OFFSET: u32 = 8;
pub const AES_DATABUFPTR_INDATAPTR_Pos: u32 = 0;
pub const AES_DBGCTRL_OFFSET: u32 = 9;
pub const AES_DBGCTRL_DBGRUN_Pos: u32 = 0;
pub const AES_KEYWORD_OFFSET: u32 = 12;
pub const AES_INDATA_OFFSET: u32 = 56;
pub const AES_INTVECTV_OFFSET: u32 = 60;
pub const AES_HASHKEY_OFFSET: u32 = 92;
pub const AES_GHASH_OFFSET: u32 = 108;
pub const AES_CIPLEN_OFFSET: u32 = 128;
pub const AES_RANDSEED_OFFSET: u32 = 132;
pub const REV_CCL: u32 = 257;
pub const CCL_CTRL_OFFSET: u32 = 0;
pub const CCL_CTRL_SWRST_Pos: u32 = 0;
pub const CCL_CTRL_ENABLE_Pos: u32 = 1;
pub const CCL_CTRL_RUNSTDBY_Pos: u32 = 6;
pub const CCL_SEQCTRL_OFFSET: u32 = 4;
pub const CCL_SEQCTRL_SEQSEL_Pos: u32 = 0;
pub const CCL_LUTCTRL_OFFSET: u32 = 8;
pub const CCL_LUTCTRL_ENABLE_Pos: u32 = 1;
pub const CCL_LUTCTRL_FILTSEL_Pos: u32 = 4;
pub const CCL_LUTCTRL_EDGESEL_Pos: u32 = 7;
pub const CCL_LUTCTRL_INSEL0_Pos: u32 = 8;
pub const CCL_LUTCTRL_INSEL1_Pos: u32 = 12;
pub const CCL_LUTCTRL_INSEL2_Pos: u32 = 16;
pub const CCL_LUTCTRL_INVEI_Pos: u32 = 20;
pub const CCL_LUTCTRL_LUTEI_Pos: u32 = 21;
pub const CCL_LUTCTRL_LUTEO_Pos: u32 = 22;
pub const CCL_LUTCTRL_TRUTH_Pos: u32 = 24;
pub const REV_DMAC: u32 = 546;
pub const DMAC_CTRL_OFFSET: u32 = 0;
pub const DMAC_CTRL_SWRST_Pos: u32 = 0;
pub const DMAC_CTRL_DMAENABLE_Pos: u32 = 1;
pub const DMAC_CTRL_CRCENABLE_Pos: u32 = 2;
pub const DMAC_CTRL_LVLEN0_Pos: u32 = 8;
pub const DMAC_CTRL_LVLEN1_Pos: u32 = 9;
pub const DMAC_CTRL_LVLEN2_Pos: u32 = 10;
pub const DMAC_CTRL_LVLEN3_Pos: u32 = 11;
pub const DMAC_CTRL_LVLEN_Pos: u32 = 8;
pub const DMAC_CRCCTRL_OFFSET: u32 = 2;
pub const DMAC_CRCCTRL_CRCBEATSIZE_Pos: u32 = 0;
pub const DMAC_CRCCTRL_CRCPOLY_Pos: u32 = 2;
pub const DMAC_CRCCTRL_CRCSRC_Pos: u32 = 8;
pub const DMAC_CRCDATAIN_OFFSET: u32 = 4;
pub const DMAC_CRCDATAIN_CRCDATAIN_Pos: u32 = 0;
pub const DMAC_CRCCHKSUM_OFFSET: u32 = 8;
pub const DMAC_CRCCHKSUM_CRCCHKSUM_Pos: u32 = 0;
pub const DMAC_CRCSTATUS_OFFSET: u32 = 12;
pub const DMAC_CRCSTATUS_CRCBUSY_Pos: u32 = 0;
pub const DMAC_CRCSTATUS_CRCZERO_Pos: u32 = 1;
pub const DMAC_DBGCTRL_OFFSET: u32 = 13;
pub const DMAC_DBGCTRL_DBGRUN_Pos: u32 = 0;
pub const DMAC_QOSCTRL_OFFSET: u32 = 14;
pub const DMAC_QOSCTRL_WRBQOS_Pos: u32 = 0;
pub const DMAC_QOSCTRL_FQOS_Pos: u32 = 2;
pub const DMAC_QOSCTRL_DQOS_Pos: u32 = 4;
pub const DMAC_SWTRIGCTRL_OFFSET: u32 = 16;
pub const DMAC_SWTRIGCTRL_SWTRIG0_Pos: u32 = 0;
pub const DMAC_SWTRIGCTRL_SWTRIG1_Pos: u32 = 1;
pub const DMAC_SWTRIGCTRL_SWTRIG2_Pos: u32 = 2;
pub const DMAC_SWTRIGCTRL_SWTRIG3_Pos: u32 = 3;
pub const DMAC_SWTRIGCTRL_SWTRIG4_Pos: u32 = 4;
pub const DMAC_SWTRIGCTRL_SWTRIG5_Pos: u32 = 5;
pub const DMAC_SWTRIGCTRL_SWTRIG6_Pos: u32 = 6;
pub const DMAC_SWTRIGCTRL_SWTRIG7_Pos: u32 = 7;
pub const DMAC_SWTRIGCTRL_SWTRIG8_Pos: u32 = 8;
pub const DMAC_SWTRIGCTRL_SWTRIG9_Pos: u32 = 9;
pub const DMAC_SWTRIGCTRL_SWTRIG10_Pos: u32 = 10;
pub const DMAC_SWTRIGCTRL_SWTRIG11_Pos: u32 = 11;
pub const DMAC_SWTRIGCTRL_SWTRIG12_Pos: u32 = 12;
pub const DMAC_SWTRIGCTRL_SWTRIG13_Pos: u32 = 13;
pub const DMAC_SWTRIGCTRL_SWTRIG14_Pos: u32 = 14;
pub const DMAC_SWTRIGCTRL_SWTRIG15_Pos: u32 = 15;
pub const DMAC_SWTRIGCTRL_SWTRIG_Pos: u32 = 0;
pub const DMAC_PRICTRL0_OFFSET: u32 = 20;
pub const DMAC_PRICTRL0_LVLPRI0_Pos: u32 = 0;
pub const DMAC_PRICTRL0_RRLVLEN0_Pos: u32 = 7;
pub const DMAC_PRICTRL0_LVLPRI1_Pos: u32 = 8;
pub const DMAC_PRICTRL0_RRLVLEN1_Pos: u32 = 15;
pub const DMAC_PRICTRL0_LVLPRI2_Pos: u32 = 16;
pub const DMAC_PRICTRL0_RRLVLEN2_Pos: u32 = 23;
pub const DMAC_PRICTRL0_LVLPRI3_Pos: u32 = 24;
pub const DMAC_PRICTRL0_RRLVLEN3_Pos: u32 = 31;
pub const DMAC_INTPEND_OFFSET: u32 = 32;
pub const DMAC_INTPEND_ID_Pos: u32 = 0;
pub const DMAC_INTPEND_TERR_Pos: u32 = 8;
pub const DMAC_INTPEND_TCMPL_Pos: u32 = 9;
pub const DMAC_INTPEND_SUSP_Pos: u32 = 10;
pub const DMAC_INTPEND_FERR_Pos: u32 = 13;
pub const DMAC_INTPEND_BUSY_Pos: u32 = 14;
pub const DMAC_INTPEND_PEND_Pos: u32 = 15;
pub const DMAC_INTSTATUS_OFFSET: u32 = 36;
pub const DMAC_INTSTATUS_CHINT0_Pos: u32 = 0;
pub const DMAC_INTSTATUS_CHINT1_Pos: u32 = 1;
pub const DMAC_INTSTATUS_CHINT2_Pos: u32 = 2;
pub const DMAC_INTSTATUS_CHINT3_Pos: u32 = 3;
pub const DMAC_INTSTATUS_CHINT4_Pos: u32 = 4;
pub const DMAC_INTSTATUS_CHINT5_Pos: u32 = 5;
pub const DMAC_INTSTATUS_CHINT6_Pos: u32 = 6;
pub const DMAC_INTSTATUS_CHINT7_Pos: u32 = 7;
pub const DMAC_INTSTATUS_CHINT8_Pos: u32 = 8;
pub const DMAC_INTSTATUS_CHINT9_Pos: u32 = 9;
pub const DMAC_INTSTATUS_CHINT10_Pos: u32 = 10;
pub const DMAC_INTSTATUS_CHINT11_Pos: u32 = 11;
pub const DMAC_INTSTATUS_CHINT12_Pos: u32 = 12;
pub const DMAC_INTSTATUS_CHINT13_Pos: u32 = 13;
pub const DMAC_INTSTATUS_CHINT14_Pos: u32 = 14;
pub const DMAC_INTSTATUS_CHINT15_Pos: u32 = 15;
pub const DMAC_INTSTATUS_CHINT_Pos: u32 = 0;
pub const DMAC_BUSYCH_OFFSET: u32 = 40;
pub const DMAC_BUSYCH_BUSYCH0_Pos: u32 = 0;
pub const DMAC_BUSYCH_BUSYCH1_Pos: u32 = 1;
pub const DMAC_BUSYCH_BUSYCH2_Pos: u32 = 2;
pub const DMAC_BUSYCH_BUSYCH3_Pos: u32 = 3;
pub const DMAC_BUSYCH_BUSYCH4_Pos: u32 = 4;
pub const DMAC_BUSYCH_BUSYCH5_Pos: u32 = 5;
pub const DMAC_BUSYCH_BUSYCH6_Pos: u32 = 6;
pub const DMAC_BUSYCH_BUSYCH7_Pos: u32 = 7;
pub const DMAC_BUSYCH_BUSYCH8_Pos: u32 = 8;
pub const DMAC_BUSYCH_BUSYCH9_Pos: u32 = 9;
pub const DMAC_BUSYCH_BUSYCH10_Pos: u32 = 10;
pub const DMAC_BUSYCH_BUSYCH11_Pos: u32 = 11;
pub const DMAC_BUSYCH_BUSYCH12_Pos: u32 = 12;
pub const DMAC_BUSYCH_BUSYCH13_Pos: u32 = 13;
pub const DMAC_BUSYCH_BUSYCH14_Pos: u32 = 14;
pub const DMAC_BUSYCH_BUSYCH15_Pos: u32 = 15;
pub const DMAC_BUSYCH_BUSYCH_Pos: u32 = 0;
pub const DMAC_PENDCH_OFFSET: u32 = 44;
pub const DMAC_PENDCH_PENDCH0_Pos: u32 = 0;
pub const DMAC_PENDCH_PENDCH1_Pos: u32 = 1;
pub const DMAC_PENDCH_PENDCH2_Pos: u32 = 2;
pub const DMAC_PENDCH_PENDCH3_Pos: u32 = 3;
pub const DMAC_PENDCH_PENDCH4_Pos: u32 = 4;
pub const DMAC_PENDCH_PENDCH5_Pos: u32 = 5;
pub const DMAC_PENDCH_PENDCH6_Pos: u32 = 6;
pub const DMAC_PENDCH_PENDCH7_Pos: u32 = 7;
pub const DMAC_PENDCH_PENDCH8_Pos: u32 = 8;
pub const DMAC_PENDCH_PENDCH9_Pos: u32 = 9;
pub const DMAC_PENDCH_PENDCH10_Pos: u32 = 10;
pub const DMAC_PENDCH_PENDCH11_Pos: u32 = 11;
pub const DMAC_PENDCH_PENDCH12_Pos: u32 = 12;
pub const DMAC_PENDCH_PENDCH13_Pos: u32 = 13;
pub const DMAC_PENDCH_PENDCH14_Pos: u32 = 14;
pub const DMAC_PENDCH_PENDCH15_Pos: u32 = 15;
pub const DMAC_PENDCH_PENDCH_Pos: u32 = 0;
pub const DMAC_ACTIVE_OFFSET: u32 = 48;
pub const DMAC_ACTIVE_LVLEX0_Pos: u32 = 0;
pub const DMAC_ACTIVE_LVLEX1_Pos: u32 = 1;
pub const DMAC_ACTIVE_LVLEX2_Pos: u32 = 2;
pub const DMAC_ACTIVE_LVLEX3_Pos: u32 = 3;
pub const DMAC_ACTIVE_LVLEX_Pos: u32 = 0;
pub const DMAC_ACTIVE_ID_Pos: u32 = 8;
pub const DMAC_ACTIVE_ABUSY_Pos: u32 = 15;
pub const DMAC_ACTIVE_BTCNT_Pos: u32 = 16;
pub const DMAC_BASEADDR_OFFSET: u32 = 52;
pub const DMAC_BASEADDR_BASEADDR_Pos: u32 = 0;
pub const DMAC_WRBADDR_OFFSET: u32 = 56;
pub const DMAC_WRBADDR_WRBADDR_Pos: u32 = 0;
pub const DMAC_CHID_OFFSET: u32 = 63;
pub const DMAC_CHID_ID_Pos: u32 = 0;
pub const DMAC_CHCTRLA_OFFSET: u32 = 64;
pub const DMAC_CHCTRLA_SWRST_Pos: u32 = 0;
pub const DMAC_CHCTRLA_ENABLE_Pos: u32 = 1;
pub const DMAC_CHCTRLA_RUNSTDBY_Pos: u32 = 6;
pub const DMAC_CHCTRLB_OFFSET: u32 = 68;
pub const DMAC_CHCTRLB_EVACT_Pos: u32 = 0;
pub const DMAC_CHCTRLB_EVIE_Pos: u32 = 3;
pub const DMAC_CHCTRLB_EVOE_Pos: u32 = 4;
pub const DMAC_CHCTRLB_LVL_Pos: u32 = 5;
pub const DMAC_CHCTRLB_TRIGSRC_Pos: u32 = 8;
pub const DMAC_CHCTRLB_TRIGACT_Pos: u32 = 22;
pub const DMAC_CHCTRLB_CMD_Pos: u32 = 24;
pub const DMAC_CHINTENCLR_OFFSET: u32 = 76;
pub const DMAC_CHINTENCLR_TERR_Pos: u32 = 0;
pub const DMAC_CHINTENCLR_TCMPL_Pos: u32 = 1;
pub const DMAC_CHINTENCLR_SUSP_Pos: u32 = 2;
pub const DMAC_CHINTENSET_OFFSET: u32 = 77;
pub const DMAC_CHINTENSET_TERR_Pos: u32 = 0;
pub const DMAC_CHINTENSET_TCMPL_Pos: u32 = 1;
pub const DMAC_CHINTENSET_SUSP_Pos: u32 = 2;
pub const DMAC_CHINTFLAG_OFFSET: u32 = 78;
pub const DMAC_CHINTFLAG_TERR_Pos: u32 = 0;
pub const DMAC_CHINTFLAG_TCMPL_Pos: u32 = 1;
pub const DMAC_CHINTFLAG_SUSP_Pos: u32 = 2;
pub const DMAC_CHSTATUS_OFFSET: u32 = 79;
pub const DMAC_CHSTATUS_PEND_Pos: u32 = 0;
pub const DMAC_CHSTATUS_BUSY_Pos: u32 = 1;
pub const DMAC_CHSTATUS_FERR_Pos: u32 = 2;
pub const DMAC_BTCTRL_OFFSET: u32 = 0;
pub const DMAC_BTCTRL_VALID_Pos: u32 = 0;
pub const DMAC_BTCTRL_EVOSEL_Pos: u32 = 1;
pub const DMAC_BTCTRL_BLOCKACT_Pos: u32 = 3;
pub const DMAC_BTCTRL_BEATSIZE_Pos: u32 = 8;
pub const DMAC_BTCTRL_SRCINC_Pos: u32 = 10;
pub const DMAC_BTCTRL_DSTINC_Pos: u32 = 11;
pub const DMAC_BTCTRL_STEPSEL_Pos: u32 = 12;
pub const DMAC_BTCTRL_STEPSIZE_Pos: u32 = 13;
pub const DMAC_BTCNT_OFFSET: u32 = 2;
pub const DMAC_BTCNT_BTCNT_Pos: u32 = 0;
pub const DMAC_SRCADDR_OFFSET: u32 = 4;
pub const DMAC_SRCADDR_SRCADDR_Pos: u32 = 0;
pub const DMAC_DSTADDR_OFFSET: u32 = 8;
pub const DMAC_DSTADDR_DSTADDR_Pos: u32 = 0;
pub const DMAC_DESCADDR_OFFSET: u32 = 12;
pub const DMAC_DESCADDR_DESCADDR_Pos: u32 = 0;
pub const REV_DSU: u32 = 592;
pub const DSU_CTRL_OFFSET: u32 = 0;
pub const DSU_CTRL_SWRST_Pos: u32 = 0;
pub const DSU_CTRL_CRC_Pos: u32 = 2;
pub const DSU_CTRL_MBIST_Pos: u32 = 3;
pub const DSU_CTRL_CE_Pos: u32 = 4;
pub const DSU_CTRL_ARR_Pos: u32 = 6;
pub const DSU_CTRL_SMSA_Pos: u32 = 7;
pub const DSU_STATUSA_OFFSET: u32 = 1;
pub const DSU_STATUSA_DONE_Pos: u32 = 0;
pub const DSU_STATUSA_CRSTEXT_Pos: u32 = 1;
pub const DSU_STATUSA_BERR_Pos: u32 = 2;
pub const DSU_STATUSA_FAIL_Pos: u32 = 3;
pub const DSU_STATUSA_PERR_Pos: u32 = 4;
pub const DSU_STATUSB_OFFSET: u32 = 2;
pub const DSU_STATUSB_PROT_Pos: u32 = 0;
pub const DSU_STATUSB_DBGPRES_Pos: u32 = 1;
pub const DSU_STATUSB_DCCD0_Pos: u32 = 2;
pub const DSU_STATUSB_DCCD1_Pos: u32 = 3;
pub const DSU_STATUSB_DCCD_Pos: u32 = 2;
pub const DSU_STATUSB_HPE_Pos: u32 = 4;
pub const DSU_ADDR_OFFSET: u32 = 4;
pub const DSU_ADDR_AMOD_Pos: u32 = 0;
pub const DSU_ADDR_ADDR_Pos: u32 = 2;
pub const DSU_LENGTH_OFFSET: u32 = 8;
pub const DSU_LENGTH_LENGTH_Pos: u32 = 2;
pub const DSU_DATA_OFFSET: u32 = 12;
pub const DSU_DATA_DATA_Pos: u32 = 0;
pub const DSU_DCC_OFFSET: u32 = 16;
pub const DSU_DCC_DATA_Pos: u32 = 0;
pub const DSU_DID_OFFSET: u32 = 24;
pub const DSU_DID_DEVSEL_Pos: u32 = 0;
pub const DSU_DID_REVISION_Pos: u32 = 8;
pub const DSU_DID_DIE_Pos: u32 = 12;
pub const DSU_DID_SERIES_Pos: u32 = 16;
pub const DSU_DID_FAMILY_Pos: u32 = 23;
pub const DSU_DID_PROCESSOR_Pos: u32 = 28;
pub const DSU_DCFG_OFFSET: u32 = 240;
pub const DSU_DCFG_DCFG_Pos: u32 = 0;
pub const DSU_ENTRY0_OFFSET: u32 = 4096;
pub const DSU_ENTRY0_EPRES_Pos: u32 = 0;
pub const DSU_ENTRY0_FMT_Pos: u32 = 1;
pub const DSU_ENTRY0_ADDOFF_Pos: u32 = 12;
pub const DSU_ENTRY1_OFFSET: u32 = 4100;
pub const DSU_END_OFFSET: u32 = 4104;
pub const DSU_END_END_Pos: u32 = 0;
pub const DSU_MEMTYPE_OFFSET: u32 = 8140;
pub const DSU_MEMTYPE_SMEMP_Pos: u32 = 0;
pub const DSU_PID4_OFFSET: u32 = 8144;
pub const DSU_PID4_JEPCC_Pos: u32 = 0;
pub const DSU_PID4_FKBC_Pos: u32 = 4;
pub const DSU_PID5_OFFSET: u32 = 8148;
pub const DSU_PID6_OFFSET: u32 = 8152;
pub const DSU_PID7_OFFSET: u32 = 8156;
pub const DSU_PID0_OFFSET: u32 = 8160;
pub const DSU_PID0_PARTNBL_Pos: u32 = 0;
pub const DSU_PID1_OFFSET: u32 = 8164;
pub const DSU_PID1_PARTNBH_Pos: u32 = 0;
pub const DSU_PID1_JEPIDCL_Pos: u32 = 4;
pub const DSU_PID2_OFFSET: u32 = 8168;
pub const DSU_PID2_JEPIDCH_Pos: u32 = 0;
pub const DSU_PID2_JEPU_Pos: u32 = 3;
pub const DSU_PID2_REVISION_Pos: u32 = 4;
pub const DSU_PID3_OFFSET: u32 = 8172;
pub const DSU_PID3_CUSMOD_Pos: u32 = 0;
pub const DSU_PID3_REVAND_Pos: u32 = 4;
pub const DSU_CID0_OFFSET: u32 = 8176;
pub const DSU_CID0_PREAMBLEB0_Pos: u32 = 0;
pub const DSU_CID1_OFFSET: u32 = 8180;
pub const DSU_CID1_PREAMBLE_Pos: u32 = 0;
pub const DSU_CID1_CCLASS_Pos: u32 = 4;
pub const DSU_CID2_OFFSET: u32 = 8184;
pub const DSU_CID2_PREAMBLEB2_Pos: u32 = 0;
pub const DSU_CID3_OFFSET: u32 = 8188;
pub const DSU_CID3_PREAMBLEB3_Pos: u32 = 0;
pub const REV_EIC: u32 = 514;
pub const EIC_CTRLA_OFFSET: u32 = 0;
pub const EIC_CTRLA_SWRST_Pos: u32 = 0;
pub const EIC_CTRLA_ENABLE_Pos: u32 = 1;
pub const EIC_CTRLA_CKSEL_Pos: u32 = 4;
pub const EIC_NMICTRL_OFFSET: u32 = 1;
pub const EIC_NMICTRL_NMISENSE_Pos: u32 = 0;
pub const EIC_NMICTRL_NMIFILTEN_Pos: u32 = 3;
pub const EIC_NMICTRL_NMIASYNCH_Pos: u32 = 4;
pub const EIC_NMIFLAG_OFFSET: u32 = 2;
pub const EIC_NMIFLAG_NMI_Pos: u32 = 0;
pub const EIC_SYNCBUSY_OFFSET: u32 = 4;
pub const EIC_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const EIC_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const EIC_EVCTRL_OFFSET: u32 = 8;
pub const EIC_EVCTRL_EXTINTEO_Pos: u32 = 0;
pub const EIC_INTENCLR_OFFSET: u32 = 12;
pub const EIC_INTENCLR_EXTINT_Pos: u32 = 0;
pub const EIC_INTENSET_OFFSET: u32 = 16;
pub const EIC_INTENSET_EXTINT_Pos: u32 = 0;
pub const EIC_INTFLAG_OFFSET: u32 = 20;
pub const EIC_INTFLAG_EXTINT_Pos: u32 = 0;
pub const EIC_ASYNCH_OFFSET: u32 = 24;
pub const EIC_ASYNCH_ASYNCH_Pos: u32 = 0;
pub const EIC_CONFIG_OFFSET: u32 = 28;
pub const EIC_CONFIG_SENSE0_Pos: u32 = 0;
pub const EIC_CONFIG_FILTEN0_Pos: u32 = 3;
pub const EIC_CONFIG_SENSE1_Pos: u32 = 4;
pub const EIC_CONFIG_FILTEN1_Pos: u32 = 7;
pub const EIC_CONFIG_SENSE2_Pos: u32 = 8;
pub const EIC_CONFIG_FILTEN2_Pos: u32 = 11;
pub const EIC_CONFIG_SENSE3_Pos: u32 = 12;
pub const EIC_CONFIG_FILTEN3_Pos: u32 = 15;
pub const EIC_CONFIG_SENSE4_Pos: u32 = 16;
pub const EIC_CONFIG_FILTEN4_Pos: u32 = 19;
pub const EIC_CONFIG_SENSE5_Pos: u32 = 20;
pub const EIC_CONFIG_FILTEN5_Pos: u32 = 23;
pub const EIC_CONFIG_SENSE6_Pos: u32 = 24;
pub const EIC_CONFIG_FILTEN6_Pos: u32 = 27;
pub const EIC_CONFIG_SENSE7_Pos: u32 = 28;
pub const EIC_CONFIG_FILTEN7_Pos: u32 = 31;
pub const REV_EVSYS: u32 = 257;
pub const EVSYS_CTRLA_OFFSET: u32 = 0;
pub const EVSYS_CTRLA_SWRST_Pos: u32 = 0;
pub const EVSYS_CHSTATUS_OFFSET: u32 = 12;
pub const EVSYS_CHSTATUS_USRRDY0_Pos: u32 = 0;
pub const EVSYS_CHSTATUS_USRRDY1_Pos: u32 = 1;
pub const EVSYS_CHSTATUS_USRRDY2_Pos: u32 = 2;
pub const EVSYS_CHSTATUS_USRRDY3_Pos: u32 = 3;
pub const EVSYS_CHSTATUS_USRRDY4_Pos: u32 = 4;
pub const EVSYS_CHSTATUS_USRRDY5_Pos: u32 = 5;
pub const EVSYS_CHSTATUS_USRRDY6_Pos: u32 = 6;
pub const EVSYS_CHSTATUS_USRRDY7_Pos: u32 = 7;
pub const EVSYS_CHSTATUS_USRRDY_Pos: u32 = 0;
pub const EVSYS_CHSTATUS_CHBUSY0_Pos: u32 = 16;
pub const EVSYS_CHSTATUS_CHBUSY1_Pos: u32 = 17;
pub const EVSYS_CHSTATUS_CHBUSY2_Pos: u32 = 18;
pub const EVSYS_CHSTATUS_CHBUSY3_Pos: u32 = 19;
pub const EVSYS_CHSTATUS_CHBUSY4_Pos: u32 = 20;
pub const EVSYS_CHSTATUS_CHBUSY5_Pos: u32 = 21;
pub const EVSYS_CHSTATUS_CHBUSY6_Pos: u32 = 22;
pub const EVSYS_CHSTATUS_CHBUSY7_Pos: u32 = 23;
pub const EVSYS_CHSTATUS_CHBUSY_Pos: u32 = 16;
pub const EVSYS_INTENCLR_OFFSET: u32 = 16;
pub const EVSYS_INTENCLR_OVR0_Pos: u32 = 0;
pub const EVSYS_INTENCLR_OVR1_Pos: u32 = 1;
pub const EVSYS_INTENCLR_OVR2_Pos: u32 = 2;
pub const EVSYS_INTENCLR_OVR3_Pos: u32 = 3;
pub const EVSYS_INTENCLR_OVR4_Pos: u32 = 4;
pub const EVSYS_INTENCLR_OVR5_Pos: u32 = 5;
pub const EVSYS_INTENCLR_OVR6_Pos: u32 = 6;
pub const EVSYS_INTENCLR_OVR7_Pos: u32 = 7;
pub const EVSYS_INTENCLR_OVR_Pos: u32 = 0;
pub const EVSYS_INTENCLR_EVD0_Pos: u32 = 16;
pub const EVSYS_INTENCLR_EVD1_Pos: u32 = 17;
pub const EVSYS_INTENCLR_EVD2_Pos: u32 = 18;
pub const EVSYS_INTENCLR_EVD3_Pos: u32 = 19;
pub const EVSYS_INTENCLR_EVD4_Pos: u32 = 20;
pub const EVSYS_INTENCLR_EVD5_Pos: u32 = 21;
pub const EVSYS_INTENCLR_EVD6_Pos: u32 = 22;
pub const EVSYS_INTENCLR_EVD7_Pos: u32 = 23;
pub const EVSYS_INTENCLR_EVD_Pos: u32 = 16;
pub const EVSYS_INTENSET_OFFSET: u32 = 20;
pub const EVSYS_INTENSET_OVR0_Pos: u32 = 0;
pub const EVSYS_INTENSET_OVR1_Pos: u32 = 1;
pub const EVSYS_INTENSET_OVR2_Pos: u32 = 2;
pub const EVSYS_INTENSET_OVR3_Pos: u32 = 3;
pub const EVSYS_INTENSET_OVR4_Pos: u32 = 4;
pub const EVSYS_INTENSET_OVR5_Pos: u32 = 5;
pub const EVSYS_INTENSET_OVR6_Pos: u32 = 6;
pub const EVSYS_INTENSET_OVR7_Pos: u32 = 7;
pub const EVSYS_INTENSET_OVR_Pos: u32 = 0;
pub const EVSYS_INTENSET_EVD0_Pos: u32 = 16;
pub const EVSYS_INTENSET_EVD1_Pos: u32 = 17;
pub const EVSYS_INTENSET_EVD2_Pos: u32 = 18;
pub const EVSYS_INTENSET_EVD3_Pos: u32 = 19;
pub const EVSYS_INTENSET_EVD4_Pos: u32 = 20;
pub const EVSYS_INTENSET_EVD5_Pos: u32 = 21;
pub const EVSYS_INTENSET_EVD6_Pos: u32 = 22;
pub const EVSYS_INTENSET_EVD7_Pos: u32 = 23;
pub const EVSYS_INTENSET_EVD_Pos: u32 = 16;
pub const EVSYS_INTFLAG_OFFSET: u32 = 24;
pub const EVSYS_INTFLAG_OVR0_Pos: u32 = 0;
pub const EVSYS_INTFLAG_OVR1_Pos: u32 = 1;
pub const EVSYS_INTFLAG_OVR2_Pos: u32 = 2;
pub const EVSYS_INTFLAG_OVR3_Pos: u32 = 3;
pub const EVSYS_INTFLAG_OVR4_Pos: u32 = 4;
pub const EVSYS_INTFLAG_OVR5_Pos: u32 = 5;
pub const EVSYS_INTFLAG_OVR6_Pos: u32 = 6;
pub const EVSYS_INTFLAG_OVR7_Pos: u32 = 7;
pub const EVSYS_INTFLAG_OVR_Pos: u32 = 0;
pub const EVSYS_INTFLAG_EVD0_Pos: u32 = 16;
pub const EVSYS_INTFLAG_EVD1_Pos: u32 = 17;
pub const EVSYS_INTFLAG_EVD2_Pos: u32 = 18;
pub const EVSYS_INTFLAG_EVD3_Pos: u32 = 19;
pub const EVSYS_INTFLAG_EVD4_Pos: u32 = 20;
pub const EVSYS_INTFLAG_EVD5_Pos: u32 = 21;
pub const EVSYS_INTFLAG_EVD6_Pos: u32 = 22;
pub const EVSYS_INTFLAG_EVD7_Pos: u32 = 23;
pub const EVSYS_INTFLAG_EVD_Pos: u32 = 16;
pub const EVSYS_SWEVT_OFFSET: u32 = 28;
pub const EVSYS_SWEVT_CHANNEL0_Pos: u32 = 0;
pub const EVSYS_SWEVT_CHANNEL1_Pos: u32 = 1;
pub const EVSYS_SWEVT_CHANNEL2_Pos: u32 = 2;
pub const EVSYS_SWEVT_CHANNEL3_Pos: u32 = 3;
pub const EVSYS_SWEVT_CHANNEL4_Pos: u32 = 4;
pub const EVSYS_SWEVT_CHANNEL5_Pos: u32 = 5;
pub const EVSYS_SWEVT_CHANNEL6_Pos: u32 = 6;
pub const EVSYS_SWEVT_CHANNEL7_Pos: u32 = 7;
pub const EVSYS_SWEVT_CHANNEL_Pos: u32 = 0;
pub const EVSYS_CHANNEL_OFFSET: u32 = 32;
pub const EVSYS_CHANNEL_EVGEN_Pos: u32 = 0;
pub const EVSYS_CHANNEL_PATH_Pos: u32 = 8;
pub const EVSYS_CHANNEL_EDGSEL_Pos: u32 = 10;
pub const EVSYS_CHANNEL_RUNSTDBY_Pos: u32 = 14;
pub const EVSYS_CHANNEL_ONDEMAND_Pos: u32 = 15;
pub const EVSYS_USER_OFFSET: u32 = 128;
pub const EVSYS_USER_CHANNEL_Pos: u32 = 0;
pub const REV_FREQM: u32 = 257;
pub const FREQM_CTRLA_OFFSET: u32 = 0;
pub const FREQM_CTRLA_SWRST_Pos: u32 = 0;
pub const FREQM_CTRLA_ENABLE_Pos: u32 = 1;
pub const FREQM_CTRLB_OFFSET: u32 = 1;
pub const FREQM_CTRLB_START_Pos: u32 = 0;
pub const FREQM_CFGA_OFFSET: u32 = 2;
pub const FREQM_CFGA_REFNUM_Pos: u32 = 0;
pub const FREQM_INTENCLR_OFFSET: u32 = 8;
pub const FREQM_INTENCLR_DONE_Pos: u32 = 0;
pub const FREQM_INTENSET_OFFSET: u32 = 9;
pub const FREQM_INTENSET_DONE_Pos: u32 = 0;
pub const FREQM_INTFLAG_OFFSET: u32 = 10;
pub const FREQM_INTFLAG_DONE_Pos: u32 = 0;
pub const FREQM_STATUS_OFFSET: u32 = 11;
pub const FREQM_STATUS_BUSY_Pos: u32 = 0;
pub const FREQM_STATUS_OVF_Pos: u32 = 1;
pub const FREQM_SYNCBUSY_OFFSET: u32 = 12;
pub const FREQM_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const FREQM_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const FREQM_VALUE_OFFSET: u32 = 16;
pub const FREQM_VALUE_VALUE_Pos: u32 = 0;
pub const REV_GCLK: u32 = 273;
pub const GCLK_CTRLA_OFFSET: u32 = 0;
pub const GCLK_CTRLA_SWRST_Pos: u32 = 0;
pub const GCLK_SYNCBUSY_OFFSET: u32 = 4;
pub const GCLK_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const GCLK_SYNCBUSY_GENCTRL0_Pos: u32 = 2;
pub const GCLK_SYNCBUSY_GENCTRL1_Pos: u32 = 3;
pub const GCLK_SYNCBUSY_GENCTRL2_Pos: u32 = 4;
pub const GCLK_SYNCBUSY_GENCTRL3_Pos: u32 = 5;
pub const GCLK_SYNCBUSY_GENCTRL4_Pos: u32 = 6;
pub const GCLK_SYNCBUSY_GENCTRL_Pos: u32 = 2;
pub const GCLK_GENCTRL_OFFSET: u32 = 32;
pub const GCLK_GENCTRL_SRC_Pos: u32 = 0;
pub const GCLK_GENCTRL_GENEN_Pos: u32 = 8;
pub const GCLK_GENCTRL_IDC_Pos: u32 = 9;
pub const GCLK_GENCTRL_OOV_Pos: u32 = 10;
pub const GCLK_GENCTRL_OE_Pos: u32 = 11;
pub const GCLK_GENCTRL_DIVSEL_Pos: u32 = 12;
pub const GCLK_GENCTRL_RUNSTDBY_Pos: u32 = 13;
pub const GCLK_GENCTRL_DIV_Pos: u32 = 16;
pub const GCLK_PCHCTRL_OFFSET: u32 = 128;
pub const GCLK_PCHCTRL_GEN_Pos: u32 = 0;
pub const GCLK_PCHCTRL_CHEN_Pos: u32 = 6;
pub const GCLK_PCHCTRL_WRTLOCK_Pos: u32 = 7;
pub const REV_MCLK: u32 = 528;
pub const MCLK_INTENCLR_OFFSET: u32 = 1;
pub const MCLK_INTENCLR_CKRDY_Pos: u32 = 0;
pub const MCLK_INTENSET_OFFSET: u32 = 2;
pub const MCLK_INTENSET_CKRDY_Pos: u32 = 0;
pub const MCLK_INTFLAG_OFFSET: u32 = 3;
pub const MCLK_INTFLAG_CKRDY_Pos: u32 = 0;
pub const MCLK_CPUDIV_OFFSET: u32 = 4;
pub const MCLK_CPUDIV_CPUDIV_Pos: u32 = 0;
pub const MCLK_BUPDIV_OFFSET: u32 = 6;
pub const MCLK_BUPDIV_BUPDIV_Pos: u32 = 0;
pub const MCLK_AHBMASK_OFFSET: u32 = 16;
pub const MCLK_AHBMASK_HPB0_Pos: u32 = 0;
pub const MCLK_AHBMASK_HPB1_Pos: u32 = 1;
pub const MCLK_AHBMASK_HPB2_Pos: u32 = 2;
pub const MCLK_AHBMASK_DMAC_Pos: u32 = 3;
pub const MCLK_AHBMASK_USB_Pos: u32 = 4;
pub const MCLK_AHBMASK_DSU_Pos: u32 = 5;
pub const MCLK_AHBMASK_PAC_Pos: u32 = 7;
pub const MCLK_AHBMASK_NVMCTRL_Pos: u32 = 8;
pub const MCLK_AHBMASK_HSRAM_Pos: u32 = 9;
pub const MCLK_AHBMASK_NVMCTRL_PICACHU_Pos: u32 = 10;
pub const MCLK_APBAMASK_OFFSET: u32 = 20;
pub const MCLK_APBAMASK_PAC_Pos: u32 = 0;
pub const MCLK_APBAMASK_PM_Pos: u32 = 1;
pub const MCLK_APBAMASK_MCLK_Pos: u32 = 2;
pub const MCLK_APBAMASK_RSTC_Pos: u32 = 3;
pub const MCLK_APBAMASK_OSCCTRL_Pos: u32 = 4;
pub const MCLK_APBAMASK_OSC32KCTRL_Pos: u32 = 5;
pub const MCLK_APBAMASK_SUPC_Pos: u32 = 6;
pub const MCLK_APBAMASK_GCLK_Pos: u32 = 7;
pub const MCLK_APBAMASK_WDT_Pos: u32 = 8;
pub const MCLK_APBAMASK_RTC_Pos: u32 = 9;
pub const MCLK_APBAMASK_EIC_Pos: u32 = 10;
pub const MCLK_APBAMASK_FREQM_Pos: u32 = 11;
pub const MCLK_APBBMASK_OFFSET: u32 = 24;
pub const MCLK_APBBMASK_USB_Pos: u32 = 0;
pub const MCLK_APBBMASK_DSU_Pos: u32 = 1;
pub const MCLK_APBBMASK_NVMCTRL_Pos: u32 = 2;
pub const MCLK_APBBMASK_PORT_Pos: u32 = 3;
pub const MCLK_APBCMASK_OFFSET: u32 = 28;
pub const MCLK_APBCMASK_EVSYS_Pos: u32 = 0;
pub const MCLK_APBCMASK_SERCOM0_Pos: u32 = 1;
pub const MCLK_APBCMASK_SERCOM1_Pos: u32 = 2;
pub const MCLK_APBCMASK_SERCOM2_Pos: u32 = 3;
pub const MCLK_APBCMASK_SERCOM3_Pos: u32 = 4;
pub const MCLK_APBCMASK_SERCOM4_Pos: u32 = 5;
pub const MCLK_APBCMASK_SERCOM5_Pos: u32 = 6;
pub const MCLK_APBCMASK_TCC0_Pos: u32 = 7;
pub const MCLK_APBCMASK_TC0_Pos: u32 = 8;
pub const MCLK_APBCMASK_TC1_Pos: u32 = 9;
pub const MCLK_APBCMASK_TC2_Pos: u32 = 10;
pub const MCLK_APBCMASK_TC3_Pos: u32 = 11;
pub const MCLK_APBCMASK_ADC_Pos: u32 = 12;
pub const MCLK_APBCMASK_AC_Pos: u32 = 13;
pub const MCLK_APBCMASK_PTC_Pos: u32 = 14;
pub const MCLK_APBCMASK_SLCD_Pos: u32 = 15;
pub const MCLK_APBCMASK_AES_Pos: u32 = 16;
pub const MCLK_APBCMASK_TRNG_Pos: u32 = 17;
pub const MCLK_APBCMASK_CCL_Pos: u32 = 18;
pub const REV_MTB: u32 = 256;
pub const MTB_POSITION_OFFSET: u32 = 0;
pub const MTB_POSITION_WRAP_Pos: u32 = 2;
pub const MTB_POSITION_POINTER_Pos: u32 = 3;
pub const MTB_MASTER_OFFSET: u32 = 4;
pub const MTB_MASTER_MASK_Pos: u32 = 0;
pub const MTB_MASTER_TSTARTEN_Pos: u32 = 5;
pub const MTB_MASTER_TSTOPEN_Pos: u32 = 6;
pub const MTB_MASTER_SFRWPRIV_Pos: u32 = 7;
pub const MTB_MASTER_RAMPRIV_Pos: u32 = 8;
pub const MTB_MASTER_HALTREQ_Pos: u32 = 9;
pub const MTB_MASTER_EN_Pos: u32 = 31;
pub const MTB_FLOW_OFFSET: u32 = 8;
pub const MTB_FLOW_AUTOSTOP_Pos: u32 = 0;
pub const MTB_FLOW_AUTOHALT_Pos: u32 = 1;
pub const MTB_FLOW_WATERMARK_Pos: u32 = 3;
pub const MTB_BASE_OFFSET: u32 = 12;
pub const MTB_ITCTRL_OFFSET: u32 = 3840;
pub const MTB_CLAIMSET_OFFSET: u32 = 4000;
pub const MTB_CLAIMCLR_OFFSET: u32 = 4004;
pub const MTB_LOCKACCESS_OFFSET: u32 = 4016;
pub const MTB_LOCKSTATUS_OFFSET: u32 = 4020;
pub const MTB_AUTHSTATUS_OFFSET: u32 = 4024;
pub const MTB_DEVARCH_OFFSET: u32 = 4028;
pub const MTB_DEVID_OFFSET: u32 = 4040;
pub const MTB_DEVTYPE_OFFSET: u32 = 4044;
pub const MTB_PID4_OFFSET: u32 = 4048;
pub const MTB_PID5_OFFSET: u32 = 4052;
pub const MTB_PID6_OFFSET: u32 = 4056;
pub const MTB_PID7_OFFSET: u32 = 4060;
pub const MTB_PID0_OFFSET: u32 = 4064;
pub const MTB_PID1_OFFSET: u32 = 4068;
pub const MTB_PID2_OFFSET: u32 = 4072;
pub const MTB_PID3_OFFSET: u32 = 4076;
pub const MTB_CID0_OFFSET: u32 = 4080;
pub const MTB_CID1_OFFSET: u32 = 4084;
pub const MTB_CID2_OFFSET: u32 = 4088;
pub const MTB_CID3_OFFSET: u32 = 4092;
pub const REV_NVMCTRL: u32 = 770;
pub const NVMCTRL_CTRLA_OFFSET: u32 = 0;
pub const NVMCTRL_CTRLA_CMD_Pos: u32 = 0;
pub const NVMCTRL_CTRLA_CMDEX_Pos: u32 = 8;
pub const NVMCTRL_CTRLB_OFFSET: u32 = 4;
pub const NVMCTRL_CTRLB_RWS_Pos: u32 = 1;
pub const NVMCTRL_CTRLB_MANW_Pos: u32 = 7;
pub const NVMCTRL_CTRLB_SLEEPPRM_Pos: u32 = 8;
pub const NVMCTRL_CTRLB_FWUP_Pos: u32 = 11;
pub const NVMCTRL_CTRLB_READMODE_Pos: u32 = 16;
pub const NVMCTRL_CTRLB_CACHEDIS_Pos: u32 = 18;
pub const NVMCTRL_PARAM_OFFSET: u32 = 8;
pub const NVMCTRL_PARAM_NVMP_Pos: u32 = 0;
pub const NVMCTRL_PARAM_PSZ_Pos: u32 = 16;
pub const NVMCTRL_PARAM_RWWEEP_Pos: u32 = 20;
pub const NVMCTRL_INTENCLR_OFFSET: u32 = 12;
pub const NVMCTRL_INTENCLR_READY_Pos: u32 = 0;
pub const NVMCTRL_INTENCLR_ERROR_Pos: u32 = 1;
pub const NVMCTRL_INTENSET_OFFSET: u32 = 16;
pub const NVMCTRL_INTENSET_READY_Pos: u32 = 0;
pub const NVMCTRL_INTENSET_ERROR_Pos: u32 = 1;
pub const NVMCTRL_INTFLAG_OFFSET: u32 = 20;
pub const NVMCTRL_INTFLAG_READY_Pos: u32 = 0;
pub const NVMCTRL_INTFLAG_ERROR_Pos: u32 = 1;
pub const NVMCTRL_STATUS_OFFSET: u32 = 24;
pub const NVMCTRL_STATUS_PRM_Pos: u32 = 0;
pub const NVMCTRL_STATUS_LOAD_Pos: u32 = 1;
pub const NVMCTRL_STATUS_PROGE_Pos: u32 = 2;
pub const NVMCTRL_STATUS_LOCKE_Pos: u32 = 3;
pub const NVMCTRL_STATUS_NVME_Pos: u32 = 4;
pub const NVMCTRL_STATUS_SB_Pos: u32 = 8;
pub const NVMCTRL_ADDR_OFFSET: u32 = 28;
pub const NVMCTRL_ADDR_ADDR_Pos: u32 = 0;
pub const NVMCTRL_LOCK_OFFSET: u32 = 32;
pub const NVMCTRL_LOCK_LOCK_Pos: u32 = 0;
pub const ADC_FUSES_BIASCOMP_Pos: u32 = 3;
pub const ADC_FUSES_BIASREFBUF_Pos: u32 = 0;
pub const FUSES_BOD12_HYST_Pos: u32 = 10;
pub const FUSES_BOD33USERLEVEL_Pos: u32 = 8;
pub const FUSES_BOD33_ACTION_Pos: u32 = 15;
pub const FUSES_BOD33_DIS_Pos: u32 = 14;
pub const FUSES_BOD33_HYST_Pos: u32 = 9;
pub const FUSES_DFLL48M_COARSE_CAL_Pos: u32 = 26;
pub const FUSES_HOT_ADC_VAL_CTAT_Pos: u32 = 12;
pub const FUSES_HOT_ADC_VAL_PTAT_Pos: u32 = 20;
pub const FUSES_HOT_INT1V_VAL_Pos: u32 = 0;
pub const FUSES_HOT_TEMP_VAL_DEC_Pos: u32 = 20;
pub const FUSES_HOT_TEMP_VAL_INT_Pos: u32 = 12;
pub const FUSES_ROOM_ADC_VAL_CTAT_Pos: u32 = 0;
pub const FUSES_ROOM_ADC_VAL_PTAT_Pos: u32 = 8;
pub const FUSES_ROOM_INT1V_VAL_Pos: u32 = 24;
pub const FUSES_ROOM_TEMP_VAL_DEC_Pos: u32 = 8;
pub const FUSES_ROOM_TEMP_VAL_INT_Pos: u32 = 0;
pub const NVMCTRL_FUSES_BOOTPROT_Pos: u32 = 0;
pub const NVMCTRL_FUSES_EEPROM_SIZE_Pos: u32 = 4;
pub const NVMCTRL_FUSES_REGION_LOCKS_Pos: u32 = 16;
pub const USB_FUSES_TRANSN_Pos: u32 = 13;
pub const USB_FUSES_TRANSP_Pos: u32 = 18;
pub const USB_FUSES_TRIM_Pos: u32 = 23;
pub const WDT_FUSES_ALWAYSON_Pos: u32 = 27;
pub const WDT_FUSES_ENABLE_Pos: u32 = 26;
pub const WDT_FUSES_EWOFFSET_Pos: u32 = 4;
pub const WDT_FUSES_PER_Pos: u32 = 28;
pub const WDT_FUSES_WEN_Pos: u32 = 8;
pub const WDT_FUSES_WINDOW_Pos: u32 = 0;
pub const REV_OSCCTRL: u32 = 768;
pub const OSCCTRL_INTENCLR_OFFSET: u32 = 0;
pub const OSCCTRL_INTENCLR_XOSCRDY_Pos: u32 = 0;
pub const OSCCTRL_INTENCLR_XOSCFAIL_Pos: u32 = 1;
pub const OSCCTRL_INTENCLR_OSC16MRDY_Pos: u32 = 4;
pub const OSCCTRL_INTENCLR_DFLLRDY_Pos: u32 = 8;
pub const OSCCTRL_INTENCLR_DFLLOOB_Pos: u32 = 9;
pub const OSCCTRL_INTENCLR_DFLLLCKF_Pos: u32 = 10;
pub const OSCCTRL_INTENCLR_DFLLLCKC_Pos: u32 = 11;
pub const OSCCTRL_INTENCLR_DFLLRCS_Pos: u32 = 12;
pub const OSCCTRL_INTENCLR_DPLLLCKR_Pos: u32 = 16;
pub const OSCCTRL_INTENCLR_DPLLLCKF_Pos: u32 = 17;
pub const OSCCTRL_INTENCLR_DPLLLTO_Pos: u32 = 18;
pub const OSCCTRL_INTENCLR_DPLLLDRTO_Pos: u32 = 19;
pub const OSCCTRL_INTENSET_OFFSET: u32 = 4;
pub const OSCCTRL_INTENSET_XOSCRDY_Pos: u32 = 0;
pub const OSCCTRL_INTENSET_XOSCFAIL_Pos: u32 = 1;
pub const OSCCTRL_INTENSET_OSC16MRDY_Pos: u32 = 4;
pub const OSCCTRL_INTENSET_DFLLRDY_Pos: u32 = 8;
pub const OSCCTRL_INTENSET_DFLLOOB_Pos: u32 = 9;
pub const OSCCTRL_INTENSET_DFLLLCKF_Pos: u32 = 10;
pub const OSCCTRL_INTENSET_DFLLLCKC_Pos: u32 = 11;
pub const OSCCTRL_INTENSET_DFLLRCS_Pos: u32 = 12;
pub const OSCCTRL_INTENSET_DPLLLCKR_Pos: u32 = 16;
pub const OSCCTRL_INTENSET_DPLLLCKF_Pos: u32 = 17;
pub const OSCCTRL_INTENSET_DPLLLTO_Pos: u32 = 18;
pub const OSCCTRL_INTENSET_DPLLLDRTO_Pos: u32 = 19;
pub const OSCCTRL_INTFLAG_OFFSET: u32 = 8;
pub const OSCCTRL_INTFLAG_XOSCRDY_Pos: u32 = 0;
pub const OSCCTRL_INTFLAG_XOSCFAIL_Pos: u32 = 1;
pub const OSCCTRL_INTFLAG_OSC16MRDY_Pos: u32 = 4;
pub const OSCCTRL_INTFLAG_DFLLRDY_Pos: u32 = 8;
pub const OSCCTRL_INTFLAG_DFLLOOB_Pos: u32 = 9;
pub const OSCCTRL_INTFLAG_DFLLLCKF_Pos: u32 = 10;
pub const OSCCTRL_INTFLAG_DFLLLCKC_Pos: u32 = 11;
pub const OSCCTRL_INTFLAG_DFLLRCS_Pos: u32 = 12;
pub const OSCCTRL_INTFLAG_DPLLLCKR_Pos: u32 = 16;
pub const OSCCTRL_INTFLAG_DPLLLCKF_Pos: u32 = 17;
pub const OSCCTRL_INTFLAG_DPLLLTO_Pos: u32 = 18;
pub const OSCCTRL_INTFLAG_DPLLLDRTO_Pos: u32 = 19;
pub const OSCCTRL_STATUS_OFFSET: u32 = 12;
pub const OSCCTRL_STATUS_XOSCRDY_Pos: u32 = 0;
pub const OSCCTRL_STATUS_XOSCFAIL_Pos: u32 = 1;
pub const OSCCTRL_STATUS_XOSCCKSW_Pos: u32 = 2;
pub const OSCCTRL_STATUS_OSC16MRDY_Pos: u32 = 4;
pub const OSCCTRL_STATUS_DFLLRDY_Pos: u32 = 8;
pub const OSCCTRL_STATUS_DFLLOOB_Pos: u32 = 9;
pub const OSCCTRL_STATUS_DFLLLCKF_Pos: u32 = 10;
pub const OSCCTRL_STATUS_DFLLLCKC_Pos: u32 = 11;
pub const OSCCTRL_STATUS_DFLLRCS_Pos: u32 = 12;
pub const OSCCTRL_STATUS_DPLLLCKR_Pos: u32 = 16;
pub const OSCCTRL_STATUS_DPLLLCKF_Pos: u32 = 17;
pub const OSCCTRL_STATUS_DPLLTO_Pos: u32 = 18;
pub const OSCCTRL_STATUS_DPLLLDRTO_Pos: u32 = 19;
pub const OSCCTRL_XOSCCTRL_OFFSET: u32 = 16;
pub const OSCCTRL_XOSCCTRL_ENABLE_Pos: u32 = 1;
pub const OSCCTRL_XOSCCTRL_XTALEN_Pos: u32 = 2;
pub const OSCCTRL_XOSCCTRL_CFDEN_Pos: u32 = 3;
pub const OSCCTRL_XOSCCTRL_SWBEN_Pos: u32 = 4;
pub const OSCCTRL_XOSCCTRL_RUNSTDBY_Pos: u32 = 6;
pub const OSCCTRL_XOSCCTRL_ONDEMAND_Pos: u32 = 7;
pub const OSCCTRL_XOSCCTRL_GAIN_Pos: u32 = 8;
pub const OSCCTRL_XOSCCTRL_AMPGC_Pos: u32 = 11;
pub const OSCCTRL_XOSCCTRL_STARTUP_Pos: u32 = 12;
pub const OSCCTRL_CFDPRESC_OFFSET: u32 = 18;
pub const OSCCTRL_CFDPRESC_CFDPRESC_Pos: u32 = 0;
pub const OSCCTRL_EVCTRL_OFFSET: u32 = 19;
pub const OSCCTRL_EVCTRL_CFDEO_Pos: u32 = 0;
pub const OSCCTRL_OSC16MCTRL_OFFSET: u32 = 20;
pub const OSCCTRL_OSC16MCTRL_ENABLE_Pos: u32 = 1;
pub const OSCCTRL_OSC16MCTRL_FSEL_Pos: u32 = 2;
pub const OSCCTRL_OSC16MCTRL_RUNSTDBY_Pos: u32 = 6;
pub const OSCCTRL_OSC16MCTRL_ONDEMAND_Pos: u32 = 7;
pub const OSCCTRL_DFLLCTRL_OFFSET: u32 = 24;
pub const OSCCTRL_DFLLCTRL_ENABLE_Pos: u32 = 1;
pub const OSCCTRL_DFLLCTRL_MODE_Pos: u32 = 2;
pub const OSCCTRL_DFLLCTRL_STABLE_Pos: u32 = 3;
pub const OSCCTRL_DFLLCTRL_LLAW_Pos: u32 = 4;
pub const OSCCTRL_DFLLCTRL_USBCRM_Pos: u32 = 5;
pub const OSCCTRL_DFLLCTRL_RUNSTDBY_Pos: u32 = 6;
pub const OSCCTRL_DFLLCTRL_ONDEMAND_Pos: u32 = 7;
pub const OSCCTRL_DFLLCTRL_CCDIS_Pos: u32 = 8;
pub const OSCCTRL_DFLLCTRL_QLDIS_Pos: u32 = 9;
pub const OSCCTRL_DFLLCTRL_BPLCKC_Pos: u32 = 10;
pub const OSCCTRL_DFLLCTRL_WAITLOCK_Pos: u32 = 11;
pub const OSCCTRL_DFLLVAL_OFFSET: u32 = 28;
pub const OSCCTRL_DFLLVAL_FINE_Pos: u32 = 0;
pub const OSCCTRL_DFLLVAL_COARSE_Pos: u32 = 10;
pub const OSCCTRL_DFLLVAL_DIFF_Pos: u32 = 16;
pub const OSCCTRL_DFLLMUL_OFFSET: u32 = 32;
pub const OSCCTRL_DFLLMUL_MUL_Pos: u32 = 0;
pub const OSCCTRL_DFLLMUL_FSTEP_Pos: u32 = 16;
pub const OSCCTRL_DFLLMUL_CSTEP_Pos: u32 = 26;
pub const OSCCTRL_DFLLSYNC_OFFSET: u32 = 36;
pub const OSCCTRL_DFLLSYNC_READREQ_Pos: u32 = 7;
pub const OSCCTRL_DPLLCTRLA_OFFSET: u32 = 40;
pub const OSCCTRL_DPLLCTRLA_ENABLE_Pos: u32 = 1;
pub const OSCCTRL_DPLLCTRLA_RUNSTDBY_Pos: u32 = 6;
pub const OSCCTRL_DPLLCTRLA_ONDEMAND_Pos: u32 = 7;
pub const OSCCTRL_DPLLRATIO_OFFSET: u32 = 44;
pub const OSCCTRL_DPLLRATIO_LDR_Pos: u32 = 0;
pub const OSCCTRL_DPLLRATIO_LDRFRAC_Pos: u32 = 16;
pub const OSCCTRL_DPLLCTRLB_OFFSET: u32 = 48;
pub const OSCCTRL_DPLLCTRLB_FILTER_Pos: u32 = 0;
pub const OSCCTRL_DPLLCTRLB_LPEN_Pos: u32 = 2;
pub const OSCCTRL_DPLLCTRLB_WUF_Pos: u32 = 3;
pub const OSCCTRL_DPLLCTRLB_REFCLK_Pos: u32 = 4;
pub const OSCCTRL_DPLLCTRLB_LTIME_Pos: u32 = 8;
pub const OSCCTRL_DPLLCTRLB_LBYPASS_Pos: u32 = 12;
pub const OSCCTRL_DPLLCTRLB_DIV_Pos: u32 = 16;
pub const OSCCTRL_DPLLPRESC_OFFSET: u32 = 52;
pub const OSCCTRL_DPLLPRESC_PRESC_Pos: u32 = 0;
pub const OSCCTRL_DPLLSYNCBUSY_OFFSET: u32 = 56;
pub const OSCCTRL_DPLLSYNCBUSY_ENABLE_Pos: u32 = 1;
pub const OSCCTRL_DPLLSYNCBUSY_DPLLRATIO_Pos: u32 = 2;
pub const OSCCTRL_DPLLSYNCBUSY_DPLLPRESC_Pos: u32 = 3;
pub const OSCCTRL_DPLLSTATUS_OFFSET: u32 = 60;
pub const OSCCTRL_DPLLSTATUS_LOCK_Pos: u32 = 0;
pub const OSCCTRL_DPLLSTATUS_CLKRDY_Pos: u32 = 1;
pub const REV_OSC32KCTRL: u32 = 768;
pub const OSC32KCTRL_INTENCLR_OFFSET: u32 = 0;
pub const OSC32KCTRL_INTENCLR_XOSC32KRDY_Pos: u32 = 0;
pub const OSC32KCTRL_INTENCLR_CLKFAIL_Pos: u32 = 2;
pub const OSC32KCTRL_INTENSET_OFFSET: u32 = 4;
pub const OSC32KCTRL_INTENSET_XOSC32KRDY_Pos: u32 = 0;
pub const OSC32KCTRL_INTENSET_CLKFAIL_Pos: u32 = 2;
pub const OSC32KCTRL_INTFLAG_OFFSET: u32 = 8;
pub const OSC32KCTRL_INTFLAG_XOSC32KRDY_Pos: u32 = 0;
pub const OSC32KCTRL_INTFLAG_CLKFAIL_Pos: u32 = 2;
pub const OSC32KCTRL_STATUS_OFFSET: u32 = 12;
pub const OSC32KCTRL_STATUS_XOSC32KRDY_Pos: u32 = 0;
pub const OSC32KCTRL_STATUS_CLKFAIL_Pos: u32 = 2;
pub const OSC32KCTRL_STATUS_CLKSW_Pos: u32 = 3;
pub const OSC32KCTRL_RTCCTRL_OFFSET: u32 = 16;
pub const OSC32KCTRL_RTCCTRL_RTCSEL_Pos: u32 = 0;
pub const OSC32KCTRL_SLCDCTRL_OFFSET: u32 = 17;
pub const OSC32KCTRL_SLCDCTRL_SLCDSEL_Pos: u32 = 0;
pub const OSC32KCTRL_XOSC32K_OFFSET: u32 = 20;
pub const OSC32KCTRL_XOSC32K_ENABLE_Pos: u32 = 1;
pub const OSC32KCTRL_XOSC32K_XTALEN_Pos: u32 = 2;
pub const OSC32KCTRL_XOSC32K_EN32K_Pos: u32 = 3;
pub const OSC32KCTRL_XOSC32K_EN1K_Pos: u32 = 4;
pub const OSC32KCTRL_XOSC32K_RUNSTDBY_Pos: u32 = 6;
pub const OSC32KCTRL_XOSC32K_ONDEMAND_Pos: u32 = 7;
pub const OSC32KCTRL_XOSC32K_STARTUP_Pos: u32 = 8;
pub const OSC32KCTRL_XOSC32K_WRTLOCK_Pos: u32 = 12;
pub const OSC32KCTRL_CFDCTRL_OFFSET: u32 = 22;
pub const OSC32KCTRL_CFDCTRL_CFDEN_Pos: u32 = 0;
pub const OSC32KCTRL_CFDCTRL_SWBACK_Pos: u32 = 1;
pub const OSC32KCTRL_CFDCTRL_CFDPRESC_Pos: u32 = 2;
pub const OSC32KCTRL_EVCTRL_OFFSET: u32 = 23;
pub const OSC32KCTRL_EVCTRL_CFDEO_Pos: u32 = 0;
pub const OSC32KCTRL_OSCULP32K_OFFSET: u32 = 28;
pub const OSC32KCTRL_OSCULP32K_EN32K_Pos: u32 = 1;
pub const OSC32KCTRL_OSCULP32K_EN1K_Pos: u32 = 2;
pub const OSC32KCTRL_OSCULP32K_CALIB_Pos: u32 = 8;
pub const OSC32KCTRL_OSCULP32K_WRTLOCK_Pos: u32 = 15;
pub const REV_PAC: u32 = 272;
pub const PAC_WRCTRL_OFFSET: u32 = 0;
pub const PAC_WRCTRL_PERID_Pos: u32 = 0;
pub const PAC_WRCTRL_KEY_Pos: u32 = 16;
pub const PAC_EVCTRL_OFFSET: u32 = 4;
pub const PAC_EVCTRL_ERREO_Pos: u32 = 0;
pub const PAC_INTENCLR_OFFSET: u32 = 8;
pub const PAC_INTENCLR_ERR_Pos: u32 = 0;
pub const PAC_INTENSET_OFFSET: u32 = 9;
pub const PAC_INTENSET_ERR_Pos: u32 = 0;
pub const PAC_INTFLAGAHB_OFFSET: u32 = 16;
pub const PAC_INTFLAGAHB_FLASH_Pos: u32 = 0;
pub const PAC_INTFLAGAHB_HSRAMCM0P_Pos: u32 = 1;
pub const PAC_INTFLAGAHB_HSRAMDSU_Pos: u32 = 2;
pub const PAC_INTFLAGAHB_HPB1_Pos: u32 = 3;
pub const PAC_INTFLAGAHB_HPB0_Pos: u32 = 4;
pub const PAC_INTFLAGAHB_HPB2_Pos: u32 = 5;
pub const PAC_INTFLAGAHB_HSRAMDMAC_Pos: u32 = 6;
pub const PAC_INTFLAGA_OFFSET: u32 = 20;
pub const PAC_INTFLAGA_PAC_Pos: u32 = 0;
pub const PAC_INTFLAGA_PM_Pos: u32 = 1;
pub const PAC_INTFLAGA_MCLK_Pos: u32 = 2;
pub const PAC_INTFLAGA_RSTC_Pos: u32 = 3;
pub const PAC_INTFLAGA_OSCCTRL_Pos: u32 = 4;
pub const PAC_INTFLAGA_OSC32KCTRL_Pos: u32 = 5;
pub const PAC_INTFLAGA_SUPC_Pos: u32 = 6;
pub const PAC_INTFLAGA_GCLK_Pos: u32 = 7;
pub const PAC_INTFLAGA_WDT_Pos: u32 = 8;
pub const PAC_INTFLAGA_RTC_Pos: u32 = 9;
pub const PAC_INTFLAGA_EIC_Pos: u32 = 10;
pub const PAC_INTFLAGA_FREQM_Pos: u32 = 11;
pub const PAC_INTFLAGB_OFFSET: u32 = 24;
pub const PAC_INTFLAGB_USB_Pos: u32 = 0;
pub const PAC_INTFLAGB_DSU_Pos: u32 = 1;
pub const PAC_INTFLAGB_NVMCTRL_Pos: u32 = 2;
pub const PAC_INTFLAGB_PORT_Pos: u32 = 3;
pub const PAC_INTFLAGB_DMAC_Pos: u32 = 4;
pub const PAC_INTFLAGB_MTB_Pos: u32 = 5;
pub const PAC_INTFLAGC_OFFSET: u32 = 28;
pub const PAC_INTFLAGC_EVSYS_Pos: u32 = 0;
pub const PAC_INTFLAGC_SERCOM0_Pos: u32 = 1;
pub const PAC_INTFLAGC_SERCOM1_Pos: u32 = 2;
pub const PAC_INTFLAGC_SERCOM2_Pos: u32 = 3;
pub const PAC_INTFLAGC_SERCOM3_Pos: u32 = 4;
pub const PAC_INTFLAGC_SERCOM4_Pos: u32 = 5;
pub const PAC_INTFLAGC_SERCOM5_Pos: u32 = 6;
pub const PAC_INTFLAGC_TCC0_Pos: u32 = 7;
pub const PAC_INTFLAGC_TC0_Pos: u32 = 8;
pub const PAC_INTFLAGC_TC1_Pos: u32 = 9;
pub const PAC_INTFLAGC_TC2_Pos: u32 = 10;
pub const PAC_INTFLAGC_TC3_Pos: u32 = 11;
pub const PAC_INTFLAGC_ADC_Pos: u32 = 12;
pub const PAC_INTFLAGC_AC_Pos: u32 = 13;
pub const PAC_INTFLAGC_PTC_Pos: u32 = 14;
pub const PAC_INTFLAGC_SLCD_Pos: u32 = 15;
pub const PAC_INTFLAGC_AES_Pos: u32 = 16;
pub const PAC_INTFLAGC_TRNG_Pos: u32 = 17;
pub const PAC_INTFLAGC_CCL_Pos: u32 = 18;
pub const PAC_STATUSA_OFFSET: u32 = 52;
pub const PAC_STATUSA_PAC_Pos: u32 = 0;
pub const PAC_STATUSA_PM_Pos: u32 = 1;
pub const PAC_STATUSA_MCLK_Pos: u32 = 2;
pub const PAC_STATUSA_RSTC_Pos: u32 = 3;
pub const PAC_STATUSA_OSCCTRL_Pos: u32 = 4;
pub const PAC_STATUSA_OSC32KCTRL_Pos: u32 = 5;
pub const PAC_STATUSA_SUPC_Pos: u32 = 6;
pub const PAC_STATUSA_GCLK_Pos: u32 = 7;
pub const PAC_STATUSA_WDT_Pos: u32 = 8;
pub const PAC_STATUSA_RTC_Pos: u32 = 9;
pub const PAC_STATUSA_EIC_Pos: u32 = 10;
pub const PAC_STATUSA_FREQM_Pos: u32 = 11;
pub const PAC_STATUSB_OFFSET: u32 = 56;
pub const PAC_STATUSB_USB_Pos: u32 = 0;
pub const PAC_STATUSB_DSU_Pos: u32 = 1;
pub const PAC_STATUSB_NVMCTRL_Pos: u32 = 2;
pub const PAC_STATUSB_PORT_Pos: u32 = 3;
pub const PAC_STATUSB_DMAC_Pos: u32 = 4;
pub const PAC_STATUSB_MTB_Pos: u32 = 5;
pub const PAC_STATUSC_OFFSET: u32 = 60;
pub const PAC_STATUSC_EVSYS_Pos: u32 = 0;
pub const PAC_STATUSC_SERCOM0_Pos: u32 = 1;
pub const PAC_STATUSC_SERCOM1_Pos: u32 = 2;
pub const PAC_STATUSC_SERCOM2_Pos: u32 = 3;
pub const PAC_STATUSC_SERCOM3_Pos: u32 = 4;
pub const PAC_STATUSC_SERCOM4_Pos: u32 = 5;
pub const PAC_STATUSC_SERCOM5_Pos: u32 = 6;
pub const PAC_STATUSC_TCC0_Pos: u32 = 7;
pub const PAC_STATUSC_TC0_Pos: u32 = 8;
pub const PAC_STATUSC_TC1_Pos: u32 = 9;
pub const PAC_STATUSC_TC2_Pos: u32 = 10;
pub const PAC_STATUSC_TC3_Pos: u32 = 11;
pub const PAC_STATUSC_ADC_Pos: u32 = 12;
pub const PAC_STATUSC_AC_Pos: u32 = 13;
pub const PAC_STATUSC_PTC_Pos: u32 = 14;
pub const PAC_STATUSC_SLCD_Pos: u32 = 15;
pub const PAC_STATUSC_AES_Pos: u32 = 16;
pub const PAC_STATUSC_TRNG_Pos: u32 = 17;
pub const PAC_STATUSC_CCL_Pos: u32 = 18;
pub const REV_PM: u32 = 529;
pub const PM_CTRLA_OFFSET: u32 = 0;
pub const PM_CTRLA_IORET_Pos: u32 = 2;
pub const PM_SLEEPCFG_OFFSET: u32 = 1;
pub const PM_SLEEPCFG_SLEEPMODE_Pos: u32 = 0;
pub const PM_PLCFG_OFFSET: u32 = 2;
pub const PM_PLCFG_PLSEL_Pos: u32 = 0;
pub const PM_PLCFG_PLDIS_Pos: u32 = 7;
pub const PM_INTENCLR_OFFSET: u32 = 4;
pub const PM_INTENCLR_PLRDY_Pos: u32 = 0;
pub const PM_INTENSET_OFFSET: u32 = 5;
pub const PM_INTENSET_PLRDY_Pos: u32 = 0;
pub const PM_INTFLAG_OFFSET: u32 = 6;
pub const PM_INTFLAG_PLRDY_Pos: u32 = 0;
pub const PM_STDBYCFG_OFFSET: u32 = 8;
pub const PM_STDBYCFG_VREGSMOD_Pos: u32 = 6;
pub const PM_STDBYCFG_BBIASHS_Pos: u32 = 10;
pub const REV_PORT: u32 = 529;
pub const PORT_DIR_OFFSET: u32 = 0;
pub const PORT_DIRCLR_OFFSET: u32 = 4;
pub const PORT_DIRSET_OFFSET: u32 = 8;
pub const PORT_DIRTGL_OFFSET: u32 = 12;
pub const PORT_OUT_OFFSET: u32 = 16;
pub const PORT_OUTCLR_OFFSET: u32 = 20;
pub const PORT_OUTSET_OFFSET: u32 = 24;
pub const PORT_OUTTGL_OFFSET: u32 = 28;
pub const PORT_IN_OFFSET: u32 = 32;
pub const PORT_CTRL_OFFSET: u32 = 36;
pub const PORT_CTRL_SAMPLING_Pos: u32 = 0;
pub const PORT_WRCONFIG_OFFSET: u32 = 40;
pub const PORT_WRCONFIG_PINMASK_Pos: u32 = 0;
pub const PORT_WRCONFIG_PMUXEN_Pos: u32 = 16;
pub const PORT_WRCONFIG_INEN_Pos: u32 = 17;
pub const PORT_WRCONFIG_PULLEN_Pos: u32 = 18;
pub const PORT_WRCONFIG_DRVSTR_Pos: u32 = 22;
pub const PORT_WRCONFIG_PMUX_Pos: u32 = 24;
pub const PORT_WRCONFIG_WRPMUX_Pos: u32 = 28;
pub const PORT_WRCONFIG_WRPINCFG_Pos: u32 = 30;
pub const PORT_WRCONFIG_HWSEL_Pos: u32 = 31;
pub const PORT_EVCTRL_OFFSET: u32 = 44;
pub const PORT_EVCTRL_PID0_Pos: u32 = 0;
pub const PORT_EVCTRL_EVACT0_Pos: u32 = 5;
pub const PORT_EVCTRL_PORTEI0_Pos: u32 = 7;
pub const PORT_EVCTRL_PID1_Pos: u32 = 8;
pub const PORT_EVCTRL_EVACT1_Pos: u32 = 13;
pub const PORT_EVCTRL_PORTEI1_Pos: u32 = 15;
pub const PORT_EVCTRL_PID2_Pos: u32 = 16;
pub const PORT_EVCTRL_EVACT2_Pos: u32 = 21;
pub const PORT_EVCTRL_PORTEI2_Pos: u32 = 23;
pub const PORT_EVCTRL_PID3_Pos: u32 = 24;
pub const PORT_EVCTRL_EVACT3_Pos: u32 = 29;
pub const PORT_EVCTRL_PORTEI3_Pos: u32 = 31;
pub const PORT_PMUX_OFFSET: u32 = 48;
pub const PORT_PMUX_PMUXE_Pos: u32 = 0;
pub const PORT_PMUX_PMUXO_Pos: u32 = 4;
pub const PORT_PINCFG_OFFSET: u32 = 64;
pub const PORT_PINCFG_PMUXEN_Pos: u32 = 0;
pub const PORT_PINCFG_INEN_Pos: u32 = 1;
pub const PORT_PINCFG_PULLEN_Pos: u32 = 2;
pub const PORT_PINCFG_DRVSTR_Pos: u32 = 6;
pub const REV_RSTC: u32 = 768;
pub const RSTC_RCAUSE_OFFSET: u32 = 0;
pub const RSTC_RCAUSE_POR_Pos: u32 = 0;
pub const RSTC_RCAUSE_BODCORE_Pos: u32 = 1;
pub const RSTC_RCAUSE_BODVDD_Pos: u32 = 2;
pub const RSTC_RCAUSE_EXT_Pos: u32 = 4;
pub const RSTC_RCAUSE_WDT_Pos: u32 = 5;
pub const RSTC_RCAUSE_SYST_Pos: u32 = 6;
pub const RSTC_RCAUSE_BACKUP_Pos: u32 = 7;
pub const RSTC_BKUPEXIT_OFFSET: u32 = 2;
pub const RSTC_BKUPEXIT_EXTWAKE_Pos: u32 = 0;
pub const RSTC_BKUPEXIT_RTC_Pos: u32 = 1;
pub const RSTC_BKUPEXIT_BBPS_Pos: u32 = 2;
pub const REV_RTC: u32 = 513;
pub const RTC_MODE0_CTRLA_OFFSET: u32 = 0;
pub const RTC_MODE0_CTRLA_SWRST_Pos: u32 = 0;
pub const RTC_MODE0_CTRLA_ENABLE_Pos: u32 = 1;
pub const RTC_MODE0_CTRLA_MODE_Pos: u32 = 2;
pub const RTC_MODE0_CTRLA_MATCHCLR_Pos: u32 = 7;
pub const RTC_MODE0_CTRLA_PRESCALER_Pos: u32 = 8;
pub const RTC_MODE0_CTRLA_BKTRST_Pos: u32 = 13;
pub const RTC_MODE0_CTRLA_GPTRST_Pos: u32 = 14;
pub const RTC_MODE0_CTRLA_COUNTSYNC_Pos: u32 = 15;
pub const RTC_MODE1_CTRLA_OFFSET: u32 = 0;
pub const RTC_MODE1_CTRLA_SWRST_Pos: u32 = 0;
pub const RTC_MODE1_CTRLA_ENABLE_Pos: u32 = 1;
pub const RTC_MODE1_CTRLA_MODE_Pos: u32 = 2;
pub const RTC_MODE1_CTRLA_PRESCALER_Pos: u32 = 8;
pub const RTC_MODE1_CTRLA_BKTRST_Pos: u32 = 13;
pub const RTC_MODE1_CTRLA_GPTRST_Pos: u32 = 14;
pub const RTC_MODE1_CTRLA_COUNTSYNC_Pos: u32 = 15;
pub const RTC_MODE2_CTRLA_OFFSET: u32 = 0;
pub const RTC_MODE2_CTRLA_SWRST_Pos: u32 = 0;
pub const RTC_MODE2_CTRLA_ENABLE_Pos: u32 = 1;
pub const RTC_MODE2_CTRLA_MODE_Pos: u32 = 2;
pub const RTC_MODE2_CTRLA_CLKREP_Pos: u32 = 6;
pub const RTC_MODE2_CTRLA_MATCHCLR_Pos: u32 = 7;
pub const RTC_MODE2_CTRLA_PRESCALER_Pos: u32 = 8;
pub const RTC_MODE2_CTRLA_BKTRST_Pos: u32 = 13;
pub const RTC_MODE2_CTRLA_GPTRST_Pos: u32 = 14;
pub const RTC_MODE2_CTRLA_CLOCKSYNC_Pos: u32 = 15;
pub const RTC_MODE0_CTRLB_OFFSET: u32 = 2;
pub const RTC_MODE0_CTRLB_GP0EN_Pos: u32 = 0;
pub const RTC_MODE0_CTRLB_DEBMAJ_Pos: u32 = 4;
pub const RTC_MODE0_CTRLB_DEBASYNC_Pos: u32 = 5;
pub const RTC_MODE0_CTRLB_RTCOUT_Pos: u32 = 6;
pub const RTC_MODE0_CTRLB_DMAEN_Pos: u32 = 7;
pub const RTC_MODE0_CTRLB_DEBF_Pos: u32 = 8;
pub const RTC_MODE0_CTRLB_ACTF_Pos: u32 = 12;
pub const RTC_MODE1_CTRLB_OFFSET: u32 = 2;
pub const RTC_MODE1_CTRLB_GP0EN_Pos: u32 = 0;
pub const RTC_MODE1_CTRLB_DEBMAJ_Pos: u32 = 4;
pub const RTC_MODE1_CTRLB_DEBASYNC_Pos: u32 = 5;
pub const RTC_MODE1_CTRLB_RTCOUT_Pos: u32 = 6;
pub const RTC_MODE1_CTRLB_DMAEN_Pos: u32 = 7;
pub const RTC_MODE1_CTRLB_DEBF_Pos: u32 = 8;
pub const RTC_MODE1_CTRLB_ACTF_Pos: u32 = 12;
pub const RTC_MODE2_CTRLB_OFFSET: u32 = 2;
pub const RTC_MODE2_CTRLB_GP0EN_Pos: u32 = 0;
pub const RTC_MODE2_CTRLB_DEBMAJ_Pos: u32 = 4;
pub const RTC_MODE2_CTRLB_DEBASYNC_Pos: u32 = 5;
pub const RTC_MODE2_CTRLB_RTCOUT_Pos: u32 = 6;
pub const RTC_MODE2_CTRLB_DMAEN_Pos: u32 = 7;
pub const RTC_MODE2_CTRLB_DEBF_Pos: u32 = 8;
pub const RTC_MODE2_CTRLB_ACTF_Pos: u32 = 12;
pub const RTC_MODE0_EVCTRL_OFFSET: u32 = 4;
pub const RTC_MODE0_EVCTRL_PEREO0_Pos: u32 = 0;
pub const RTC_MODE0_EVCTRL_PEREO1_Pos: u32 = 1;
pub const RTC_MODE0_EVCTRL_PEREO2_Pos: u32 = 2;
pub const RTC_MODE0_EVCTRL_PEREO3_Pos: u32 = 3;
pub const RTC_MODE0_EVCTRL_PEREO4_Pos: u32 = 4;
pub const RTC_MODE0_EVCTRL_PEREO5_Pos: u32 = 5;
pub const RTC_MODE0_EVCTRL_PEREO6_Pos: u32 = 6;
pub const RTC_MODE0_EVCTRL_PEREO7_Pos: u32 = 7;
pub const RTC_MODE0_EVCTRL_PEREO_Pos: u32 = 0;
pub const RTC_MODE0_EVCTRL_CMPEO0_Pos: u32 = 8;
pub const RTC_MODE0_EVCTRL_CMPEO_Pos: u32 = 8;
pub const RTC_MODE0_EVCTRL_TAMPEREO_Pos: u32 = 14;
pub const RTC_MODE0_EVCTRL_OVFEO_Pos: u32 = 15;
pub const RTC_MODE0_EVCTRL_TAMPEVEI_Pos: u32 = 16;
pub const RTC_MODE1_EVCTRL_OFFSET: u32 = 4;
pub const RTC_MODE1_EVCTRL_PEREO0_Pos: u32 = 0;
pub const RTC_MODE1_EVCTRL_PEREO1_Pos: u32 = 1;
pub const RTC_MODE1_EVCTRL_PEREO2_Pos: u32 = 2;
pub const RTC_MODE1_EVCTRL_PEREO3_Pos: u32 = 3;
pub const RTC_MODE1_EVCTRL_PEREO4_Pos: u32 = 4;
pub const RTC_MODE1_EVCTRL_PEREO5_Pos: u32 = 5;
pub const RTC_MODE1_EVCTRL_PEREO6_Pos: u32 = 6;
pub const RTC_MODE1_EVCTRL_PEREO7_Pos: u32 = 7;
pub const RTC_MODE1_EVCTRL_PEREO_Pos: u32 = 0;
pub const RTC_MODE1_EVCTRL_CMPEO0_Pos: u32 = 8;
pub const RTC_MODE1_EVCTRL_CMPEO1_Pos: u32 = 9;
pub const RTC_MODE1_EVCTRL_CMPEO_Pos: u32 = 8;
pub const RTC_MODE1_EVCTRL_TAMPEREO_Pos: u32 = 14;
pub const RTC_MODE1_EVCTRL_OVFEO_Pos: u32 = 15;
pub const RTC_MODE1_EVCTRL_TAMPEVEI_Pos: u32 = 16;
pub const RTC_MODE2_EVCTRL_OFFSET: u32 = 4;
pub const RTC_MODE2_EVCTRL_PEREO0_Pos: u32 = 0;
pub const RTC_MODE2_EVCTRL_PEREO1_Pos: u32 = 1;
pub const RTC_MODE2_EVCTRL_PEREO2_Pos: u32 = 2;
pub const RTC_MODE2_EVCTRL_PEREO3_Pos: u32 = 3;
pub const RTC_MODE2_EVCTRL_PEREO4_Pos: u32 = 4;
pub const RTC_MODE2_EVCTRL_PEREO5_Pos: u32 = 5;
pub const RTC_MODE2_EVCTRL_PEREO6_Pos: u32 = 6;
pub const RTC_MODE2_EVCTRL_PEREO7_Pos: u32 = 7;
pub const RTC_MODE2_EVCTRL_PEREO_Pos: u32 = 0;
pub const RTC_MODE2_EVCTRL_ALARMEO0_Pos: u32 = 8;
pub const RTC_MODE2_EVCTRL_ALARMEO_Pos: u32 = 8;
pub const RTC_MODE2_EVCTRL_TAMPEREO_Pos: u32 = 14;
pub const RTC_MODE2_EVCTRL_OVFEO_Pos: u32 = 15;
pub const RTC_MODE2_EVCTRL_TAMPEVEI_Pos: u32 = 16;
pub const RTC_MODE0_INTENCLR_OFFSET: u32 = 8;
pub const RTC_MODE0_INTENCLR_PER0_Pos: u32 = 0;
pub const RTC_MODE0_INTENCLR_PER1_Pos: u32 = 1;
pub const RTC_MODE0_INTENCLR_PER2_Pos: u32 = 2;
pub const RTC_MODE0_INTENCLR_PER3_Pos: u32 = 3;
pub const RTC_MODE0_INTENCLR_PER4_Pos: u32 = 4;
pub const RTC_MODE0_INTENCLR_PER5_Pos: u32 = 5;
pub const RTC_MODE0_INTENCLR_PER6_Pos: u32 = 6;
pub const RTC_MODE0_INTENCLR_PER7_Pos: u32 = 7;
pub const RTC_MODE0_INTENCLR_PER_Pos: u32 = 0;
pub const RTC_MODE0_INTENCLR_CMP0_Pos: u32 = 8;
pub const RTC_MODE0_INTENCLR_CMP_Pos: u32 = 8;
pub const RTC_MODE0_INTENCLR_TAMPER_Pos: u32 = 14;
pub const RTC_MODE0_INTENCLR_OVF_Pos: u32 = 15;
pub const RTC_MODE1_INTENCLR_OFFSET: u32 = 8;
pub const RTC_MODE1_INTENCLR_PER0_Pos: u32 = 0;
pub const RTC_MODE1_INTENCLR_PER1_Pos: u32 = 1;
pub const RTC_MODE1_INTENCLR_PER2_Pos: u32 = 2;
pub const RTC_MODE1_INTENCLR_PER3_Pos: u32 = 3;
pub const RTC_MODE1_INTENCLR_PER4_Pos: u32 = 4;
pub const RTC_MODE1_INTENCLR_PER5_Pos: u32 = 5;
pub const RTC_MODE1_INTENCLR_PER6_Pos: u32 = 6;
pub const RTC_MODE1_INTENCLR_PER7_Pos: u32 = 7;
pub const RTC_MODE1_INTENCLR_PER_Pos: u32 = 0;
pub const RTC_MODE1_INTENCLR_CMP0_Pos: u32 = 8;
pub const RTC_MODE1_INTENCLR_CMP1_Pos: u32 = 9;
pub const RTC_MODE1_INTENCLR_CMP_Pos: u32 = 8;
pub const RTC_MODE1_INTENCLR_TAMPER_Pos: u32 = 14;
pub const RTC_MODE1_INTENCLR_OVF_Pos: u32 = 15;
pub const RTC_MODE2_INTENCLR_OFFSET: u32 = 8;
pub const RTC_MODE2_INTENCLR_PER0_Pos: u32 = 0;
pub const RTC_MODE2_INTENCLR_PER1_Pos: u32 = 1;
pub const RTC_MODE2_INTENCLR_PER2_Pos: u32 = 2;
pub const RTC_MODE2_INTENCLR_PER3_Pos: u32 = 3;
pub const RTC_MODE2_INTENCLR_PER4_Pos: u32 = 4;
pub const RTC_MODE2_INTENCLR_PER5_Pos: u32 = 5;
pub const RTC_MODE2_INTENCLR_PER6_Pos: u32 = 6;
pub const RTC_MODE2_INTENCLR_PER7_Pos: u32 = 7;
pub const RTC_MODE2_INTENCLR_PER_Pos: u32 = 0;
pub const RTC_MODE2_INTENCLR_ALARM0_Pos: u32 = 8;
pub const RTC_MODE2_INTENCLR_ALARM_Pos: u32 = 8;
pub const RTC_MODE2_INTENCLR_TAMPER_Pos: u32 = 14;
pub const RTC_MODE2_INTENCLR_OVF_Pos: u32 = 15;
pub const RTC_MODE0_INTENSET_OFFSET: u32 = 10;
pub const RTC_MODE0_INTENSET_PER0_Pos: u32 = 0;
pub const RTC_MODE0_INTENSET_PER1_Pos: u32 = 1;
pub const RTC_MODE0_INTENSET_PER2_Pos: u32 = 2;
pub const RTC_MODE0_INTENSET_PER3_Pos: u32 = 3;
pub const RTC_MODE0_INTENSET_PER4_Pos: u32 = 4;
pub const RTC_MODE0_INTENSET_PER5_Pos: u32 = 5;
pub const RTC_MODE0_INTENSET_PER6_Pos: u32 = 6;
pub const RTC_MODE0_INTENSET_PER7_Pos: u32 = 7;
pub const RTC_MODE0_INTENSET_PER_Pos: u32 = 0;
pub const RTC_MODE0_INTENSET_CMP0_Pos: u32 = 8;
pub const RTC_MODE0_INTENSET_CMP_Pos: u32 = 8;
pub const RTC_MODE0_INTENSET_TAMPER_Pos: u32 = 14;
pub const RTC_MODE0_INTENSET_OVF_Pos: u32 = 15;
pub const RTC_MODE1_INTENSET_OFFSET: u32 = 10;
pub const RTC_MODE1_INTENSET_PER0_Pos: u32 = 0;
pub const RTC_MODE1_INTENSET_PER1_Pos: u32 = 1;
pub const RTC_MODE1_INTENSET_PER2_Pos: u32 = 2;
pub const RTC_MODE1_INTENSET_PER3_Pos: u32 = 3;
pub const RTC_MODE1_INTENSET_PER4_Pos: u32 = 4;
pub const RTC_MODE1_INTENSET_PER5_Pos: u32 = 5;
pub const RTC_MODE1_INTENSET_PER6_Pos: u32 = 6;
pub const RTC_MODE1_INTENSET_PER7_Pos: u32 = 7;
pub const RTC_MODE1_INTENSET_PER_Pos: u32 = 0;
pub const RTC_MODE1_INTENSET_CMP0_Pos: u32 = 8;
pub const RTC_MODE1_INTENSET_CMP1_Pos: u32 = 9;
pub const RTC_MODE1_INTENSET_CMP_Pos: u32 = 8;
pub const RTC_MODE1_INTENSET_TAMPER_Pos: u32 = 14;
pub const RTC_MODE1_INTENSET_OVF_Pos: u32 = 15;
pub const RTC_MODE2_INTENSET_OFFSET: u32 = 10;
pub const RTC_MODE2_INTENSET_PER0_Pos: u32 = 0;
pub const RTC_MODE2_INTENSET_PER1_Pos: u32 = 1;
pub const RTC_MODE2_INTENSET_PER2_Pos: u32 = 2;
pub const RTC_MODE2_INTENSET_PER3_Pos: u32 = 3;
pub const RTC_MODE2_INTENSET_PER4_Pos: u32 = 4;
pub const RTC_MODE2_INTENSET_PER5_Pos: u32 = 5;
pub const RTC_MODE2_INTENSET_PER6_Pos: u32 = 6;
pub const RTC_MODE2_INTENSET_PER7_Pos: u32 = 7;
pub const RTC_MODE2_INTENSET_PER_Pos: u32 = 0;
pub const RTC_MODE2_INTENSET_ALARM0_Pos: u32 = 8;
pub const RTC_MODE2_INTENSET_ALARM_Pos: u32 = 8;
pub const RTC_MODE2_INTENSET_TAMPER_Pos: u32 = 14;
pub const RTC_MODE2_INTENSET_OVF_Pos: u32 = 15;
pub const RTC_MODE0_INTFLAG_OFFSET: u32 = 12;
pub const RTC_MODE0_INTFLAG_PER0_Pos: u32 = 0;
pub const RTC_MODE0_INTFLAG_PER1_Pos: u32 = 1;
pub const RTC_MODE0_INTFLAG_PER2_Pos: u32 = 2;
pub const RTC_MODE0_INTFLAG_PER3_Pos: u32 = 3;
pub const RTC_MODE0_INTFLAG_PER4_Pos: u32 = 4;
pub const RTC_MODE0_INTFLAG_PER5_Pos: u32 = 5;
pub const RTC_MODE0_INTFLAG_PER6_Pos: u32 = 6;
pub const RTC_MODE0_INTFLAG_PER7_Pos: u32 = 7;
pub const RTC_MODE0_INTFLAG_PER_Pos: u32 = 0;
pub const RTC_MODE0_INTFLAG_CMP0_Pos: u32 = 8;
pub const RTC_MODE0_INTFLAG_CMP_Pos: u32 = 8;
pub const RTC_MODE0_INTFLAG_TAMPER_Pos: u32 = 14;
pub const RTC_MODE0_INTFLAG_OVF_Pos: u32 = 15;
pub const RTC_MODE1_INTFLAG_OFFSET: u32 = 12;
pub const RTC_MODE1_INTFLAG_PER0_Pos: u32 = 0;
pub const RTC_MODE1_INTFLAG_PER1_Pos: u32 = 1;
pub const RTC_MODE1_INTFLAG_PER2_Pos: u32 = 2;
pub const RTC_MODE1_INTFLAG_PER3_Pos: u32 = 3;
pub const RTC_MODE1_INTFLAG_PER4_Pos: u32 = 4;
pub const RTC_MODE1_INTFLAG_PER5_Pos: u32 = 5;
pub const RTC_MODE1_INTFLAG_PER6_Pos: u32 = 6;
pub const RTC_MODE1_INTFLAG_PER7_Pos: u32 = 7;
pub const RTC_MODE1_INTFLAG_PER_Pos: u32 = 0;
pub const RTC_MODE1_INTFLAG_CMP0_Pos: u32 = 8;
pub const RTC_MODE1_INTFLAG_CMP1_Pos: u32 = 9;
pub const RTC_MODE1_INTFLAG_CMP_Pos: u32 = 8;
pub const RTC_MODE1_INTFLAG_TAMPER_Pos: u32 = 14;
pub const RTC_MODE1_INTFLAG_OVF_Pos: u32 = 15;
pub const RTC_MODE2_INTFLAG_OFFSET: u32 = 12;
pub const RTC_MODE2_INTFLAG_PER0_Pos: u32 = 0;
pub const RTC_MODE2_INTFLAG_PER1_Pos: u32 = 1;
pub const RTC_MODE2_INTFLAG_PER2_Pos: u32 = 2;
pub const RTC_MODE2_INTFLAG_PER3_Pos: u32 = 3;
pub const RTC_MODE2_INTFLAG_PER4_Pos: u32 = 4;
pub const RTC_MODE2_INTFLAG_PER5_Pos: u32 = 5;
pub const RTC_MODE2_INTFLAG_PER6_Pos: u32 = 6;
pub const RTC_MODE2_INTFLAG_PER7_Pos: u32 = 7;
pub const RTC_MODE2_INTFLAG_PER_Pos: u32 = 0;
pub const RTC_MODE2_INTFLAG_ALARM0_Pos: u32 = 8;
pub const RTC_MODE2_INTFLAG_ALARM_Pos: u32 = 8;
pub const RTC_MODE2_INTFLAG_TAMPER_Pos: u32 = 14;
pub const RTC_MODE2_INTFLAG_OVF_Pos: u32 = 15;
pub const RTC_DBGCTRL_OFFSET: u32 = 14;
pub const RTC_DBGCTRL_DBGRUN_Pos: u32 = 0;
pub const RTC_MODE0_SYNCBUSY_OFFSET: u32 = 16;
pub const RTC_MODE0_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const RTC_MODE0_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const RTC_MODE0_SYNCBUSY_FREQCORR_Pos: u32 = 2;
pub const RTC_MODE0_SYNCBUSY_COUNT_Pos: u32 = 3;
pub const RTC_MODE0_SYNCBUSY_COMP0_Pos: u32 = 5;
pub const RTC_MODE0_SYNCBUSY_COMP_Pos: u32 = 5;
pub const RTC_MODE0_SYNCBUSY_COUNTSYNC_Pos: u32 = 15;
pub const RTC_MODE0_SYNCBUSY_GP0_Pos: u32 = 16;
pub const RTC_MODE0_SYNCBUSY_GP1_Pos: u32 = 17;
pub const RTC_MODE0_SYNCBUSY_GP_Pos: u32 = 16;
pub const RTC_MODE1_SYNCBUSY_OFFSET: u32 = 16;
pub const RTC_MODE1_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const RTC_MODE1_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const RTC_MODE1_SYNCBUSY_FREQCORR_Pos: u32 = 2;
pub const RTC_MODE1_SYNCBUSY_COUNT_Pos: u32 = 3;
pub const RTC_MODE1_SYNCBUSY_PER_Pos: u32 = 4;
pub const RTC_MODE1_SYNCBUSY_COMP0_Pos: u32 = 5;
pub const RTC_MODE1_SYNCBUSY_COMP1_Pos: u32 = 6;
pub const RTC_MODE1_SYNCBUSY_COMP_Pos: u32 = 5;
pub const RTC_MODE1_SYNCBUSY_COUNTSYNC_Pos: u32 = 15;
pub const RTC_MODE1_SYNCBUSY_GP0_Pos: u32 = 16;
pub const RTC_MODE1_SYNCBUSY_GP1_Pos: u32 = 17;
pub const RTC_MODE1_SYNCBUSY_GP_Pos: u32 = 16;
pub const RTC_MODE2_SYNCBUSY_OFFSET: u32 = 16;
pub const RTC_MODE2_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const RTC_MODE2_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const RTC_MODE2_SYNCBUSY_FREQCORR_Pos: u32 = 2;
pub const RTC_MODE2_SYNCBUSY_CLOCK_Pos: u32 = 3;
pub const RTC_MODE2_SYNCBUSY_ALARM0_Pos: u32 = 5;
pub const RTC_MODE2_SYNCBUSY_ALARM_Pos: u32 = 5;
pub const RTC_MODE2_SYNCBUSY_MASK0_Pos: u32 = 11;
pub const RTC_MODE2_SYNCBUSY_MASK_Pos: u32 = 11;
pub const RTC_MODE2_SYNCBUSY_CLOCKSYNC_Pos: u32 = 15;
pub const RTC_MODE2_SYNCBUSY_GP0_Pos: u32 = 16;
pub const RTC_MODE2_SYNCBUSY_GP1_Pos: u32 = 17;
pub const RTC_MODE2_SYNCBUSY_GP_Pos: u32 = 16;
pub const RTC_FREQCORR_OFFSET: u32 = 20;
pub const RTC_FREQCORR_VALUE_Pos: u32 = 0;
pub const RTC_FREQCORR_SIGN_Pos: u32 = 7;
pub const RTC_MODE0_COUNT_OFFSET: u32 = 24;
pub const RTC_MODE0_COUNT_COUNT_Pos: u32 = 0;
pub const RTC_MODE1_COUNT_OFFSET: u32 = 24;
pub const RTC_MODE1_COUNT_COUNT_Pos: u32 = 0;
pub const RTC_MODE2_CLOCK_OFFSET: u32 = 24;
pub const RTC_MODE2_CLOCK_SECOND_Pos: u32 = 0;
pub const RTC_MODE2_CLOCK_MINUTE_Pos: u32 = 6;
pub const RTC_MODE2_CLOCK_HOUR_Pos: u32 = 12;
pub const RTC_MODE2_CLOCK_DAY_Pos: u32 = 17;
pub const RTC_MODE2_CLOCK_MONTH_Pos: u32 = 22;
pub const RTC_MODE2_CLOCK_YEAR_Pos: u32 = 26;
pub const RTC_MODE1_PER_OFFSET: u32 = 28;
pub const RTC_MODE1_PER_PER_Pos: u32 = 0;
pub const RTC_MODE0_COMP_OFFSET: u32 = 32;
pub const RTC_MODE0_COMP_COMP_Pos: u32 = 0;
pub const RTC_MODE1_COMP_OFFSET: u32 = 32;
pub const RTC_MODE1_COMP_COMP_Pos: u32 = 0;
pub const RTC_MODE2_ALARM_OFFSET: u32 = 32;
pub const RTC_MODE2_ALARM_SECOND_Pos: u32 = 0;
pub const RTC_MODE2_ALARM_MINUTE_Pos: u32 = 6;
pub const RTC_MODE2_ALARM_HOUR_Pos: u32 = 12;
pub const RTC_MODE2_ALARM_DAY_Pos: u32 = 17;
pub const RTC_MODE2_ALARM_MONTH_Pos: u32 = 22;
pub const RTC_MODE2_ALARM_YEAR_Pos: u32 = 26;
pub const RTC_MODE2_MASK_OFFSET: u32 = 36;
pub const RTC_MODE2_MASK_SEL_Pos: u32 = 0;
pub const RTC_GP_OFFSET: u32 = 64;
pub const RTC_GP_GP_Pos: u32 = 0;
pub const RTC_TAMPCTRL_OFFSET: u32 = 96;
pub const RTC_TAMPCTRL_IN0ACT_Pos: u32 = 0;
pub const RTC_TAMPCTRL_IN1ACT_Pos: u32 = 2;
pub const RTC_TAMPCTRL_IN2ACT_Pos: u32 = 4;
pub const RTC_TAMPCTRL_IN3ACT_Pos: u32 = 6;
pub const RTC_TAMPCTRL_IN4ACT_Pos: u32 = 8;
pub const RTC_TAMPCTRL_TAMLVL0_Pos: u32 = 16;
pub const RTC_TAMPCTRL_TAMLVL1_Pos: u32 = 17;
pub const RTC_TAMPCTRL_TAMLVL2_Pos: u32 = 18;
pub const RTC_TAMPCTRL_TAMLVL3_Pos: u32 = 19;
pub const RTC_TAMPCTRL_TAMLVL4_Pos: u32 = 20;
pub const RTC_TAMPCTRL_TAMLVL_Pos: u32 = 16;
pub const RTC_TAMPCTRL_DEBNC0_Pos: u32 = 24;
pub const RTC_TAMPCTRL_DEBNC1_Pos: u32 = 25;
pub const RTC_TAMPCTRL_DEBNC2_Pos: u32 = 26;
pub const RTC_TAMPCTRL_DEBNC3_Pos: u32 = 27;
pub const RTC_TAMPCTRL_DEBNC4_Pos: u32 = 28;
pub const RTC_TAMPCTRL_DEBNC_Pos: u32 = 24;
pub const RTC_MODE0_TIMESTAMP_OFFSET: u32 = 100;
pub const RTC_MODE0_TIMESTAMP_COUNT_Pos: u32 = 0;
pub const RTC_MODE1_TIMESTAMP_OFFSET: u32 = 100;
pub const RTC_MODE1_TIMESTAMP_COUNT_Pos: u32 = 0;
pub const RTC_MODE2_TIMESTAMP_OFFSET: u32 = 100;
pub const RTC_MODE2_TIMESTAMP_SECOND_Pos: u32 = 0;
pub const RTC_MODE2_TIMESTAMP_MINUTE_Pos: u32 = 6;
pub const RTC_MODE2_TIMESTAMP_HOUR_Pos: u32 = 12;
pub const RTC_MODE2_TIMESTAMP_DAY_Pos: u32 = 17;
pub const RTC_MODE2_TIMESTAMP_MONTH_Pos: u32 = 22;
pub const RTC_MODE2_TIMESTAMP_YEAR_Pos: u32 = 26;
pub const RTC_TAMPID_OFFSET: u32 = 104;
pub const RTC_TAMPID_TAMPID0_Pos: u32 = 0;
pub const RTC_TAMPID_TAMPID1_Pos: u32 = 1;
pub const RTC_TAMPID_TAMPID2_Pos: u32 = 2;
pub const RTC_TAMPID_TAMPID3_Pos: u32 = 3;
pub const RTC_TAMPID_TAMPID4_Pos: u32 = 4;
pub const RTC_TAMPID_TAMPID_Pos: u32 = 0;
pub const RTC_TAMPID_TAMPEVT_Pos: u32 = 31;
pub const RTC_BKUP_OFFSET: u32 = 128;
pub const RTC_BKUP_BKUP_Pos: u32 = 0;
pub const REV_SERCOM: u32 = 1024;
pub const SERCOM_I2CM_CTRLA_OFFSET: u32 = 0;
pub const SERCOM_I2CM_CTRLA_SWRST_Pos: u32 = 0;
pub const SERCOM_I2CM_CTRLA_ENABLE_Pos: u32 = 1;
pub const SERCOM_I2CM_CTRLA_MODE_Pos: u32 = 2;
pub const SERCOM_I2CM_CTRLA_RUNSTDBY_Pos: u32 = 7;
pub const SERCOM_I2CM_CTRLA_PINOUT_Pos: u32 = 16;
pub const SERCOM_I2CM_CTRLA_SDAHOLD_Pos: u32 = 20;
pub const SERCOM_I2CM_CTRLA_MEXTTOEN_Pos: u32 = 22;
pub const SERCOM_I2CM_CTRLA_SEXTTOEN_Pos: u32 = 23;
pub const SERCOM_I2CM_CTRLA_SPEED_Pos: u32 = 24;
pub const SERCOM_I2CM_CTRLA_SCLSM_Pos: u32 = 27;
pub const SERCOM_I2CM_CTRLA_INACTOUT_Pos: u32 = 28;
pub const SERCOM_I2CM_CTRLA_LOWTOUTEN_Pos: u32 = 30;
pub const SERCOM_I2CS_CTRLA_OFFSET: u32 = 0;
pub const SERCOM_I2CS_CTRLA_SWRST_Pos: u32 = 0;
pub const SERCOM_I2CS_CTRLA_ENABLE_Pos: u32 = 1;
pub const SERCOM_I2CS_CTRLA_MODE_Pos: u32 = 2;
pub const SERCOM_I2CS_CTRLA_RUNSTDBY_Pos: u32 = 7;
pub const SERCOM_I2CS_CTRLA_PINOUT_Pos: u32 = 16;
pub const SERCOM_I2CS_CTRLA_SDAHOLD_Pos: u32 = 20;
pub const SERCOM_I2CS_CTRLA_SEXTTOEN_Pos: u32 = 23;
pub const SERCOM_I2CS_CTRLA_SPEED_Pos: u32 = 24;
pub const SERCOM_I2CS_CTRLA_SCLSM_Pos: u32 = 27;
pub const SERCOM_I2CS_CTRLA_LOWTOUTEN_Pos: u32 = 30;
pub const SERCOM_SPI_CTRLA_OFFSET: u32 = 0;
pub const SERCOM_SPI_CTRLA_SWRST_Pos: u32 = 0;
pub const SERCOM_SPI_CTRLA_ENABLE_Pos: u32 = 1;
pub const SERCOM_SPI_CTRLA_MODE_Pos: u32 = 2;
pub const SERCOM_SPI_CTRLA_RUNSTDBY_Pos: u32 = 7;
pub const SERCOM_SPI_CTRLA_IBON_Pos: u32 = 8;
pub const SERCOM_SPI_CTRLA_DOPO_Pos: u32 = 16;
pub const SERCOM_SPI_CTRLA_DIPO_Pos: u32 = 20;
pub const SERCOM_SPI_CTRLA_FORM_Pos: u32 = 24;
pub const SERCOM_SPI_CTRLA_CPHA_Pos: u32 = 28;
pub const SERCOM_SPI_CTRLA_CPOL_Pos: u32 = 29;
pub const SERCOM_SPI_CTRLA_DORD_Pos: u32 = 30;
pub const SERCOM_USART_CTRLA_OFFSET: u32 = 0;
pub const SERCOM_USART_CTRLA_SWRST_Pos: u32 = 0;
pub const SERCOM_USART_CTRLA_ENABLE_Pos: u32 = 1;
pub const SERCOM_USART_CTRLA_MODE_Pos: u32 = 2;
pub const SERCOM_USART_CTRLA_RUNSTDBY_Pos: u32 = 7;
pub const SERCOM_USART_CTRLA_IBON_Pos: u32 = 8;
pub const SERCOM_USART_CTRLA_TXINV_Pos: u32 = 9;
pub const SERCOM_USART_CTRLA_RXINV_Pos: u32 = 10;
pub const SERCOM_USART_CTRLA_SAMPR_Pos: u32 = 13;
pub const SERCOM_USART_CTRLA_TXPO_Pos: u32 = 16;
pub const SERCOM_USART_CTRLA_RXPO_Pos: u32 = 20;
pub const SERCOM_USART_CTRLA_SAMPA_Pos: u32 = 22;
pub const SERCOM_USART_CTRLA_FORM_Pos: u32 = 24;
pub const SERCOM_USART_CTRLA_CMODE_Pos: u32 = 28;
pub const SERCOM_USART_CTRLA_CPOL_Pos: u32 = 29;
pub const SERCOM_USART_CTRLA_DORD_Pos: u32 = 30;
pub const SERCOM_I2CM_CTRLB_OFFSET: u32 = 4;
pub const SERCOM_I2CM_CTRLB_SMEN_Pos: u32 = 8;
pub const SERCOM_I2CM_CTRLB_QCEN_Pos: u32 = 9;
pub const SERCOM_I2CM_CTRLB_CMD_Pos: u32 = 16;
pub const SERCOM_I2CM_CTRLB_ACKACT_Pos: u32 = 18;
pub const SERCOM_I2CS_CTRLB_OFFSET: u32 = 4;
pub const SERCOM_I2CS_CTRLB_SMEN_Pos: u32 = 8;
pub const SERCOM_I2CS_CTRLB_GCMD_Pos: u32 = 9;
pub const SERCOM_I2CS_CTRLB_AACKEN_Pos: u32 = 10;
pub const SERCOM_I2CS_CTRLB_AMODE_Pos: u32 = 14;
pub const SERCOM_I2CS_CTRLB_CMD_Pos: u32 = 16;
pub const SERCOM_I2CS_CTRLB_ACKACT_Pos: u32 = 18;
pub const SERCOM_SPI_CTRLB_OFFSET: u32 = 4;
pub const SERCOM_SPI_CTRLB_CHSIZE_Pos: u32 = 0;
pub const SERCOM_SPI_CTRLB_PLOADEN_Pos: u32 = 6;
pub const SERCOM_SPI_CTRLB_SSDE_Pos: u32 = 9;
pub const SERCOM_SPI_CTRLB_MSSEN_Pos: u32 = 13;
pub const SERCOM_SPI_CTRLB_AMODE_Pos: u32 = 14;
pub const SERCOM_SPI_CTRLB_RXEN_Pos: u32 = 17;
pub const SERCOM_USART_CTRLB_OFFSET: u32 = 4;
pub const SERCOM_USART_CTRLB_CHSIZE_Pos: u32 = 0;
pub const SERCOM_USART_CTRLB_SBMODE_Pos: u32 = 6;
pub const SERCOM_USART_CTRLB_COLDEN_Pos: u32 = 8;
pub const SERCOM_USART_CTRLB_SFDE_Pos: u32 = 9;
pub const SERCOM_USART_CTRLB_ENC_Pos: u32 = 10;
pub const SERCOM_USART_CTRLB_PMODE_Pos: u32 = 13;
pub const SERCOM_USART_CTRLB_TXEN_Pos: u32 = 16;
pub const SERCOM_USART_CTRLB_RXEN_Pos: u32 = 17;
pub const SERCOM_USART_CTRLC_OFFSET: u32 = 8;
pub const SERCOM_USART_CTRLC_GTIME_Pos: u32 = 0;
pub const SERCOM_USART_CTRLC_INACK_Pos: u32 = 16;
pub const SERCOM_USART_CTRLC_DSNACK_Pos: u32 = 17;
pub const SERCOM_USART_CTRLC_MAXITER_Pos: u32 = 20;
pub const SERCOM_I2CM_BAUD_OFFSET: u32 = 12;
pub const SERCOM_I2CM_BAUD_BAUD_Pos: u32 = 0;
pub const SERCOM_I2CM_BAUD_BAUDLOW_Pos: u32 = 8;
pub const SERCOM_I2CM_BAUD_HSBAUD_Pos: u32 = 16;
pub const SERCOM_I2CM_BAUD_HSBAUDLOW_Pos: u32 = 24;
pub const SERCOM_SPI_BAUD_OFFSET: u32 = 12;
pub const SERCOM_SPI_BAUD_BAUD_Pos: u32 = 0;
pub const SERCOM_USART_BAUD_OFFSET: u32 = 12;
pub const SERCOM_USART_BAUD_BAUD_Pos: u32 = 0;
pub const SERCOM_USART_BAUD_FRAC_BAUD_Pos: u32 = 0;
pub const SERCOM_USART_BAUD_FRAC_FP_Pos: u32 = 13;
pub const SERCOM_USART_BAUD_FRACFP_BAUD_Pos: u32 = 0;
pub const SERCOM_USART_BAUD_FRACFP_FP_Pos: u32 = 13;
pub const SERCOM_USART_BAUD_USARTFP_BAUD_Pos: u32 = 0;
pub const SERCOM_USART_RXPL_OFFSET: u32 = 14;
pub const SERCOM_USART_RXPL_RXPL_Pos: u32 = 0;
pub const SERCOM_I2CM_INTENCLR_OFFSET: u32 = 20;
pub const SERCOM_I2CM_INTENCLR_MB_Pos: u32 = 0;
pub const SERCOM_I2CM_INTENCLR_SB_Pos: u32 = 1;
pub const SERCOM_I2CM_INTENCLR_ERROR_Pos: u32 = 7;
pub const SERCOM_I2CS_INTENCLR_OFFSET: u32 = 20;
pub const SERCOM_I2CS_INTENCLR_PREC_Pos: u32 = 0;
pub const SERCOM_I2CS_INTENCLR_AMATCH_Pos: u32 = 1;
pub const SERCOM_I2CS_INTENCLR_DRDY_Pos: u32 = 2;
pub const SERCOM_I2CS_INTENCLR_ERROR_Pos: u32 = 7;
pub const SERCOM_SPI_INTENCLR_OFFSET: u32 = 20;
pub const SERCOM_SPI_INTENCLR_DRE_Pos: u32 = 0;
pub const SERCOM_SPI_INTENCLR_TXC_Pos: u32 = 1;
pub const SERCOM_SPI_INTENCLR_RXC_Pos: u32 = 2;
pub const SERCOM_SPI_INTENCLR_SSL_Pos: u32 = 3;
pub const SERCOM_SPI_INTENCLR_ERROR_Pos: u32 = 7;
pub const SERCOM_USART_INTENCLR_OFFSET: u32 = 20;
pub const SERCOM_USART_INTENCLR_DRE_Pos: u32 = 0;
pub const SERCOM_USART_INTENCLR_TXC_Pos: u32 = 1;
pub const SERCOM_USART_INTENCLR_RXC_Pos: u32 = 2;
pub const SERCOM_USART_INTENCLR_RXS_Pos: u32 = 3;
pub const SERCOM_USART_INTENCLR_CTSIC_Pos: u32 = 4;
pub const SERCOM_USART_INTENCLR_RXBRK_Pos: u32 = 5;
pub const SERCOM_USART_INTENCLR_ERROR_Pos: u32 = 7;
pub const SERCOM_I2CM_INTENSET_OFFSET: u32 = 22;
pub const SERCOM_I2CM_INTENSET_MB_Pos: u32 = 0;
pub const SERCOM_I2CM_INTENSET_SB_Pos: u32 = 1;
pub const SERCOM_I2CM_INTENSET_ERROR_Pos: u32 = 7;
pub const SERCOM_I2CS_INTENSET_OFFSET: u32 = 22;
pub const SERCOM_I2CS_INTENSET_PREC_Pos: u32 = 0;
pub const SERCOM_I2CS_INTENSET_AMATCH_Pos: u32 = 1;
pub const SERCOM_I2CS_INTENSET_DRDY_Pos: u32 = 2;
pub const SERCOM_I2CS_INTENSET_ERROR_Pos: u32 = 7;
pub const SERCOM_SPI_INTENSET_OFFSET: u32 = 22;
pub const SERCOM_SPI_INTENSET_DRE_Pos: u32 = 0;
pub const SERCOM_SPI_INTENSET_TXC_Pos: u32 = 1;
pub const SERCOM_SPI_INTENSET_RXC_Pos: u32 = 2;
pub const SERCOM_SPI_INTENSET_SSL_Pos: u32 = 3;
pub const SERCOM_SPI_INTENSET_ERROR_Pos: u32 = 7;
pub const SERCOM_USART_INTENSET_OFFSET: u32 = 22;
pub const SERCOM_USART_INTENSET_DRE_Pos: u32 = 0;
pub const SERCOM_USART_INTENSET_TXC_Pos: u32 = 1;
pub const SERCOM_USART_INTENSET_RXC_Pos: u32 = 2;
pub const SERCOM_USART_INTENSET_RXS_Pos: u32 = 3;
pub const SERCOM_USART_INTENSET_CTSIC_Pos: u32 = 4;
pub const SERCOM_USART_INTENSET_RXBRK_Pos: u32 = 5;
pub const SERCOM_USART_INTENSET_ERROR_Pos: u32 = 7;
pub const SERCOM_I2CM_INTFLAG_OFFSET: u32 = 24;
pub const SERCOM_I2CM_INTFLAG_MB_Pos: u32 = 0;
pub const SERCOM_I2CM_INTFLAG_SB_Pos: u32 = 1;
pub const SERCOM_I2CM_INTFLAG_ERROR_Pos: u32 = 7;
pub const SERCOM_I2CS_INTFLAG_OFFSET: u32 = 24;
pub const SERCOM_I2CS_INTFLAG_PREC_Pos: u32 = 0;
pub const SERCOM_I2CS_INTFLAG_AMATCH_Pos: u32 = 1;
pub const SERCOM_I2CS_INTFLAG_DRDY_Pos: u32 = 2;
pub const SERCOM_I2CS_INTFLAG_ERROR_Pos: u32 = 7;
pub const SERCOM_SPI_INTFLAG_OFFSET: u32 = 24;
pub const SERCOM_SPI_INTFLAG_DRE_Pos: u32 = 0;
pub const SERCOM_SPI_INTFLAG_TXC_Pos: u32 = 1;
pub const SERCOM_SPI_INTFLAG_RXC_Pos: u32 = 2;
pub const SERCOM_SPI_INTFLAG_SSL_Pos: u32 = 3;
pub const SERCOM_SPI_INTFLAG_ERROR_Pos: u32 = 7;
pub const SERCOM_USART_INTFLAG_OFFSET: u32 = 24;
pub const SERCOM_USART_INTFLAG_DRE_Pos: u32 = 0;
pub const SERCOM_USART_INTFLAG_TXC_Pos: u32 = 1;
pub const SERCOM_USART_INTFLAG_RXC_Pos: u32 = 2;
pub const SERCOM_USART_INTFLAG_RXS_Pos: u32 = 3;
pub const SERCOM_USART_INTFLAG_CTSIC_Pos: u32 = 4;
pub const SERCOM_USART_INTFLAG_RXBRK_Pos: u32 = 5;
pub const SERCOM_USART_INTFLAG_ERROR_Pos: u32 = 7;
pub const SERCOM_I2CM_STATUS_OFFSET: u32 = 26;
pub const SERCOM_I2CM_STATUS_BUSERR_Pos: u32 = 0;
pub const SERCOM_I2CM_STATUS_ARBLOST_Pos: u32 = 1;
pub const SERCOM_I2CM_STATUS_RXNACK_Pos: u32 = 2;
pub const SERCOM_I2CM_STATUS_BUSSTATE_Pos: u32 = 4;
pub const SERCOM_I2CM_STATUS_LOWTOUT_Pos: u32 = 6;
pub const SERCOM_I2CM_STATUS_CLKHOLD_Pos: u32 = 7;
pub const SERCOM_I2CM_STATUS_MEXTTOUT_Pos: u32 = 8;
pub const SERCOM_I2CM_STATUS_SEXTTOUT_Pos: u32 = 9;
pub const SERCOM_I2CM_STATUS_LENERR_Pos: u32 = 10;
pub const SERCOM_I2CS_STATUS_OFFSET: u32 = 26;
pub const SERCOM_I2CS_STATUS_BUSERR_Pos: u32 = 0;
pub const SERCOM_I2CS_STATUS_COLL_Pos: u32 = 1;
pub const SERCOM_I2CS_STATUS_RXNACK_Pos: u32 = 2;
pub const SERCOM_I2CS_STATUS_DIR_Pos: u32 = 3;
pub const SERCOM_I2CS_STATUS_SR_Pos: u32 = 4;
pub const SERCOM_I2CS_STATUS_LOWTOUT_Pos: u32 = 6;
pub const SERCOM_I2CS_STATUS_CLKHOLD_Pos: u32 = 7;
pub const SERCOM_I2CS_STATUS_SEXTTOUT_Pos: u32 = 9;
pub const SERCOM_I2CS_STATUS_HS_Pos: u32 = 10;
pub const SERCOM_SPI_STATUS_OFFSET: u32 = 26;
pub const SERCOM_SPI_STATUS_BUFOVF_Pos: u32 = 2;
pub const SERCOM_USART_STATUS_OFFSET: u32 = 26;
pub const SERCOM_USART_STATUS_PERR_Pos: u32 = 0;
pub const SERCOM_USART_STATUS_FERR_Pos: u32 = 1;
pub const SERCOM_USART_STATUS_BUFOVF_Pos: u32 = 2;
pub const SERCOM_USART_STATUS_CTS_Pos: u32 = 3;
pub const SERCOM_USART_STATUS_ISF_Pos: u32 = 4;
pub const SERCOM_USART_STATUS_COLL_Pos: u32 = 5;
pub const SERCOM_USART_STATUS_TXE_Pos: u32 = 6;
pub const SERCOM_USART_STATUS_ITER_Pos: u32 = 7;
pub const SERCOM_I2CM_SYNCBUSY_OFFSET: u32 = 28;
pub const SERCOM_I2CM_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const SERCOM_I2CM_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const SERCOM_I2CM_SYNCBUSY_SYSOP_Pos: u32 = 2;
pub const SERCOM_I2CS_SYNCBUSY_OFFSET: u32 = 28;
pub const SERCOM_I2CS_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const SERCOM_I2CS_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const SERCOM_SPI_SYNCBUSY_OFFSET: u32 = 28;
pub const SERCOM_SPI_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const SERCOM_SPI_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const SERCOM_SPI_SYNCBUSY_CTRLB_Pos: u32 = 2;
pub const SERCOM_USART_SYNCBUSY_OFFSET: u32 = 28;
pub const SERCOM_USART_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const SERCOM_USART_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const SERCOM_USART_SYNCBUSY_CTRLB_Pos: u32 = 2;
pub const SERCOM_USART_RXERRCNT_OFFSET: u32 = 32;
pub const SERCOM_I2CM_ADDR_OFFSET: u32 = 36;
pub const SERCOM_I2CM_ADDR_ADDR_Pos: u32 = 0;
pub const SERCOM_I2CM_ADDR_LENEN_Pos: u32 = 13;
pub const SERCOM_I2CM_ADDR_HS_Pos: u32 = 14;
pub const SERCOM_I2CM_ADDR_TENBITEN_Pos: u32 = 15;
pub const SERCOM_I2CM_ADDR_LEN_Pos: u32 = 16;
pub const SERCOM_I2CS_ADDR_OFFSET: u32 = 36;
pub const SERCOM_I2CS_ADDR_GENCEN_Pos: u32 = 0;
pub const SERCOM_I2CS_ADDR_ADDR_Pos: u32 = 1;
pub const SERCOM_I2CS_ADDR_TENBITEN_Pos: u32 = 15;
pub const SERCOM_I2CS_ADDR_ADDRMASK_Pos: u32 = 17;
pub const SERCOM_SPI_ADDR_OFFSET: u32 = 36;
pub const SERCOM_SPI_ADDR_ADDR_Pos: u32 = 0;
pub const SERCOM_SPI_ADDR_ADDRMASK_Pos: u32 = 16;
pub const SERCOM_I2CM_DATA_OFFSET: u32 = 40;
pub const SERCOM_I2CM_DATA_DATA_Pos: u32 = 0;
pub const SERCOM_I2CS_DATA_OFFSET: u32 = 40;
pub const SERCOM_I2CS_DATA_DATA_Pos: u32 = 0;
pub const SERCOM_SPI_DATA_OFFSET: u32 = 40;
pub const SERCOM_SPI_DATA_DATA_Pos: u32 = 0;
pub const SERCOM_USART_DATA_OFFSET: u32 = 40;
pub const SERCOM_USART_DATA_DATA_Pos: u32 = 0;
pub const SERCOM_I2CM_DBGCTRL_OFFSET: u32 = 48;
pub const SERCOM_I2CM_DBGCTRL_DBGSTOP_Pos: u32 = 0;
pub const SERCOM_SPI_DBGCTRL_OFFSET: u32 = 48;
pub const SERCOM_SPI_DBGCTRL_DBGSTOP_Pos: u32 = 0;
pub const SERCOM_USART_DBGCTRL_OFFSET: u32 = 48;
pub const SERCOM_USART_DBGCTRL_DBGSTOP_Pos: u32 = 0;
pub const REV_SLCD: u32 = 256;
pub const SLCD_CTRLA_OFFSET: u32 = 0;
pub const SLCD_CTRLA_SWRST_Pos: u32 = 0;
pub const SLCD_CTRLA_ENABLE_Pos: u32 = 1;
pub const SLCD_CTRLA_DUTY_Pos: u32 = 2;
pub const SLCD_CTRLA_WMOD_Pos: u32 = 5;
pub const SLCD_CTRLA_RUNSTDBY_Pos: u32 = 6;
pub const SLCD_CTRLA_PRESC_Pos: u32 = 8;
pub const SLCD_CTRLA_CKDIV_Pos: u32 = 12;
pub const SLCD_CTRLA_BIAS_Pos: u32 = 16;
pub const SLCD_CTRLA_XVLCD_Pos: u32 = 19;
pub const SLCD_CTRLA_PRF_Pos: u32 = 20;
pub const SLCD_CTRLA_DMFCS_Pos: u32 = 22;
pub const SLCD_CTRLA_RRF_Pos: u32 = 24;
pub const SLCD_CTRLB_OFFSET: u32 = 4;
pub const SLCD_CTRLB_BBD_Pos: u32 = 0;
pub const SLCD_CTRLB_BBEN_Pos: u32 = 7;
pub const SLCD_CTRLB_LRD_Pos: u32 = 8;
pub const SLCD_CTRLB_LREN_Pos: u32 = 15;
pub const SLCD_CTRLC_OFFSET: u32 = 6;
pub const SLCD_CTRLC_CLEAR_Pos: u32 = 0;
pub const SLCD_CTRLC_LOCK_Pos: u32 = 1;
pub const SLCD_CTRLC_ABMEN_Pos: u32 = 2;
pub const SLCD_CTRLC_ACMEN_Pos: u32 = 3;
pub const SLCD_CTRLC_CTST_Pos: u32 = 4;
pub const SLCD_CTRLC_LPPM_Pos: u32 = 8;
pub const SLCD_CTRLD_OFFSET: u32 = 8;
pub const SLCD_CTRLD_BLANK_Pos: u32 = 0;
pub const SLCD_CTRLD_BLINK_Pos: u32 = 1;
pub const SLCD_CTRLD_CSREN_Pos: u32 = 2;
pub const SLCD_CTRLD_FC0EN_Pos: u32 = 4;
pub const SLCD_CTRLD_FC1EN_Pos: u32 = 5;
pub const SLCD_CTRLD_FC2EN_Pos: u32 = 6;
pub const SLCD_CTRLD_DISPEN_Pos: u32 = 7;
pub const SLCD_EVCTRL_OFFSET: u32 = 12;
pub const SLCD_EVCTRL_FC0OEO_Pos: u32 = 0;
pub const SLCD_EVCTRL_FC1OEO_Pos: u32 = 1;
pub const SLCD_EVCTRL_FC2OEO_Pos: u32 = 2;
pub const SLCD_INTENCLR_OFFSET: u32 = 13;
pub const SLCD_INTENCLR_FC0O_Pos: u32 = 0;
pub const SLCD_INTENCLR_FC1O_Pos: u32 = 1;
pub const SLCD_INTENCLR_FC2O_Pos: u32 = 2;
pub const SLCD_INTENCLR_VLCDRT_Pos: u32 = 3;
pub const SLCD_INTENCLR_VLCDST_Pos: u32 = 4;
pub const SLCD_INTENCLR_PRST_Pos: u32 = 5;
pub const SLCD_INTENSET_OFFSET: u32 = 14;
pub const SLCD_INTENSET_FC0O_Pos: u32 = 0;
pub const SLCD_INTENSET_FC1O_Pos: u32 = 1;
pub const SLCD_INTENSET_FC2O_Pos: u32 = 2;
pub const SLCD_INTENSET_VLCDRT_Pos: u32 = 3;
pub const SLCD_INTENSET_VLCDST_Pos: u32 = 4;
pub const SLCD_INTENSET_PRST_Pos: u32 = 5;
pub const SLCD_INTFLAG_OFFSET: u32 = 15;
pub const SLCD_INTFLAG_FC0O_Pos: u32 = 0;
pub const SLCD_INTFLAG_FC1O_Pos: u32 = 1;
pub const SLCD_INTFLAG_FC2O_Pos: u32 = 2;
pub const SLCD_INTFLAG_VLCDRT_Pos: u32 = 3;
pub const SLCD_INTFLAG_VLCDST_Pos: u32 = 4;
pub const SLCD_INTFLAG_PRST_Pos: u32 = 5;
pub const SLCD_STATUS_OFFSET: u32 = 16;
pub const SLCD_STATUS_VLCDR_Pos: u32 = 0;
pub const SLCD_STATUS_PRUN_Pos: u32 = 1;
pub const SLCD_STATUS_VLCDS_Pos: u32 = 2;
pub const SLCD_STATUS_CMWRBUSY_Pos: u32 = 3;
pub const SLCD_STATUS_ACMBUSY_Pos: u32 = 4;
pub const SLCD_STATUS_ABMBUSY_Pos: u32 = 5;
pub const SLCD_SYNCBUSY_OFFSET: u32 = 20;
pub const SLCD_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const SLCD_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const SLCD_SYNCBUSY_CTRLD_Pos: u32 = 2;
pub const SLCD_FC0_OFFSET: u32 = 24;
pub const SLCD_FC0_OVF_Pos: u32 = 0;
pub const SLCD_FC0_PB_Pos: u32 = 7;
pub const SLCD_FC1_OFFSET: u32 = 25;
pub const SLCD_FC1_OVF_Pos: u32 = 0;
pub const SLCD_FC1_PB_Pos: u32 = 7;
pub const SLCD_FC2_OFFSET: u32 = 26;
pub const SLCD_FC2_OVF_Pos: u32 = 0;
pub const SLCD_FC2_PB_Pos: u32 = 7;
pub const SLCD_LPENL_OFFSET: u32 = 28;
pub const SLCD_LPENL_LPEN_Pos: u32 = 0;
pub const SLCD_LPENH_OFFSET: u32 = 32;
pub const SLCD_LPENH_LPEN_Pos: u32 = 0;
pub const SLCD_SDATAL0_OFFSET: u32 = 36;
pub const SLCD_SDATAL0_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAH0_OFFSET: u32 = 40;
pub const SLCD_SDATAH0_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAL1_OFFSET: u32 = 44;
pub const SLCD_SDATAL1_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAH1_OFFSET: u32 = 48;
pub const SLCD_SDATAH1_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAL2_OFFSET: u32 = 52;
pub const SLCD_SDATAL2_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAH2_OFFSET: u32 = 56;
pub const SLCD_SDATAH2_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAL3_OFFSET: u32 = 60;
pub const SLCD_SDATAL3_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAH3_OFFSET: u32 = 64;
pub const SLCD_SDATAH3_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAL4_OFFSET: u32 = 68;
pub const SLCD_SDATAL4_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAH4_OFFSET: u32 = 72;
pub const SLCD_SDATAH4_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAL5_OFFSET: u32 = 76;
pub const SLCD_SDATAL5_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAH5_OFFSET: u32 = 80;
pub const SLCD_SDATAH5_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAL6_OFFSET: u32 = 84;
pub const SLCD_SDATAL6_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAH6_OFFSET: u32 = 88;
pub const SLCD_SDATAH6_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAL7_OFFSET: u32 = 92;
pub const SLCD_SDATAL7_SDATA_Pos: u32 = 0;
pub const SLCD_SDATAH7_OFFSET: u32 = 96;
pub const SLCD_SDATAH7_SDATA_Pos: u32 = 0;
pub const SLCD_ISDATA_OFFSET: u32 = 100;
pub const SLCD_ISDATA_SDATA_Pos: u32 = 0;
pub const SLCD_ISDATA_SDMASK_Pos: u32 = 8;
pub const SLCD_ISDATA_OFF_Pos: u32 = 16;
pub const SLCD_BCFG_OFFSET: u32 = 104;
pub const SLCD_BCFG_MODE_Pos: u32 = 0;
pub const SLCD_BCFG_FCS_Pos: u32 = 1;
pub const SLCD_BCFG_BSS0_Pos: u32 = 8;
pub const SLCD_BCFG_BSS1_Pos: u32 = 16;
pub const SLCD_CSRCFG_OFFSET: u32 = 108;
pub const SLCD_CSRCFG_DIR_Pos: u32 = 0;
pub const SLCD_CSRCFG_FCS_Pos: u32 = 1;
pub const SLCD_CSRCFG_SIZE_Pos: u32 = 4;
pub const SLCD_CSRCFG_DATA_Pos: u32 = 8;
pub const SLCD_CMCFG_OFFSET: u32 = 112;
pub const SLCD_CMCFG_NSEG_Pos: u32 = 0;
pub const SLCD_CMCFG_DEC_Pos: u32 = 3;
pub const SLCD_ACMCFG_OFFSET: u32 = 116;
pub const SLCD_ACMCFG_NCOM_Pos: u32 = 0;
pub const SLCD_ACMCFG_NDIG_Pos: u32 = 4;
pub const SLCD_ACMCFG_STEPS_Pos: u32 = 8;
pub const SLCD_ACMCFG_NDROW_Pos: u32 = 16;
pub const SLCD_ACMCFG_MODE_Pos: u32 = 23;
pub const SLCD_ACMCFG_STSEG_Pos: u32 = 24;
pub const SLCD_ACMCFG_FCS_Pos: u32 = 30;
pub const SLCD_ABMCFG_OFFSET: u32 = 120;
pub const SLCD_ABMCFG_FCS_Pos: u32 = 0;
pub const SLCD_ABMCFG_SIZE_Pos: u32 = 2;
pub const SLCD_CMDATA_OFFSET: u32 = 124;
pub const SLCD_CMDATA_SDATA_Pos: u32 = 0;
pub const SLCD_CMDMASK_OFFSET: u32 = 128;
pub const SLCD_CMDMASK_SDMASK_Pos: u32 = 0;
pub const SLCD_CMINDEX_OFFSET: u32 = 132;
pub const SLCD_CMINDEX_SINDEX_Pos: u32 = 0;
pub const SLCD_CMINDEX_CINDEX_Pos: u32 = 8;
pub const REV_SUPC: u32 = 768;
pub const SUPC_INTENCLR_OFFSET: u32 = 0;
pub const SUPC_INTENCLR_BOD33RDY_Pos: u32 = 0;
pub const SUPC_INTENCLR_BOD33DET_Pos: u32 = 1;
pub const SUPC_INTENCLR_B33SRDY_Pos: u32 = 2;
pub const SUPC_INTENCLR_BOD12RDY_Pos: u32 = 3;
pub const SUPC_INTENCLR_BOD12DET_Pos: u32 = 4;
pub const SUPC_INTENCLR_B12SRDY_Pos: u32 = 5;
pub const SUPC_INTENCLR_VREGRDY_Pos: u32 = 8;
pub const SUPC_INTENCLR_APWSRDY_Pos: u32 = 9;
pub const SUPC_INTENCLR_VCORERDY_Pos: u32 = 10;
pub const SUPC_INTENSET_OFFSET: u32 = 4;
pub const SUPC_INTENSET_BOD33RDY_Pos: u32 = 0;
pub const SUPC_INTENSET_BOD33DET_Pos: u32 = 1;
pub const SUPC_INTENSET_B33SRDY_Pos: u32 = 2;
pub const SUPC_INTENSET_BOD12RDY_Pos: u32 = 3;
pub const SUPC_INTENSET_BOD12DET_Pos: u32 = 4;
pub const SUPC_INTENSET_B12SRDY_Pos: u32 = 5;
pub const SUPC_INTENSET_VREGRDY_Pos: u32 = 8;
pub const SUPC_INTENSET_APWSRDY_Pos: u32 = 9;
pub const SUPC_INTENSET_VCORERDY_Pos: u32 = 10;
pub const SUPC_INTFLAG_OFFSET: u32 = 8;
pub const SUPC_INTFLAG_BOD33RDY_Pos: u32 = 0;
pub const SUPC_INTFLAG_BOD33DET_Pos: u32 = 1;
pub const SUPC_INTFLAG_B33SRDY_Pos: u32 = 2;
pub const SUPC_INTFLAG_BOD12RDY_Pos: u32 = 3;
pub const SUPC_INTFLAG_BOD12DET_Pos: u32 = 4;
pub const SUPC_INTFLAG_B12SRDY_Pos: u32 = 5;
pub const SUPC_INTFLAG_VREGRDY_Pos: u32 = 8;
pub const SUPC_INTFLAG_APWSRDY_Pos: u32 = 9;
pub const SUPC_INTFLAG_VCORERDY_Pos: u32 = 10;
pub const SUPC_STATUS_OFFSET: u32 = 12;
pub const SUPC_STATUS_BOD33RDY_Pos: u32 = 0;
pub const SUPC_STATUS_BOD33DET_Pos: u32 = 1;
pub const SUPC_STATUS_B33SRDY_Pos: u32 = 2;
pub const SUPC_STATUS_BOD12RDY_Pos: u32 = 3;
pub const SUPC_STATUS_BOD12DET_Pos: u32 = 4;
pub const SUPC_STATUS_B12SRDY_Pos: u32 = 5;
pub const SUPC_STATUS_VREGRDY_Pos: u32 = 8;
pub const SUPC_STATUS_APWSRDY_Pos: u32 = 9;
pub const SUPC_STATUS_VCORERDY_Pos: u32 = 10;
pub const SUPC_STATUS_BBPS_Pos: u32 = 11;
pub const SUPC_BOD33_OFFSET: u32 = 16;
pub const SUPC_BOD33_ENABLE_Pos: u32 = 1;
pub const SUPC_BOD33_HYST_Pos: u32 = 2;
pub const SUPC_BOD33_ACTION_Pos: u32 = 3;
pub const SUPC_BOD33_STDBYCFG_Pos: u32 = 5;
pub const SUPC_BOD33_RUNSTDBY_Pos: u32 = 6;
pub const SUPC_BOD33_RUNBKUP_Pos: u32 = 7;
pub const SUPC_BOD33_ACTCFG_Pos: u32 = 8;
pub const SUPC_BOD33_VMON_Pos: u32 = 10;
pub const SUPC_BOD33_PSEL_Pos: u32 = 12;
pub const SUPC_BOD33_LEVEL_Pos: u32 = 16;
pub const SUPC_BOD33_BKUPLEVEL_Pos: u32 = 24;
pub const SUPC_BOD12_OFFSET: u32 = 20;
pub const SUPC_BOD12_ENABLE_Pos: u32 = 1;
pub const SUPC_BOD12_HYST_Pos: u32 = 2;
pub const SUPC_BOD12_ACTION_Pos: u32 = 3;
pub const SUPC_BOD12_STDBYCFG_Pos: u32 = 5;
pub const SUPC_BOD12_RUNSTDBY_Pos: u32 = 6;
pub const SUPC_BOD12_ACTCFG_Pos: u32 = 8;
pub const SUPC_BOD12_PSEL_Pos: u32 = 12;
pub const SUPC_BOD12_LEVEL_Pos: u32 = 16;
pub const SUPC_VREG_OFFSET: u32 = 24;
pub const SUPC_VREG_ENABLE_Pos: u32 = 1;
pub const SUPC_VREG_SEL_Pos: u32 = 2;
pub const SUPC_VREG_STDBYPL0_Pos: u32 = 5;
pub const SUPC_VREG_RUNSTDBY_Pos: u32 = 6;
pub const SUPC_VREG_LPEFF_Pos: u32 = 8;
pub const SUPC_VREG_VSVSTEP_Pos: u32 = 16;
pub const SUPC_VREG_VSPER_Pos: u32 = 24;
pub const SUPC_VREF_OFFSET: u32 = 28;
pub const SUPC_VREF_TSEN_Pos: u32 = 1;
pub const SUPC_VREF_VREFOE_Pos: u32 = 2;
pub const SUPC_VREF_TSSEL_Pos: u32 = 3;
pub const SUPC_VREF_RUNSTDBY_Pos: u32 = 6;
pub const SUPC_VREF_ONDEMAND_Pos: u32 = 7;
pub const SUPC_VREF_SEL_Pos: u32 = 16;
pub const SUPC_BBPS_OFFSET: u32 = 32;
pub const SUPC_BBPS_CONF_Pos: u32 = 0;
pub const SUPC_BBPS_WAKEEN_Pos: u32 = 2;
pub const SUPC_BBPS_PSOKEN_Pos: u32 = 3;
pub const SUPC_BKOUT_OFFSET: u32 = 36;
pub const SUPC_BKOUT_EN_Pos: u32 = 0;
pub const SUPC_BKOUT_CLR_Pos: u32 = 8;
pub const SUPC_BKOUT_SET_Pos: u32 = 16;
pub const SUPC_BKOUT_RTCTGL_Pos: u32 = 24;
pub const SUPC_BKIN_OFFSET: u32 = 40;
pub const SUPC_BKIN_BKIN_Pos: u32 = 0;
pub const REV_TC: u32 = 512;
pub const TC_CTRLA_OFFSET: u32 = 0;
pub const TC_CTRLA_SWRST_Pos: u32 = 0;
pub const TC_CTRLA_ENABLE_Pos: u32 = 1;
pub const TC_CTRLA_MODE_Pos: u32 = 2;
pub const TC_CTRLA_PRESCSYNC_Pos: u32 = 4;
pub const TC_CTRLA_RUNSTDBY_Pos: u32 = 6;
pub const TC_CTRLA_ONDEMAND_Pos: u32 = 7;
pub const TC_CTRLA_PRESCALER_Pos: u32 = 8;
pub const TC_CTRLA_ALOCK_Pos: u32 = 11;
pub const TC_CTRLA_CAPTEN0_Pos: u32 = 16;
pub const TC_CTRLA_CAPTEN1_Pos: u32 = 17;
pub const TC_CTRLA_CAPTEN_Pos: u32 = 16;
pub const TC_CTRLA_COPEN0_Pos: u32 = 20;
pub const TC_CTRLA_COPEN1_Pos: u32 = 21;
pub const TC_CTRLA_COPEN_Pos: u32 = 20;
pub const TC_CTRLBCLR_OFFSET: u32 = 4;
pub const TC_CTRLBCLR_DIR_Pos: u32 = 0;
pub const TC_CTRLBCLR_LUPD_Pos: u32 = 1;
pub const TC_CTRLBCLR_ONESHOT_Pos: u32 = 2;
pub const TC_CTRLBCLR_CMD_Pos: u32 = 5;
pub const TC_CTRLBSET_OFFSET: u32 = 5;
pub const TC_CTRLBSET_DIR_Pos: u32 = 0;
pub const TC_CTRLBSET_LUPD_Pos: u32 = 1;
pub const TC_CTRLBSET_ONESHOT_Pos: u32 = 2;
pub const TC_CTRLBSET_CMD_Pos: u32 = 5;
pub const TC_EVCTRL_OFFSET: u32 = 6;
pub const TC_EVCTRL_EVACT_Pos: u32 = 0;
pub const TC_EVCTRL_TCINV_Pos: u32 = 4;
pub const TC_EVCTRL_TCEI_Pos: u32 = 5;
pub const TC_EVCTRL_OVFEO_Pos: u32 = 8;
pub const TC_EVCTRL_MCEO0_Pos: u32 = 12;
pub const TC_EVCTRL_MCEO1_Pos: u32 = 13;
pub const TC_EVCTRL_MCEO_Pos: u32 = 12;
pub const TC_INTENCLR_OFFSET: u32 = 8;
pub const TC_INTENCLR_OVF_Pos: u32 = 0;
pub const TC_INTENCLR_ERR_Pos: u32 = 1;
pub const TC_INTENCLR_MC0_Pos: u32 = 4;
pub const TC_INTENCLR_MC1_Pos: u32 = 5;
pub const TC_INTENCLR_MC_Pos: u32 = 4;
pub const TC_INTENSET_OFFSET: u32 = 9;
pub const TC_INTENSET_OVF_Pos: u32 = 0;
pub const TC_INTENSET_ERR_Pos: u32 = 1;
pub const TC_INTENSET_MC0_Pos: u32 = 4;
pub const TC_INTENSET_MC1_Pos: u32 = 5;
pub const TC_INTENSET_MC_Pos: u32 = 4;
pub const TC_INTFLAG_OFFSET: u32 = 10;
pub const TC_INTFLAG_OVF_Pos: u32 = 0;
pub const TC_INTFLAG_ERR_Pos: u32 = 1;
pub const TC_INTFLAG_MC0_Pos: u32 = 4;
pub const TC_INTFLAG_MC1_Pos: u32 = 5;
pub const TC_INTFLAG_MC_Pos: u32 = 4;
pub const TC_STATUS_OFFSET: u32 = 11;
pub const TC_STATUS_STOP_Pos: u32 = 0;
pub const TC_STATUS_SLAVE_Pos: u32 = 1;
pub const TC_STATUS_PERBUFV_Pos: u32 = 3;
pub const TC_STATUS_CCBUFV0_Pos: u32 = 4;
pub const TC_STATUS_CCBUFV1_Pos: u32 = 5;
pub const TC_STATUS_CCBUFV_Pos: u32 = 4;
pub const TC_WAVE_OFFSET: u32 = 12;
pub const TC_WAVE_WAVEGEN_Pos: u32 = 0;
pub const TC_DRVCTRL_OFFSET: u32 = 13;
pub const TC_DRVCTRL_INVEN0_Pos: u32 = 0;
pub const TC_DRVCTRL_INVEN1_Pos: u32 = 1;
pub const TC_DRVCTRL_INVEN_Pos: u32 = 0;
pub const TC_DBGCTRL_OFFSET: u32 = 15;
pub const TC_DBGCTRL_DBGRUN_Pos: u32 = 0;
pub const TC_SYNCBUSY_OFFSET: u32 = 16;
pub const TC_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const TC_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const TC_SYNCBUSY_CTRLB_Pos: u32 = 2;
pub const TC_SYNCBUSY_STATUS_Pos: u32 = 3;
pub const TC_SYNCBUSY_COUNT_Pos: u32 = 4;
pub const TC_SYNCBUSY_PER_Pos: u32 = 5;
pub const TC_SYNCBUSY_CC0_Pos: u32 = 6;
pub const TC_SYNCBUSY_CC1_Pos: u32 = 7;
pub const TC_SYNCBUSY_CC_Pos: u32 = 6;
pub const TC_COUNT16_COUNT_OFFSET: u32 = 20;
pub const TC_COUNT16_COUNT_COUNT_Pos: u32 = 0;
pub const TC_COUNT32_COUNT_OFFSET: u32 = 20;
pub const TC_COUNT32_COUNT_COUNT_Pos: u32 = 0;
pub const TC_COUNT8_COUNT_OFFSET: u32 = 20;
pub const TC_COUNT8_COUNT_COUNT_Pos: u32 = 0;
pub const TC_COUNT8_PER_OFFSET: u32 = 27;
pub const TC_COUNT8_PER_PER_Pos: u32 = 0;
pub const TC_COUNT16_CC_OFFSET: u32 = 28;
pub const TC_COUNT16_CC_CC_Pos: u32 = 0;
pub const TC_COUNT32_CC_OFFSET: u32 = 28;
pub const TC_COUNT32_CC_CC_Pos: u32 = 0;
pub const TC_COUNT8_CC_OFFSET: u32 = 28;
pub const TC_COUNT8_CC_CC_Pos: u32 = 0;
pub const TC_COUNT8_PERBUF_OFFSET: u32 = 47;
pub const TC_COUNT8_PERBUF_PERBUF_Pos: u32 = 0;
pub const TC_COUNT16_CCBUF_OFFSET: u32 = 48;
pub const TC_COUNT16_CCBUF_CCBUF_Pos: u32 = 0;
pub const TC_COUNT32_CCBUF_OFFSET: u32 = 48;
pub const TC_COUNT32_CCBUF_CCBUF_Pos: u32 = 0;
pub const TC_COUNT8_CCBUF_OFFSET: u32 = 48;
pub const TC_COUNT8_CCBUF_CCBUF_Pos: u32 = 0;
pub const REV_TCC: u32 = 768;
pub const TCC_CTRLA_OFFSET: u32 = 0;
pub const TCC_CTRLA_SWRST_Pos: u32 = 0;
pub const TCC_CTRLA_ENABLE_Pos: u32 = 1;
pub const TCC_CTRLA_RESOLUTION_Pos: u32 = 5;
pub const TCC_CTRLA_PRESCALER_Pos: u32 = 8;
pub const TCC_CTRLA_RUNSTDBY_Pos: u32 = 11;
pub const TCC_CTRLA_PRESCSYNC_Pos: u32 = 12;
pub const TCC_CTRLA_ALOCK_Pos: u32 = 14;
pub const TCC_CTRLA_MSYNC_Pos: u32 = 15;
pub const TCC_CTRLA_DMAOS_Pos: u32 = 23;
pub const TCC_CTRLA_CPTEN0_Pos: u32 = 24;
pub const TCC_CTRLA_CPTEN1_Pos: u32 = 25;
pub const TCC_CTRLA_CPTEN2_Pos: u32 = 26;
pub const TCC_CTRLA_CPTEN3_Pos: u32 = 27;
pub const TCC_CTRLA_CPTEN_Pos: u32 = 24;
pub const TCC_CTRLBCLR_OFFSET: u32 = 4;
pub const TCC_CTRLBCLR_DIR_Pos: u32 = 0;
pub const TCC_CTRLBCLR_LUPD_Pos: u32 = 1;
pub const TCC_CTRLBCLR_ONESHOT_Pos: u32 = 2;
pub const TCC_CTRLBCLR_IDXCMD_Pos: u32 = 3;
pub const TCC_CTRLBCLR_CMD_Pos: u32 = 5;
pub const TCC_CTRLBSET_OFFSET: u32 = 5;
pub const TCC_CTRLBSET_DIR_Pos: u32 = 0;
pub const TCC_CTRLBSET_LUPD_Pos: u32 = 1;
pub const TCC_CTRLBSET_ONESHOT_Pos: u32 = 2;
pub const TCC_CTRLBSET_IDXCMD_Pos: u32 = 3;
pub const TCC_CTRLBSET_CMD_Pos: u32 = 5;
pub const TCC_SYNCBUSY_OFFSET: u32 = 8;
pub const TCC_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const TCC_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const TCC_SYNCBUSY_CTRLB_Pos: u32 = 2;
pub const TCC_SYNCBUSY_STATUS_Pos: u32 = 3;
pub const TCC_SYNCBUSY_COUNT_Pos: u32 = 4;
pub const TCC_SYNCBUSY_PATT_Pos: u32 = 5;
pub const TCC_SYNCBUSY_WAVE_Pos: u32 = 6;
pub const TCC_SYNCBUSY_PER_Pos: u32 = 7;
pub const TCC_SYNCBUSY_CC0_Pos: u32 = 8;
pub const TCC_SYNCBUSY_CC1_Pos: u32 = 9;
pub const TCC_SYNCBUSY_CC2_Pos: u32 = 10;
pub const TCC_SYNCBUSY_CC3_Pos: u32 = 11;
pub const TCC_SYNCBUSY_CC_Pos: u32 = 8;
pub const TCC_FCTRLA_OFFSET: u32 = 12;
pub const TCC_FCTRLA_SRC_Pos: u32 = 0;
pub const TCC_FCTRLA_KEEP_Pos: u32 = 3;
pub const TCC_FCTRLA_QUAL_Pos: u32 = 4;
pub const TCC_FCTRLA_BLANK_Pos: u32 = 5;
pub const TCC_FCTRLA_RESTART_Pos: u32 = 7;
pub const TCC_FCTRLA_HALT_Pos: u32 = 8;
pub const TCC_FCTRLA_CHSEL_Pos: u32 = 10;
pub const TCC_FCTRLA_CAPTURE_Pos: u32 = 12;
pub const TCC_FCTRLA_BLANKPRESC_Pos: u32 = 15;
pub const TCC_FCTRLA_BLANKVAL_Pos: u32 = 16;
pub const TCC_FCTRLA_FILTERVAL_Pos: u32 = 24;
pub const TCC_FCTRLB_OFFSET: u32 = 16;
pub const TCC_FCTRLB_SRC_Pos: u32 = 0;
pub const TCC_FCTRLB_KEEP_Pos: u32 = 3;
pub const TCC_FCTRLB_QUAL_Pos: u32 = 4;
pub const TCC_FCTRLB_BLANK_Pos: u32 = 5;
pub const TCC_FCTRLB_RESTART_Pos: u32 = 7;
pub const TCC_FCTRLB_HALT_Pos: u32 = 8;
pub const TCC_FCTRLB_CHSEL_Pos: u32 = 10;
pub const TCC_FCTRLB_CAPTURE_Pos: u32 = 12;
pub const TCC_FCTRLB_BLANKPRESC_Pos: u32 = 15;
pub const TCC_FCTRLB_BLANKVAL_Pos: u32 = 16;
pub const TCC_FCTRLB_FILTERVAL_Pos: u32 = 24;
pub const TCC_WEXCTRL_OFFSET: u32 = 20;
pub const TCC_WEXCTRL_OTMX_Pos: u32 = 0;
pub const TCC_WEXCTRL_DTIEN0_Pos: u32 = 8;
pub const TCC_WEXCTRL_DTIEN1_Pos: u32 = 9;
pub const TCC_WEXCTRL_DTIEN2_Pos: u32 = 10;
pub const TCC_WEXCTRL_DTIEN3_Pos: u32 = 11;
pub const TCC_WEXCTRL_DTIEN_Pos: u32 = 8;
pub const TCC_WEXCTRL_DTLS_Pos: u32 = 16;
pub const TCC_WEXCTRL_DTHS_Pos: u32 = 24;
pub const TCC_DRVCTRL_OFFSET: u32 = 24;
pub const TCC_DRVCTRL_NRE0_Pos: u32 = 0;
pub const TCC_DRVCTRL_NRE1_Pos: u32 = 1;
pub const TCC_DRVCTRL_NRE2_Pos: u32 = 2;
pub const TCC_DRVCTRL_NRE3_Pos: u32 = 3;
pub const TCC_DRVCTRL_NRE4_Pos: u32 = 4;
pub const TCC_DRVCTRL_NRE5_Pos: u32 = 5;
pub const TCC_DRVCTRL_NRE6_Pos: u32 = 6;
pub const TCC_DRVCTRL_NRE7_Pos: u32 = 7;
pub const TCC_DRVCTRL_NRE_Pos: u32 = 0;
pub const TCC_DRVCTRL_NRV0_Pos: u32 = 8;
pub const TCC_DRVCTRL_NRV1_Pos: u32 = 9;
pub const TCC_DRVCTRL_NRV2_Pos: u32 = 10;
pub const TCC_DRVCTRL_NRV3_Pos: u32 = 11;
pub const TCC_DRVCTRL_NRV4_Pos: u32 = 12;
pub const TCC_DRVCTRL_NRV5_Pos: u32 = 13;
pub const TCC_DRVCTRL_NRV6_Pos: u32 = 14;
pub const TCC_DRVCTRL_NRV7_Pos: u32 = 15;
pub const TCC_DRVCTRL_NRV_Pos: u32 = 8;
pub const TCC_DRVCTRL_INVEN0_Pos: u32 = 16;
pub const TCC_DRVCTRL_INVEN1_Pos: u32 = 17;
pub const TCC_DRVCTRL_INVEN2_Pos: u32 = 18;
pub const TCC_DRVCTRL_INVEN3_Pos: u32 = 19;
pub const TCC_DRVCTRL_INVEN4_Pos: u32 = 20;
pub const TCC_DRVCTRL_INVEN5_Pos: u32 = 21;
pub const TCC_DRVCTRL_INVEN6_Pos: u32 = 22;
pub const TCC_DRVCTRL_INVEN7_Pos: u32 = 23;
pub const TCC_DRVCTRL_INVEN_Pos: u32 = 16;
pub const TCC_DRVCTRL_FILTERVAL0_Pos: u32 = 24;
pub const TCC_DRVCTRL_FILTERVAL1_Pos: u32 = 28;
pub const TCC_DBGCTRL_OFFSET: u32 = 30;
pub const TCC_DBGCTRL_DBGRUN_Pos: u32 = 0;
pub const TCC_DBGCTRL_FDDBD_Pos: u32 = 2;
pub const TCC_EVCTRL_OFFSET: u32 = 32;
pub const TCC_EVCTRL_EVACT0_Pos: u32 = 0;
pub const TCC_EVCTRL_EVACT1_Pos: u32 = 3;
pub const TCC_EVCTRL_CNTSEL_Pos: u32 = 6;
pub const TCC_EVCTRL_OVFEO_Pos: u32 = 8;
pub const TCC_EVCTRL_TRGEO_Pos: u32 = 9;
pub const TCC_EVCTRL_CNTEO_Pos: u32 = 10;
pub const TCC_EVCTRL_TCINV0_Pos: u32 = 12;
pub const TCC_EVCTRL_TCINV1_Pos: u32 = 13;
pub const TCC_EVCTRL_TCINV_Pos: u32 = 12;
pub const TCC_EVCTRL_TCEI0_Pos: u32 = 14;
pub const TCC_EVCTRL_TCEI1_Pos: u32 = 15;
pub const TCC_EVCTRL_TCEI_Pos: u32 = 14;
pub const TCC_EVCTRL_MCEI0_Pos: u32 = 16;
pub const TCC_EVCTRL_MCEI1_Pos: u32 = 17;
pub const TCC_EVCTRL_MCEI2_Pos: u32 = 18;
pub const TCC_EVCTRL_MCEI3_Pos: u32 = 19;
pub const TCC_EVCTRL_MCEI_Pos: u32 = 16;
pub const TCC_EVCTRL_MCEO0_Pos: u32 = 24;
pub const TCC_EVCTRL_MCEO1_Pos: u32 = 25;
pub const TCC_EVCTRL_MCEO2_Pos: u32 = 26;
pub const TCC_EVCTRL_MCEO3_Pos: u32 = 27;
pub const TCC_EVCTRL_MCEO_Pos: u32 = 24;
pub const TCC_INTENCLR_OFFSET: u32 = 36;
pub const TCC_INTENCLR_OVF_Pos: u32 = 0;
pub const TCC_INTENCLR_TRG_Pos: u32 = 1;
pub const TCC_INTENCLR_CNT_Pos: u32 = 2;
pub const TCC_INTENCLR_ERR_Pos: u32 = 3;
pub const TCC_INTENCLR_UFS_Pos: u32 = 10;
pub const TCC_INTENCLR_DFS_Pos: u32 = 11;
pub const TCC_INTENCLR_FAULTA_Pos: u32 = 12;
pub const TCC_INTENCLR_FAULTB_Pos: u32 = 13;
pub const TCC_INTENCLR_FAULT0_Pos: u32 = 14;
pub const TCC_INTENCLR_FAULT1_Pos: u32 = 15;
pub const TCC_INTENCLR_MC0_Pos: u32 = 16;
pub const TCC_INTENCLR_MC1_Pos: u32 = 17;
pub const TCC_INTENCLR_MC2_Pos: u32 = 18;
pub const TCC_INTENCLR_MC3_Pos: u32 = 19;
pub const TCC_INTENCLR_MC_Pos: u32 = 16;
pub const TCC_INTENSET_OFFSET: u32 = 40;
pub const TCC_INTENSET_OVF_Pos: u32 = 0;
pub const TCC_INTENSET_TRG_Pos: u32 = 1;
pub const TCC_INTENSET_CNT_Pos: u32 = 2;
pub const TCC_INTENSET_ERR_Pos: u32 = 3;
pub const TCC_INTENSET_UFS_Pos: u32 = 10;
pub const TCC_INTENSET_DFS_Pos: u32 = 11;
pub const TCC_INTENSET_FAULTA_Pos: u32 = 12;
pub const TCC_INTENSET_FAULTB_Pos: u32 = 13;
pub const TCC_INTENSET_FAULT0_Pos: u32 = 14;
pub const TCC_INTENSET_FAULT1_Pos: u32 = 15;
pub const TCC_INTENSET_MC0_Pos: u32 = 16;
pub const TCC_INTENSET_MC1_Pos: u32 = 17;
pub const TCC_INTENSET_MC2_Pos: u32 = 18;
pub const TCC_INTENSET_MC3_Pos: u32 = 19;
pub const TCC_INTENSET_MC_Pos: u32 = 16;
pub const TCC_INTFLAG_OFFSET: u32 = 44;
pub const TCC_INTFLAG_OVF_Pos: u32 = 0;
pub const TCC_INTFLAG_TRG_Pos: u32 = 1;
pub const TCC_INTFLAG_CNT_Pos: u32 = 2;
pub const TCC_INTFLAG_ERR_Pos: u32 = 3;
pub const TCC_INTFLAG_UFS_Pos: u32 = 10;
pub const TCC_INTFLAG_DFS_Pos: u32 = 11;
pub const TCC_INTFLAG_FAULTA_Pos: u32 = 12;
pub const TCC_INTFLAG_FAULTB_Pos: u32 = 13;
pub const TCC_INTFLAG_FAULT0_Pos: u32 = 14;
pub const TCC_INTFLAG_FAULT1_Pos: u32 = 15;
pub const TCC_INTFLAG_MC0_Pos: u32 = 16;
pub const TCC_INTFLAG_MC1_Pos: u32 = 17;
pub const TCC_INTFLAG_MC2_Pos: u32 = 18;
pub const TCC_INTFLAG_MC3_Pos: u32 = 19;
pub const TCC_INTFLAG_MC_Pos: u32 = 16;
pub const TCC_STATUS_OFFSET: u32 = 48;
pub const TCC_STATUS_STOP_Pos: u32 = 0;
pub const TCC_STATUS_IDX_Pos: u32 = 1;
pub const TCC_STATUS_UFS_Pos: u32 = 2;
pub const TCC_STATUS_DFS_Pos: u32 = 3;
pub const TCC_STATUS_SLAVE_Pos: u32 = 4;
pub const TCC_STATUS_PATTBUFV_Pos: u32 = 5;
pub const TCC_STATUS_PERBUFV_Pos: u32 = 7;
pub const TCC_STATUS_FAULTAIN_Pos: u32 = 8;
pub const TCC_STATUS_FAULTBIN_Pos: u32 = 9;
pub const TCC_STATUS_FAULT0IN_Pos: u32 = 10;
pub const TCC_STATUS_FAULT1IN_Pos: u32 = 11;
pub const TCC_STATUS_FAULTA_Pos: u32 = 12;
pub const TCC_STATUS_FAULTB_Pos: u32 = 13;
pub const TCC_STATUS_FAULT0_Pos: u32 = 14;
pub const TCC_STATUS_FAULT1_Pos: u32 = 15;
pub const TCC_STATUS_CCBUFV0_Pos: u32 = 16;
pub const TCC_STATUS_CCBUFV1_Pos: u32 = 17;
pub const TCC_STATUS_CCBUFV2_Pos: u32 = 18;
pub const TCC_STATUS_CCBUFV3_Pos: u32 = 19;
pub const TCC_STATUS_CCBUFV_Pos: u32 = 16;
pub const TCC_STATUS_CMP0_Pos: u32 = 24;
pub const TCC_STATUS_CMP1_Pos: u32 = 25;
pub const TCC_STATUS_CMP2_Pos: u32 = 26;
pub const TCC_STATUS_CMP3_Pos: u32 = 27;
pub const TCC_STATUS_CMP_Pos: u32 = 24;
pub const TCC_COUNT_OFFSET: u32 = 52;
pub const TCC_COUNT_DITH4_COUNT_Pos: u32 = 4;
pub const TCC_COUNT_DITH5_COUNT_Pos: u32 = 5;
pub const TCC_COUNT_DITH6_COUNT_Pos: u32 = 6;
pub const TCC_COUNT_COUNT_Pos: u32 = 0;
pub const TCC_PATT_OFFSET: u32 = 56;
pub const TCC_PATT_PGE0_Pos: u32 = 0;
pub const TCC_PATT_PGE1_Pos: u32 = 1;
pub const TCC_PATT_PGE2_Pos: u32 = 2;
pub const TCC_PATT_PGE3_Pos: u32 = 3;
pub const TCC_PATT_PGE4_Pos: u32 = 4;
pub const TCC_PATT_PGE5_Pos: u32 = 5;
pub const TCC_PATT_PGE6_Pos: u32 = 6;
pub const TCC_PATT_PGE7_Pos: u32 = 7;
pub const TCC_PATT_PGE_Pos: u32 = 0;
pub const TCC_PATT_PGV0_Pos: u32 = 8;
pub const TCC_PATT_PGV1_Pos: u32 = 9;
pub const TCC_PATT_PGV2_Pos: u32 = 10;
pub const TCC_PATT_PGV3_Pos: u32 = 11;
pub const TCC_PATT_PGV4_Pos: u32 = 12;
pub const TCC_PATT_PGV5_Pos: u32 = 13;
pub const TCC_PATT_PGV6_Pos: u32 = 14;
pub const TCC_PATT_PGV7_Pos: u32 = 15;
pub const TCC_PATT_PGV_Pos: u32 = 8;
pub const TCC_WAVE_OFFSET: u32 = 60;
pub const TCC_WAVE_WAVEGEN_Pos: u32 = 0;
pub const TCC_WAVE_RAMP_Pos: u32 = 4;
pub const TCC_WAVE_CIPEREN_Pos: u32 = 7;
pub const TCC_WAVE_CICCEN0_Pos: u32 = 8;
pub const TCC_WAVE_CICCEN1_Pos: u32 = 9;
pub const TCC_WAVE_CICCEN2_Pos: u32 = 10;
pub const TCC_WAVE_CICCEN3_Pos: u32 = 11;
pub const TCC_WAVE_CICCEN_Pos: u32 = 8;
pub const TCC_WAVE_POL0_Pos: u32 = 16;
pub const TCC_WAVE_POL1_Pos: u32 = 17;
pub const TCC_WAVE_POL2_Pos: u32 = 18;
pub const TCC_WAVE_POL3_Pos: u32 = 19;
pub const TCC_WAVE_POL_Pos: u32 = 16;
pub const TCC_WAVE_SWAP0_Pos: u32 = 24;
pub const TCC_WAVE_SWAP1_Pos: u32 = 25;
pub const TCC_WAVE_SWAP2_Pos: u32 = 26;
pub const TCC_WAVE_SWAP3_Pos: u32 = 27;
pub const TCC_WAVE_SWAP_Pos: u32 = 24;
pub const TCC_PER_OFFSET: u32 = 64;
pub const TCC_PER_DITH4_DITHER_Pos: u32 = 0;
pub const TCC_PER_DITH4_PER_Pos: u32 = 4;
pub const TCC_PER_DITH5_DITHER_Pos: u32 = 0;
pub const TCC_PER_DITH5_PER_Pos: u32 = 5;
pub const TCC_PER_DITH6_DITHER_Pos: u32 = 0;
pub const TCC_PER_DITH6_PER_Pos: u32 = 6;
pub const TCC_PER_PER_Pos: u32 = 0;
pub const TCC_CC_OFFSET: u32 = 68;
pub const TCC_CC_DITH4_DITHER_Pos: u32 = 0;
pub const TCC_CC_DITH4_CC_Pos: u32 = 4;
pub const TCC_CC_DITH5_DITHER_Pos: u32 = 0;
pub const TCC_CC_DITH5_CC_Pos: u32 = 5;
pub const TCC_CC_DITH6_DITHER_Pos: u32 = 0;
pub const TCC_CC_DITH6_CC_Pos: u32 = 6;
pub const TCC_CC_CC_Pos: u32 = 0;
pub const TCC_PATTBUF_OFFSET: u32 = 100;
pub const TCC_PATTBUF_PGEB0_Pos: u32 = 0;
pub const TCC_PATTBUF_PGEB1_Pos: u32 = 1;
pub const TCC_PATTBUF_PGEB2_Pos: u32 = 2;
pub const TCC_PATTBUF_PGEB3_Pos: u32 = 3;
pub const TCC_PATTBUF_PGEB4_Pos: u32 = 4;
pub const TCC_PATTBUF_PGEB5_Pos: u32 = 5;
pub const TCC_PATTBUF_PGEB6_Pos: u32 = 6;
pub const TCC_PATTBUF_PGEB7_Pos: u32 = 7;
pub const TCC_PATTBUF_PGEB_Pos: u32 = 0;
pub const TCC_PATTBUF_PGVB0_Pos: u32 = 8;
pub const TCC_PATTBUF_PGVB1_Pos: u32 = 9;
pub const TCC_PATTBUF_PGVB2_Pos: u32 = 10;
pub const TCC_PATTBUF_PGVB3_Pos: u32 = 11;
pub const TCC_PATTBUF_PGVB4_Pos: u32 = 12;
pub const TCC_PATTBUF_PGVB5_Pos: u32 = 13;
pub const TCC_PATTBUF_PGVB6_Pos: u32 = 14;
pub const TCC_PATTBUF_PGVB7_Pos: u32 = 15;
pub const TCC_PATTBUF_PGVB_Pos: u32 = 8;
pub const TCC_PERBUF_OFFSET: u32 = 108;
pub const TCC_PERBUF_DITH4_DITHERBUF_Pos: u32 = 0;
pub const TCC_PERBUF_DITH4_PERBUF_Pos: u32 = 4;
pub const TCC_PERBUF_DITH5_DITHERBUF_Pos: u32 = 0;
pub const TCC_PERBUF_DITH5_PERBUF_Pos: u32 = 5;
pub const TCC_PERBUF_DITH6_DITHERBUF_Pos: u32 = 0;
pub const TCC_PERBUF_DITH6_PERBUF_Pos: u32 = 6;
pub const TCC_PERBUF_PERBUF_Pos: u32 = 0;
pub const TCC_CCBUF_OFFSET: u32 = 112;
pub const TCC_CCBUF_DITH4_CCBUF_Pos: u32 = 0;
pub const TCC_CCBUF_DITH4_DITHERBUF_Pos: u32 = 4;
pub const TCC_CCBUF_DITH5_DITHERBUF_Pos: u32 = 0;
pub const TCC_CCBUF_DITH5_CCBUF_Pos: u32 = 5;
pub const TCC_CCBUF_DITH6_DITHERBUF_Pos: u32 = 0;
pub const TCC_CCBUF_DITH6_CCBUF_Pos: u32 = 6;
pub const TCC_CCBUF_CCBUF_Pos: u32 = 0;
pub const REV_TRNG: u32 = 257;
pub const TRNG_CTRLA_OFFSET: u32 = 0;
pub const TRNG_CTRLA_ENABLE_Pos: u32 = 1;
pub const TRNG_CTRLA_RUNSTDBY_Pos: u32 = 6;
pub const TRNG_EVCTRL_OFFSET: u32 = 4;
pub const TRNG_EVCTRL_DATARDYEO_Pos: u32 = 0;
pub const TRNG_INTENCLR_OFFSET: u32 = 8;
pub const TRNG_INTENCLR_DATARDY_Pos: u32 = 0;
pub const TRNG_INTENSET_OFFSET: u32 = 9;
pub const TRNG_INTENSET_DATARDY_Pos: u32 = 0;
pub const TRNG_INTFLAG_OFFSET: u32 = 10;
pub const TRNG_INTFLAG_DATARDY_Pos: u32 = 0;
pub const TRNG_DATA_OFFSET: u32 = 32;
pub const TRNG_DATA_DATA_Pos: u32 = 0;
pub const REV_USB: u32 = 273;
pub const USB_CTRLA_OFFSET: u32 = 0;
pub const USB_CTRLA_SWRST_Pos: u32 = 0;
pub const USB_CTRLA_ENABLE_Pos: u32 = 1;
pub const USB_CTRLA_RUNSTDBY_Pos: u32 = 2;
pub const USB_CTRLA_MODE_Pos: u32 = 7;
pub const USB_SYNCBUSY_OFFSET: u32 = 2;
pub const USB_SYNCBUSY_SWRST_Pos: u32 = 0;
pub const USB_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const USB_QOSCTRL_OFFSET: u32 = 3;
pub const USB_QOSCTRL_CQOS_Pos: u32 = 0;
pub const USB_QOSCTRL_DQOS_Pos: u32 = 2;
pub const USB_DEVICE_CTRLB_OFFSET: u32 = 8;
pub const USB_DEVICE_CTRLB_DETACH_Pos: u32 = 0;
pub const USB_DEVICE_CTRLB_UPRSM_Pos: u32 = 1;
pub const USB_DEVICE_CTRLB_SPDCONF_Pos: u32 = 2;
pub const USB_DEVICE_CTRLB_NREPLY_Pos: u32 = 4;
pub const USB_DEVICE_CTRLB_TSTJ_Pos: u32 = 5;
pub const USB_DEVICE_CTRLB_TSTK_Pos: u32 = 6;
pub const USB_DEVICE_CTRLB_TSTPCKT_Pos: u32 = 7;
pub const USB_DEVICE_CTRLB_OPMODE2_Pos: u32 = 8;
pub const USB_DEVICE_CTRLB_GNAK_Pos: u32 = 9;
pub const USB_DEVICE_CTRLB_LPMHDSK_Pos: u32 = 10;
pub const USB_DEVICE_DADD_OFFSET: u32 = 10;
pub const USB_DEVICE_DADD_DADD_Pos: u32 = 0;
pub const USB_DEVICE_DADD_ADDEN_Pos: u32 = 7;
pub const USB_DEVICE_STATUS_OFFSET: u32 = 12;
pub const USB_DEVICE_STATUS_SPEED_Pos: u32 = 2;
pub const USB_DEVICE_STATUS_LINESTATE_Pos: u32 = 6;
pub const USB_FSMSTATUS_OFFSET: u32 = 13;
pub const USB_FSMSTATUS_FSMSTATE_Pos: u32 = 0;
pub const USB_DEVICE_FNUM_OFFSET: u32 = 16;
pub const USB_DEVICE_FNUM_MFNUM_Pos: u32 = 0;
pub const USB_DEVICE_FNUM_FNUM_Pos: u32 = 3;
pub const USB_DEVICE_FNUM_FNCERR_Pos: u32 = 15;
pub const USB_DEVICE_INTENCLR_OFFSET: u32 = 20;
pub const USB_DEVICE_INTENCLR_SUSPEND_Pos: u32 = 0;
pub const USB_DEVICE_INTENCLR_MSOF_Pos: u32 = 1;
pub const USB_DEVICE_INTENCLR_SOF_Pos: u32 = 2;
pub const USB_DEVICE_INTENCLR_EORST_Pos: u32 = 3;
pub const USB_DEVICE_INTENCLR_WAKEUP_Pos: u32 = 4;
pub const USB_DEVICE_INTENCLR_EORSM_Pos: u32 = 5;
pub const USB_DEVICE_INTENCLR_UPRSM_Pos: u32 = 6;
pub const USB_DEVICE_INTENCLR_RAMACER_Pos: u32 = 7;
pub const USB_DEVICE_INTENCLR_LPMNYET_Pos: u32 = 8;
pub const USB_DEVICE_INTENCLR_LPMSUSP_Pos: u32 = 9;
pub const USB_DEVICE_INTENSET_OFFSET: u32 = 24;
pub const USB_DEVICE_INTENSET_SUSPEND_Pos: u32 = 0;
pub const USB_DEVICE_INTENSET_MSOF_Pos: u32 = 1;
pub const USB_DEVICE_INTENSET_SOF_Pos: u32 = 2;
pub const USB_DEVICE_INTENSET_EORST_Pos: u32 = 3;
pub const USB_DEVICE_INTENSET_WAKEUP_Pos: u32 = 4;
pub const USB_DEVICE_INTENSET_EORSM_Pos: u32 = 5;
pub const USB_DEVICE_INTENSET_UPRSM_Pos: u32 = 6;
pub const USB_DEVICE_INTENSET_RAMACER_Pos: u32 = 7;
pub const USB_DEVICE_INTENSET_LPMNYET_Pos: u32 = 8;
pub const USB_DEVICE_INTENSET_LPMSUSP_Pos: u32 = 9;
pub const USB_DEVICE_INTFLAG_OFFSET: u32 = 28;
pub const USB_DEVICE_INTFLAG_SUSPEND_Pos: u32 = 0;
pub const USB_DEVICE_INTFLAG_MSOF_Pos: u32 = 1;
pub const USB_DEVICE_INTFLAG_SOF_Pos: u32 = 2;
pub const USB_DEVICE_INTFLAG_EORST_Pos: u32 = 3;
pub const USB_DEVICE_INTFLAG_WAKEUP_Pos: u32 = 4;
pub const USB_DEVICE_INTFLAG_EORSM_Pos: u32 = 5;
pub const USB_DEVICE_INTFLAG_UPRSM_Pos: u32 = 6;
pub const USB_DEVICE_INTFLAG_RAMACER_Pos: u32 = 7;
pub const USB_DEVICE_INTFLAG_LPMNYET_Pos: u32 = 8;
pub const USB_DEVICE_INTFLAG_LPMSUSP_Pos: u32 = 9;
pub const USB_DEVICE_EPINTSMRY_OFFSET: u32 = 32;
pub const USB_DEVICE_EPINTSMRY_EPINT0_Pos: u32 = 0;
pub const USB_DEVICE_EPINTSMRY_EPINT1_Pos: u32 = 1;
pub const USB_DEVICE_EPINTSMRY_EPINT2_Pos: u32 = 2;
pub const USB_DEVICE_EPINTSMRY_EPINT3_Pos: u32 = 3;
pub const USB_DEVICE_EPINTSMRY_EPINT4_Pos: u32 = 4;
pub const USB_DEVICE_EPINTSMRY_EPINT5_Pos: u32 = 5;
pub const USB_DEVICE_EPINTSMRY_EPINT6_Pos: u32 = 6;
pub const USB_DEVICE_EPINTSMRY_EPINT7_Pos: u32 = 7;
pub const USB_DEVICE_EPINTSMRY_EPINT_Pos: u32 = 0;
pub const USB_DESCADD_OFFSET: u32 = 36;
pub const USB_DESCADD_DESCADD_Pos: u32 = 0;
pub const USB_PADCAL_OFFSET: u32 = 40;
pub const USB_PADCAL_TRANSP_Pos: u32 = 0;
pub const USB_PADCAL_TRANSN_Pos: u32 = 6;
pub const USB_PADCAL_TRIM_Pos: u32 = 12;
pub const USB_DEVICE_EPCFG_OFFSET: u32 = 256;
pub const USB_DEVICE_EPCFG_EPTYPE0_Pos: u32 = 0;
pub const USB_DEVICE_EPCFG_EPTYPE1_Pos: u32 = 4;
pub const USB_DEVICE_EPCFG_NYETDIS_Pos: u32 = 7;
pub const USB_DEVICE_EPSTATUSCLR_OFFSET: u32 = 260;
pub const USB_DEVICE_EPSTATUSCLR_DTGLOUT_Pos: u32 = 0;
pub const USB_DEVICE_EPSTATUSCLR_DTGLIN_Pos: u32 = 1;
pub const USB_DEVICE_EPSTATUSCLR_CURBK_Pos: u32 = 2;
pub const USB_DEVICE_EPSTATUSCLR_STALLRQ0_Pos: u32 = 4;
pub const USB_DEVICE_EPSTATUSCLR_STALLRQ1_Pos: u32 = 5;
pub const USB_DEVICE_EPSTATUSCLR_STALLRQ_Pos: u32 = 4;
pub const USB_DEVICE_EPSTATUSCLR_BK0RDY_Pos: u32 = 6;
pub const USB_DEVICE_EPSTATUSCLR_BK1RDY_Pos: u32 = 7;
pub const USB_DEVICE_EPSTATUSSET_OFFSET: u32 = 261;
pub const USB_DEVICE_EPSTATUSSET_DTGLOUT_Pos: u32 = 0;
pub const USB_DEVICE_EPSTATUSSET_DTGLIN_Pos: u32 = 1;
pub const USB_DEVICE_EPSTATUSSET_CURBK_Pos: u32 = 2;
pub const USB_DEVICE_EPSTATUSSET_STALLRQ0_Pos: u32 = 4;
pub const USB_DEVICE_EPSTATUSSET_STALLRQ1_Pos: u32 = 5;
pub const USB_DEVICE_EPSTATUSSET_STALLRQ_Pos: u32 = 4;
pub const USB_DEVICE_EPSTATUSSET_BK0RDY_Pos: u32 = 6;
pub const USB_DEVICE_EPSTATUSSET_BK1RDY_Pos: u32 = 7;
pub const USB_DEVICE_EPSTATUS_OFFSET: u32 = 262;
pub const USB_DEVICE_EPSTATUS_DTGLOUT_Pos: u32 = 0;
pub const USB_DEVICE_EPSTATUS_DTGLIN_Pos: u32 = 1;
pub const USB_DEVICE_EPSTATUS_CURBK_Pos: u32 = 2;
pub const USB_DEVICE_EPSTATUS_STALLRQ0_Pos: u32 = 4;
pub const USB_DEVICE_EPSTATUS_STALLRQ1_Pos: u32 = 5;
pub const USB_DEVICE_EPSTATUS_STALLRQ_Pos: u32 = 4;
pub const USB_DEVICE_EPSTATUS_BK0RDY_Pos: u32 = 6;
pub const USB_DEVICE_EPSTATUS_BK1RDY_Pos: u32 = 7;
pub const USB_DEVICE_EPINTFLAG_OFFSET: u32 = 263;
pub const USB_DEVICE_EPINTFLAG_TRCPT0_Pos: u32 = 0;
pub const USB_DEVICE_EPINTFLAG_TRCPT1_Pos: u32 = 1;
pub const USB_DEVICE_EPINTFLAG_TRCPT_Pos: u32 = 0;
pub const USB_DEVICE_EPINTFLAG_TRFAIL0_Pos: u32 = 2;
pub const USB_DEVICE_EPINTFLAG_TRFAIL1_Pos: u32 = 3;
pub const USB_DEVICE_EPINTFLAG_TRFAIL_Pos: u32 = 2;
pub const USB_DEVICE_EPINTFLAG_RXSTP_Pos: u32 = 4;
pub const USB_DEVICE_EPINTFLAG_STALL0_Pos: u32 = 5;
pub const USB_DEVICE_EPINTFLAG_STALL1_Pos: u32 = 6;
pub const USB_DEVICE_EPINTFLAG_STALL_Pos: u32 = 5;
pub const USB_DEVICE_EPINTENCLR_OFFSET: u32 = 264;
pub const USB_DEVICE_EPINTENCLR_TRCPT0_Pos: u32 = 0;
pub const USB_DEVICE_EPINTENCLR_TRCPT1_Pos: u32 = 1;
pub const USB_DEVICE_EPINTENCLR_TRCPT_Pos: u32 = 0;
pub const USB_DEVICE_EPINTENCLR_TRFAIL0_Pos: u32 = 2;
pub const USB_DEVICE_EPINTENCLR_TRFAIL1_Pos: u32 = 3;
pub const USB_DEVICE_EPINTENCLR_TRFAIL_Pos: u32 = 2;
pub const USB_DEVICE_EPINTENCLR_RXSTP_Pos: u32 = 4;
pub const USB_DEVICE_EPINTENCLR_STALL0_Pos: u32 = 5;
pub const USB_DEVICE_EPINTENCLR_STALL1_Pos: u32 = 6;
pub const USB_DEVICE_EPINTENCLR_STALL_Pos: u32 = 5;
pub const USB_DEVICE_EPINTENSET_OFFSET: u32 = 265;
pub const USB_DEVICE_EPINTENSET_TRCPT0_Pos: u32 = 0;
pub const USB_DEVICE_EPINTENSET_TRCPT1_Pos: u32 = 1;
pub const USB_DEVICE_EPINTENSET_TRCPT_Pos: u32 = 0;
pub const USB_DEVICE_EPINTENSET_TRFAIL0_Pos: u32 = 2;
pub const USB_DEVICE_EPINTENSET_TRFAIL1_Pos: u32 = 3;
pub const USB_DEVICE_EPINTENSET_TRFAIL_Pos: u32 = 2;
pub const USB_DEVICE_EPINTENSET_RXSTP_Pos: u32 = 4;
pub const USB_DEVICE_EPINTENSET_STALL0_Pos: u32 = 5;
pub const USB_DEVICE_EPINTENSET_STALL1_Pos: u32 = 6;
pub const USB_DEVICE_EPINTENSET_STALL_Pos: u32 = 5;
pub const USB_DEVICE_ADDR_OFFSET: u32 = 0;
pub const USB_DEVICE_ADDR_ADDR_Pos: u32 = 0;
pub const USB_DEVICE_PCKSIZE_OFFSET: u32 = 4;
pub const USB_DEVICE_PCKSIZE_BYTE_COUNT_Pos: u32 = 0;
pub const USB_DEVICE_PCKSIZE_MULTI_PACKET_SIZE_Pos: u32 = 14;
pub const USB_DEVICE_PCKSIZE_SIZE_Pos: u32 = 28;
pub const USB_DEVICE_PCKSIZE_AUTO_ZLP_Pos: u32 = 31;
pub const USB_DEVICE_EXTREG_OFFSET: u32 = 8;
pub const USB_DEVICE_EXTREG_SUBPID_Pos: u32 = 0;
pub const USB_DEVICE_EXTREG_VARIABLE_Pos: u32 = 4;
pub const USB_DEVICE_STATUS_BK_OFFSET: u32 = 10;
pub const USB_DEVICE_STATUS_BK_CRCERR_Pos: u32 = 0;
pub const USB_DEVICE_STATUS_BK_ERRORFLOW_Pos: u32 = 1;
pub const REV_WDT: u32 = 257;
pub const WDT_CTRLA_OFFSET: u32 = 0;
pub const WDT_CTRLA_ENABLE_Pos: u32 = 1;
pub const WDT_CTRLA_WEN_Pos: u32 = 2;
pub const WDT_CTRLA_ALWAYSON_Pos: u32 = 7;
pub const WDT_CONFIG_OFFSET: u32 = 1;
pub const WDT_CONFIG_PER_Pos: u32 = 0;
pub const WDT_CONFIG_WINDOW_Pos: u32 = 4;
pub const WDT_EWCTRL_OFFSET: u32 = 2;
pub const WDT_EWCTRL_EWOFFSET_Pos: u32 = 0;
pub const WDT_INTENCLR_OFFSET: u32 = 4;
pub const WDT_INTENCLR_EW_Pos: u32 = 0;
pub const WDT_INTENSET_OFFSET: u32 = 5;
pub const WDT_INTENSET_EW_Pos: u32 = 0;
pub const WDT_INTFLAG_OFFSET: u32 = 6;
pub const WDT_INTFLAG_EW_Pos: u32 = 0;
pub const WDT_SYNCBUSY_OFFSET: u32 = 8;
pub const WDT_SYNCBUSY_ENABLE_Pos: u32 = 1;
pub const WDT_SYNCBUSY_WEN_Pos: u32 = 2;
pub const WDT_SYNCBUSY_ALWAYSON_Pos: u32 = 3;
pub const WDT_SYNCBUSY_CLEAR_Pos: u32 = 4;
pub const WDT_CLEAR_OFFSET: u32 = 12;
pub const WDT_CLEAR_CLEAR_Pos: u32 = 0;
pub const AC_COMPCTRL_MUXNEG_OPAMP: u32 = 7;
pub const AC_GCLK_ID: u32 = 26;
pub const AC_NUM_CMP: u32 = 2;
pub const AC_PAIRS: u32 = 1;
pub const ADC_DMAC_ID_RESRDY: u32 = 31;
pub const ADC_EXTCHANNEL_MSB: u32 = 19;
pub const ADC_GCLK_ID: u32 = 25;
pub const ADC_INT_CH30: u32 = 2;
pub const ADC_MASTER_SLAVE_MODE: u32 = 0;
pub const AES_DMAC_ID_RD: u32 = 36;
pub const AES_DMAC_ID_WR: u32 = 35;
pub const CCL_GCLK_ID: u32 = 28;
pub const CCL_IO_NUM: u32 = 12;
pub const CCL_LUT_NUM: u32 = 4;
pub const CCL_SEQ_NUM: u32 = 2;
pub const DMAC_CH_BITS: u32 = 4;
pub const DMAC_CH_NUM: u32 = 16;
pub const DMAC_CLK_AHB_ID: u32 = 3;
pub const DMAC_EVIN_NUM: u32 = 4;
pub const DMAC_EVOUT_NUM: u32 = 4;
pub const DMAC_LVL_BITS: u32 = 2;
pub const DMAC_LVL_NUM: u32 = 4;
pub const DMAC_QOSCTRL_D_RESETVALUE: u32 = 2;
pub const DMAC_QOSCTRL_F_RESETVALUE: u32 = 2;
pub const DMAC_QOSCTRL_WRB_RESETVALUE: u32 = 2;
pub const DMAC_TRIG_BITS: u32 = 6;
pub const DMAC_TRIG_NUM: u32 = 40;
pub const DSU_CLK_AHB_ID: u32 = 5;
pub const EIC_EXTINT_NUM: u32 = 16;
pub const EIC_GCLK_ID: u32 = 3;
pub const EIC_NUMBER_OF_CONFIG_REGS: u32 = 2;
pub const EIC_NUMBER_OF_INTERRUPTS: u32 = 16;
pub const EVSYS_CHANNELS: u32 = 8;
pub const EVSYS_CHANNELS_BITS: u32 = 3;
pub const EVSYS_CHANNELS_MSB: u32 = 7;
pub const EVSYS_EXTEVT_NUM: u32 = 0;
pub const EVSYS_GCLK_ID_0: u32 = 7;
pub const EVSYS_GCLK_ID_1: u32 = 8;
pub const EVSYS_GCLK_ID_2: u32 = 9;
pub const EVSYS_GCLK_ID_3: u32 = 10;
pub const EVSYS_GCLK_ID_4: u32 = 11;
pub const EVSYS_GCLK_ID_5: u32 = 12;
pub const EVSYS_GCLK_ID_6: u32 = 13;
pub const EVSYS_GCLK_ID_7: u32 = 14;
pub const EVSYS_GCLK_ID_LSB: u32 = 7;
pub const EVSYS_GCLK_ID_MSB: u32 = 14;
pub const EVSYS_GCLK_ID_SIZE: u32 = 8;
pub const EVSYS_GENERATORS: u32 = 71;
pub const EVSYS_GENERATORS_BITS: u32 = 7;
pub const EVSYS_USERS: u32 = 31;
pub const EVSYS_USERS_BITS: u32 = 5;
pub const EVSYS_ID_GEN_OSCCTRL_XOSC_FAIL: u32 = 1;
pub const EVSYS_ID_GEN_OSC32KCTRL_XOSC32K_FAIL: u32 = 2;
pub const EVSYS_ID_GEN_RTC_CMP_0: u32 = 3;
pub const EVSYS_ID_GEN_RTC_CMP_1: u32 = 4;
pub const EVSYS_ID_GEN_RTC_TAMPER: u32 = 5;
pub const EVSYS_ID_GEN_RTC_OVF: u32 = 6;
pub const EVSYS_ID_GEN_RTC_PER_0: u32 = 7;
pub const EVSYS_ID_GEN_RTC_PER_1: u32 = 8;
pub const EVSYS_ID_GEN_RTC_PER_2: u32 = 9;
pub const EVSYS_ID_GEN_RTC_PER_3: u32 = 10;
pub const EVSYS_ID_GEN_RTC_PER_4: u32 = 11;
pub const EVSYS_ID_GEN_RTC_PER_5: u32 = 12;
pub const EVSYS_ID_GEN_RTC_PER_6: u32 = 13;
pub const EVSYS_ID_GEN_RTC_PER_7: u32 = 14;
pub const EVSYS_ID_GEN_EIC_EXTINT_0: u32 = 15;
pub const EVSYS_ID_GEN_EIC_EXTINT_1: u32 = 16;
pub const EVSYS_ID_GEN_EIC_EXTINT_2: u32 = 17;
pub const EVSYS_ID_GEN_EIC_EXTINT_3: u32 = 18;
pub const EVSYS_ID_GEN_EIC_EXTINT_4: u32 = 19;
pub const EVSYS_ID_GEN_EIC_EXTINT_5: u32 = 20;
pub const EVSYS_ID_GEN_EIC_EXTINT_6: u32 = 21;
pub const EVSYS_ID_GEN_EIC_EXTINT_7: u32 = 22;
pub const EVSYS_ID_GEN_EIC_EXTINT_8: u32 = 23;
pub const EVSYS_ID_GEN_EIC_EXTINT_9: u32 = 24;
pub const EVSYS_ID_GEN_EIC_EXTINT_10: u32 = 25;
pub const EVSYS_ID_GEN_EIC_EXTINT_11: u32 = 26;
pub const EVSYS_ID_GEN_EIC_EXTINT_12: u32 = 27;
pub const EVSYS_ID_GEN_EIC_EXTINT_13: u32 = 28;
pub const EVSYS_ID_GEN_EIC_EXTINT_14: u32 = 29;
pub const EVSYS_ID_GEN_EIC_EXTINT_15: u32 = 30;
pub const EVSYS_ID_GEN_DMAC_CH_0: u32 = 31;
pub const EVSYS_ID_GEN_DMAC_CH_1: u32 = 32;
pub const EVSYS_ID_GEN_DMAC_CH_2: u32 = 33;
pub const EVSYS_ID_GEN_DMAC_CH_3: u32 = 34;
pub const EVSYS_ID_GEN_TCC0_OVF: u32 = 35;
pub const EVSYS_ID_GEN_TCC0_TRG: u32 = 36;
pub const EVSYS_ID_GEN_TCC0_CNT: u32 = 37;
pub const EVSYS_ID_GEN_TCC0_MCX_0: u32 = 38;
pub const EVSYS_ID_GEN_TCC0_MCX_1: u32 = 39;
pub const EVSYS_ID_GEN_TCC0_MCX_2: u32 = 40;
pub const EVSYS_ID_GEN_TCC0_MCX_3: u32 = 41;
pub const EVSYS_ID_GEN_TC0_OVF: u32 = 42;
pub const EVSYS_ID_GEN_TC0_MCX_0: u32 = 43;
pub const EVSYS_ID_GEN_TC0_MCX_1: u32 = 44;
pub const EVSYS_ID_GEN_TC1_OVF: u32 = 45;
pub const EVSYS_ID_GEN_TC1_MCX_0: u32 = 46;
pub const EVSYS_ID_GEN_TC1_MCX_1: u32 = 47;
pub const EVSYS_ID_GEN_TC2_OVF: u32 = 48;
pub const EVSYS_ID_GEN_TC2_MCX_0: u32 = 49;
pub const EVSYS_ID_GEN_TC2_MCX_1: u32 = 50;
pub const EVSYS_ID_GEN_TC3_OVF: u32 = 51;
pub const EVSYS_ID_GEN_TC3_MCX_0: u32 = 52;
pub const EVSYS_ID_GEN_TC3_MCX_1: u32 = 53;
pub const EVSYS_ID_GEN_ADC_RESRDY: u32 = 54;
pub const EVSYS_ID_GEN_ADC_WINMON: u32 = 55;
pub const EVSYS_ID_GEN_AC_COMP_0: u32 = 56;
pub const EVSYS_ID_GEN_AC_COMP_1: u32 = 57;
pub const EVSYS_ID_GEN_AC_WIN_0: u32 = 58;
pub const EVSYS_ID_GEN_SLCD_FC0OVERFLOW: u32 = 61;
pub const EVSYS_ID_GEN_SLCD_FC1OVERFLOW: u32 = 62;
pub const EVSYS_ID_GEN_SLCD_FC2OVERFLOW: u32 = 63;
pub const EVSYS_ID_GEN_SLCD_DT: u32 = 64;
pub const EVSYS_ID_GEN_TRNG_READY: u32 = 65;
pub const EVSYS_ID_GEN_CCL_LUTOUT_0: u32 = 66;
pub const EVSYS_ID_GEN_CCL_LUTOUT_1: u32 = 67;
pub const EVSYS_ID_GEN_CCL_LUTOUT_2: u32 = 68;
pub const EVSYS_ID_GEN_CCL_LUTOUT_3: u32 = 69;
pub const EVSYS_ID_GEN_PAC_ACCERR: u32 = 70;
pub const EVSYS_ID_USER_RTC_TAMPER: u32 = 0;
pub const EVSYS_ID_USER_PORT_EV_0: u32 = 1;
pub const EVSYS_ID_USER_PORT_EV_1: u32 = 2;
pub const EVSYS_ID_USER_PORT_EV_2: u32 = 3;
pub const EVSYS_ID_USER_PORT_EV_3: u32 = 4;
pub const EVSYS_ID_USER_DMAC_CH_0: u32 = 5;
pub const EVSYS_ID_USER_DMAC_CH_1: u32 = 6;
pub const EVSYS_ID_USER_DMAC_CH_2: u32 = 7;
pub const EVSYS_ID_USER_DMAC_CH_3: u32 = 8;
pub const EVSYS_ID_USER_TCC0_EV_0: u32 = 9;
pub const EVSYS_ID_USER_TCC0_EV_1: u32 = 10;
pub const EVSYS_ID_USER_TCC0_MC_0: u32 = 11;
pub const EVSYS_ID_USER_TCC0_MC_1: u32 = 12;
pub const EVSYS_ID_USER_TCC0_MC_2: u32 = 13;
pub const EVSYS_ID_USER_TCC0_MC_3: u32 = 14;
pub const EVSYS_ID_USER_TC0_EVU: u32 = 15;
pub const EVSYS_ID_USER_TC1_EVU: u32 = 16;
pub const EVSYS_ID_USER_TC2_EVU: u32 = 17;
pub const EVSYS_ID_USER_TC3_EVU: u32 = 18;
pub const EVSYS_ID_USER_ADC_START: u32 = 19;
pub const EVSYS_ID_USER_ADC_SYNC: u32 = 20;
pub const EVSYS_ID_USER_AC_SOC_0: u32 = 21;
pub const EVSYS_ID_USER_AC_SOC_1: u32 = 22;
pub const EVSYS_ID_USER_CCL_LUTIN_0: u32 = 24;
pub const EVSYS_ID_USER_CCL_LUTIN_1: u32 = 25;
pub const EVSYS_ID_USER_CCL_LUTIN_2: u32 = 26;
pub const EVSYS_ID_USER_CCL_LUTIN_3: u32 = 27;
pub const EVSYS_ID_USER_MTB_START: u32 = 29;
pub const EVSYS_ID_USER_MTB_STOP: u32 = 30;
pub const FREQM_GCLK_ID_MSR: u32 = 4;
pub const FREQM_GCLK_ID_REF: u32 = 5;
pub const GCLK_GENDIV_BITS: u32 = 16;
pub const GCLK_GEN_BITS: u32 = 3;
pub const GCLK_GEN_NUM: u32 = 5;
pub const GCLK_GEN_NUM_MSB: u32 = 4;
pub const GCLK_GEN_SOURCE_NUM_MSB: u32 = 7;
pub const GCLK_NUM: u32 = 30;
pub const GCLK_SOURCE_BITS: u32 = 3;
pub const GCLK_SOURCE_DFLL48M: u32 = 6;
pub const GCLK_SOURCE_DPLL96M: u32 = 7;
pub const GCLK_SOURCE_GCLKGEN1: u32 = 2;
pub const GCLK_SOURCE_GCLKIN: u32 = 1;
pub const GCLK_SOURCE_NUM: u32 = 8;
pub const GCLK_SOURCE_OSCULP32K: u32 = 3;
pub const GCLK_SOURCE_OSC16M: u32 = 5;
pub const GCLK_SOURCE_XOSC: u32 = 0;
pub const GCLK_SOURCE_XOSC32K: u32 = 4;
pub const MCLK_BUPDIV_IMPLEMENTED: u32 = 1;
pub const MCLK_CTRLA_MCSEL_GCLK: u32 = 1;
pub const MCLK_CTRLA_MCSEL_OSC8M: u32 = 0;
pub const MCLK_MCLK_CLK_APB_NUM: u32 = 3;
pub const MCLK_SYSTEM_CLOCK: u32 = 1000000;
pub const NVMCTRL_AUX0_ADDRESS: u32 = 8404992;
pub const NVMCTRL_AUX1_ADDRESS: u32 = 8413184;
pub const NVMCTRL_AUX2_ADDRESS: u32 = 8421376;
pub const NVMCTRL_AUX3_ADDRESS: u32 = 8429568;
pub const NVMCTRL_CLK_AHB_ID: u32 = 8;
pub const NVMCTRL_CLK_AHB_ID_PICACHU: u32 = 10;
pub const NVMCTRL_FACTORY_WORD_IMPLEMENTED_MASK: i64 = -4611685984067649537;
pub const NVMCTRL_FLASH_SIZE: u32 = 262144;
pub const NVMCTRL_GCLK_ID: u32 = 29;
pub const NVMCTRL_LOCKBIT_ADDRESS: u32 = 8396800;
pub const NVMCTRL_PAGE_HW: u32 = 32;
pub const NVMCTRL_PAGE_SIZE: u32 = 64;
pub const NVMCTRL_PAGE_W: u32 = 16;
pub const NVMCTRL_PMSB: u32 = 3;
pub const NVMCTRL_PSZ_BITS: u32 = 6;
pub const NVMCTRL_ROW_PAGES: u32 = 4;
pub const NVMCTRL_ROW_SIZE: u32 = 256;
pub const NVMCTRL_USER_PAGE_ADDRESS: u32 = 8388608;
pub const NVMCTRL_USER_PAGE_OFFSET: u32 = 8388608;
pub const NVMCTRL_USER_WORD_IMPLEMENTED_MASK: i64 = -4602678819172646913;
pub const NVMCTRL_RWWEE_PAGES: u32 = 128;
pub const NVMCTRL_RWW_EEPROM_ADDR: u32 = 4194304;
pub const OSCCTRL_DFLL48M_COARSE_MSB: u32 = 5;
pub const OSCCTRL_DFLL48M_FINE_MSB: u32 = 9;
pub const OSCCTRL_GCLK_ID_DFLL48: u32 = 0;
pub const OSCCTRL_GCLK_ID_FDPLL: u32 = 1;
pub const OSCCTRL_GCLK_ID_FDPLL32K: u32 = 2;
pub const OSCCTRL_CFD_VERSION: u32 = 256;
pub const OSCCTRL_DFLL48M_VERSION: u32 = 800;
pub const OSCCTRL_FDPLL_VERSION: u32 = 529;
pub const OSCCTRL_OSC16M_VERSION: u32 = 257;
pub const OSCCTRL_XOSC_VERSION: u32 = 513;
pub const OSC32KCTRL_OSC32K_COARSE_CALIB_MSB: u32 = 6;
pub const PAC_CLK_AHB_ID: u32 = 7;
pub const PAC_HPB_NUM: u32 = 3;
pub const PAC_INTFLAG_NUM: u32 = 4;
pub const PM_BIAS_RAM_HS: u32 = 1;
pub const PM_PD_NUM: u32 = 0;
pub const PORT_BITS: u32 = 93;
pub const PORT_DRVSTR: u32 = 1;
pub const PORT_EV_NUM: u32 = 4;
pub const PORT_ODRAIN: u32 = 0;
pub const PORT_SLEWLIM: u32 = 0;
pub const PTC_DMAC_ID_EOC: u32 = 37;
pub const PTC_DMAC_ID_SEQ: u32 = 38;
pub const PTC_DMAC_ID_WCOMP: u32 = 39;
pub const PTC_GCLK_ID: u32 = 27;
pub const PTC_LINES_MSB: u32 = 31;
pub const PTC_LINES_NUM: u32 = 32;
pub const PTC_Y_LINES_MSB: u32 = 23;
pub const PTC_Y_LINES_NUM: u32 = 24;
pub const RSTC_BACKUP_IMPLEMENTED: u32 = 1;
pub const RSTC_NUMBER_OF_EXTWAKE: u32 = 0;
pub const RTC_ALARM_NUM: u32 = 1;
pub const RTC_BKUP_NUM: u32 = 8;
pub const RTC_COMP16_NUM: u32 = 2;
pub const RTC_COMP32_NUM: u32 = 1;
pub const RTC_DMAC_ID_TIMESTAMP: u32 = 1;
pub const RTC_GPR_NUM: u32 = 2;
pub const RTC_PER_NUM: u32 = 8;
pub const RTC_TAMPER_NUM: u32 = 5;
pub const SERCOM0_DMAC_ID_RX: u32 = 2;
pub const SERCOM0_DMAC_ID_TX: u32 = 3;
pub const SERCOM0_GCLK_ID_CORE: u32 = 16;
pub const SERCOM0_GCLK_ID_SLOW: u32 = 15;
pub const SERCOM0_INT_MSB: u32 = 6;
pub const SERCOM0_PMSB: u32 = 3;
pub const SERCOM0_SPI: u32 = 1;
pub const SERCOM0_TWIM: u32 = 0;
pub const SERCOM0_TWIS: u32 = 0;
pub const SERCOM0_TWI_HSMODE: u32 = 0;
pub const SERCOM0_USART: u32 = 1;
pub const SERCOM0_USART_ISO7816: u32 = 1;
pub const SERCOM0_USART_LIN_MASTER: u32 = 0;
pub const SERCOM0_USART_RS485: u32 = 1;
pub const SERCOM1_DMAC_ID_RX: u32 = 4;
pub const SERCOM1_DMAC_ID_TX: u32 = 5;
pub const SERCOM1_GCLK_ID_CORE: u32 = 17;
pub const SERCOM1_GCLK_ID_SLOW: u32 = 15;
pub const SERCOM1_INT_MSB: u32 = 6;
pub const SERCOM1_PMSB: u32 = 3;
pub const SERCOM1_SPI: u32 = 1;
pub const SERCOM1_TWIM: u32 = 1;
pub const SERCOM1_TWIS: u32 = 1;
pub const SERCOM1_TWI_HSMODE: u32 = 1;
pub const SERCOM1_USART: u32 = 1;
pub const SERCOM1_USART_ISO7816: u32 = 1;
pub const SERCOM1_USART_LIN_MASTER: u32 = 0;
pub const SERCOM1_USART_RS485: u32 = 1;
pub const SERCOM2_DMAC_ID_RX: u32 = 6;
pub const SERCOM2_DMAC_ID_TX: u32 = 7;
pub const SERCOM2_GCLK_ID_CORE: u32 = 18;
pub const SERCOM2_GCLK_ID_SLOW: u32 = 15;
pub const SERCOM2_INT_MSB: u32 = 6;
pub const SERCOM2_PMSB: u32 = 3;
pub const SERCOM2_SPI: u32 = 1;
pub const SERCOM2_TWIM: u32 = 1;
pub const SERCOM2_TWIS: u32 = 1;
pub const SERCOM2_TWI_HSMODE: u32 = 0;
pub const SERCOM2_USART: u32 = 1;
pub const SERCOM2_USART_ISO7816: u32 = 1;
pub const SERCOM2_USART_LIN_MASTER: u32 = 0;
pub const SERCOM2_USART_RS485: u32 = 1;
pub const SERCOM3_DMAC_ID_RX: u32 = 8;
pub const SERCOM3_DMAC_ID_TX: u32 = 9;
pub const SERCOM3_GCLK_ID_CORE: u32 = 19;
pub const SERCOM3_GCLK_ID_SLOW: u32 = 15;
pub const SERCOM3_INT_MSB: u32 = 6;
pub const SERCOM3_PMSB: u32 = 3;
pub const SERCOM3_SPI: u32 = 1;
pub const SERCOM3_TWIM: u32 = 1;
pub const SERCOM3_TWIS: u32 = 1;
pub const SERCOM3_TWI_HSMODE: u32 = 0;
pub const SERCOM3_USART: u32 = 1;
pub const SERCOM3_USART_ISO7816: u32 = 1;
pub const SERCOM3_USART_LIN_MASTER: u32 = 0;
pub const SERCOM3_USART_RS485: u32 = 1;
pub const SLCD_DMAC_ID_ABMDRDY: u32 = 34;
pub const SLCD_DMAC_ID_ACMDRDY: u32 = 33;
pub const SLCD_DMAC_ID_DMU: u32 = 32;
pub const SLCD_MAX_COM: u32 = 8;
pub const SLCD_MAX_SEG: u32 = 44;
pub const SLCD_NB_LP: u32 = 52;
pub const SUPC_BOD12_CALIB_MSB: u32 = 5;
pub const SUPC_BOD33_CALIB_MSB: u32 = 5;
pub const SUPC_OUT_NUM_MSB: u32 = 1;
pub const TC0_CC_NUM: u32 = 2;
pub const TC0_DMAC_ID_MC_0: u32 = 20;
pub const TC0_DMAC_ID_MC_1: u32 = 21;
pub const TC0_DMAC_ID_MC_LSB: u32 = 20;
pub const TC0_DMAC_ID_MC_MSB: u32 = 21;
pub const TC0_DMAC_ID_MC_SIZE: u32 = 2;
pub const TC0_DMAC_ID_OVF: u32 = 19;
pub const TC0_EXT: u32 = 0;
pub const TC0_GCLK_ID: u32 = 23;
pub const TC0_MASTER: u32 = 1;
pub const TC0_OW_NUM: u32 = 2;
pub const TC1_CC_NUM: u32 = 2;
pub const TC1_DMAC_ID_MC_0: u32 = 23;
pub const TC1_DMAC_ID_MC_1: u32 = 24;
pub const TC1_DMAC_ID_MC_LSB: u32 = 23;
pub const TC1_DMAC_ID_MC_MSB: u32 = 24;
pub const TC1_DMAC_ID_MC_SIZE: u32 = 2;
pub const TC1_DMAC_ID_OVF: u32 = 22;
pub const TC1_EXT: u32 = 0;
pub const TC1_GCLK_ID: u32 = 23;
pub const TC1_MASTER: u32 = 0;
pub const TC1_OW_NUM: u32 = 2;
pub const TC2_CC_NUM: u32 = 2;
pub const TC2_DMAC_ID_MC_0: u32 = 26;
pub const TC2_DMAC_ID_MC_1: u32 = 27;
pub const TC2_DMAC_ID_MC_LSB: u32 = 26;
pub const TC2_DMAC_ID_MC_MSB: u32 = 27;
pub const TC2_DMAC_ID_MC_SIZE: u32 = 2;
pub const TC2_DMAC_ID_OVF: u32 = 25;
pub const TC2_EXT: u32 = 0;
pub const TC2_GCLK_ID: u32 = 24;
pub const TC2_MASTER: u32 = 1;
pub const TC2_OW_NUM: u32 = 2;
pub const TC3_CC_NUM: u32 = 2;
pub const TC3_DMAC_ID_MC_0: u32 = 29;
pub const TC3_DMAC_ID_MC_1: u32 = 30;
pub const TC3_DMAC_ID_MC_LSB: u32 = 29;
pub const TC3_DMAC_ID_MC_MSB: u32 = 30;
pub const TC3_DMAC_ID_MC_SIZE: u32 = 2;
pub const TC3_DMAC_ID_OVF: u32 = 28;
pub const TC3_EXT: u32 = 0;
pub const TC3_GCLK_ID: u32 = 24;
pub const TC3_MASTER: u32 = 0;
pub const TC3_OW_NUM: u32 = 2;
pub const TCC0_CC_NUM: u32 = 4;
pub const TCC0_DITHERING: u32 = 1;
pub const TCC0_DMAC_ID_MC_0: u32 = 15;
pub const TCC0_DMAC_ID_MC_1: u32 = 16;
pub const TCC0_DMAC_ID_MC_2: u32 = 17;
pub const TCC0_DMAC_ID_MC_3: u32 = 18;
pub const TCC0_DMAC_ID_MC_LSB: u32 = 15;
pub const TCC0_DMAC_ID_MC_MSB: u32 = 18;
pub const TCC0_DMAC_ID_MC_SIZE: u32 = 4;
pub const TCC0_DMAC_ID_OVF: u32 = 14;
pub const TCC0_DTI: u32 = 1;
pub const TCC0_EXT: u32 = 31;
pub const TCC0_GCLK_ID: u32 = 22;
pub const TCC0_OTMX: u32 = 1;
pub const TCC0_OW_NUM: u32 = 8;
pub const TCC0_PG: u32 = 1;
pub const TCC0_SIZE: u32 = 24;
pub const TCC0_SWAP: u32 = 1;
pub const TCC0_TYPE: u32 = 0;
pub const USB_EPT_NBR: u32 = 8;
pub const USB_EPT_NUM: u32 = 8;
pub const USB_GCLK_ID: u32 = 6;
pub const USB_PIPE_NUM: u32 = 0;
pub const ID_PAC: u32 = 0;
pub const ID_PM: u32 = 1;
pub const ID_MCLK: u32 = 2;
pub const ID_RSTC: u32 = 3;
pub const ID_OSCCTRL: u32 = 4;
pub const ID_OSC32KCTRL: u32 = 5;
pub const ID_SUPC: u32 = 6;
pub const ID_GCLK: u32 = 7;
pub const ID_WDT: u32 = 8;
pub const ID_RTC: u32 = 9;
pub const ID_EIC: u32 = 10;
pub const ID_FREQM: u32 = 11;
pub const ID_USB: u32 = 32;
pub const ID_DSU: u32 = 33;
pub const ID_NVMCTRL: u32 = 34;
pub const ID_PORT: u32 = 35;
pub const ID_DMAC: u32 = 36;
pub const ID_MTB: u32 = 37;
pub const ID_EVSYS: u32 = 64;
pub const ID_SERCOM0: u32 = 65;
pub const ID_SERCOM1: u32 = 66;
pub const ID_SERCOM2: u32 = 67;
pub const ID_SERCOM3: u32 = 68;
pub const ID_TCC0: u32 = 71;
pub const ID_TC0: u32 = 72;
pub const ID_TC1: u32 = 73;
pub const ID_TC2: u32 = 74;
pub const ID_TC3: u32 = 75;
pub const ID_ADC: u32 = 76;
pub const ID_AC: u32 = 77;
pub const ID_PTC: u32 = 78;
pub const ID_SLCD: u32 = 79;
pub const ID_AES: u32 = 80;
pub const ID_TRNG: u32 = 81;
pub const ID_CCL: u32 = 82;
pub const ID_PERIPH_COUNT: u32 = 83;
pub const AC_INST_NUM: u32 = 1;
pub const ADC_INST_NUM: u32 = 1;
pub const AES_INST_NUM: u32 = 1;
pub const CCL_INST_NUM: u32 = 1;
pub const DMAC_INST_NUM: u32 = 1;
pub const DSU_INST_NUM: u32 = 1;
pub const EIC_INST_NUM: u32 = 1;
pub const EVSYS_INST_NUM: u32 = 1;
pub const FREQM_INST_NUM: u32 = 1;
pub const GCLK_INST_NUM: u32 = 1;
pub const MCLK_INST_NUM: u32 = 1;
pub const MTB_INST_NUM: u32 = 1;
pub const NVMCTRL_CAL: u32 = 8388608;
pub const NVMCTRL_LOCKBIT: u32 = 8396800;
pub const NVMCTRL_OTP1: u32 = 8413184;
pub const NVMCTRL_OTP2: u32 = 8413192;
pub const NVMCTRL_OTP3: u32 = 8413200;
pub const NVMCTRL_OTP4: u32 = 8413208;
pub const NVMCTRL_OTP5: u32 = 8413216;
pub const NVMCTRL_TEMP_LOG: u32 = 8413232;
pub const NVMCTRL_USER: u32 = 8404992;
pub const NVMCTRL_INST_NUM: u32 = 1;
pub const OSCCTRL_INST_NUM: u32 = 1;
pub const OSC32KCTRL_INST_NUM: u32 = 1;
pub const PAC_INST_NUM: u32 = 1;
pub const PM_INST_NUM: u32 = 1;
pub const PORT_INST_NUM: u32 = 1;
pub const PORT_IOBUS_INST_NUM: u32 = 1;
pub const PTC_INST_NUM: u32 = 1;
pub const RSTC_INST_NUM: u32 = 1;
pub const RTC_INST_NUM: u32 = 1;
pub const SERCOM_INST_NUM: u32 = 4;
pub const SLCD_INST_NUM: u32 = 1;
pub const SUPC_INST_NUM: u32 = 1;
pub const TC_INST_NUM: u32 = 4;
pub const TCC_INST_NUM: u32 = 1;
pub const TRNG_INST_NUM: u32 = 1;
pub const USB_INST_NUM: u32 = 1;
pub const WDT_INST_NUM: u32 = 1;
pub const PIN_PA00: u32 = 0;
pub const PIN_PA01: u32 = 1;
pub const PIN_PA02: u32 = 2;
pub const PIN_PA03: u32 = 3;
pub const PIN_PA04: u32 = 4;
pub const PIN_PA05: u32 = 5;
pub const PIN_PA06: u32 = 6;
pub const PIN_PA07: u32 = 7;
pub const PIN_PA08: u32 = 8;
pub const PIN_PA09: u32 = 9;
pub const PIN_PA10: u32 = 10;
pub const PIN_PA11: u32 = 11;
pub const PIN_PA12: u32 = 12;
pub const PIN_PA13: u32 = 13;
pub const PIN_PA14: u32 = 14;
pub const PIN_PA15: u32 = 15;
pub const PIN_PA16: u32 = 16;
pub const PIN_PA17: u32 = 17;
pub const PIN_PA18: u32 = 18;
pub const PIN_PA19: u32 = 19;
pub const PIN_PA20: u32 = 20;
pub const PIN_PA21: u32 = 21;
pub const PIN_PA22: u32 = 22;
pub const PIN_PA23: u32 = 23;
pub const PIN_PA24: u32 = 24;
pub const PIN_PA25: u32 = 25;
pub const PIN_PA27: u32 = 27;
pub const PIN_PA30: u32 = 30;
pub const PIN_PA31: u32 = 31;
pub const PIN_PB00: u32 = 32;
pub const PIN_PB01: u32 = 33;
pub const PIN_PB02: u32 = 34;
pub const PIN_PB03: u32 = 35;
pub const PIN_PB04: u32 = 36;
pub const PIN_PB05: u32 = 37;
pub const PIN_PB06: u32 = 38;
pub const PIN_PB07: u32 = 39;
pub const PIN_PB08: u32 = 40;
pub const PIN_PB09: u32 = 41;
pub const PIN_PB11: u32 = 43;
pub const PIN_PB12: u32 = 44;
pub const PIN_PB13: u32 = 45;
pub const PIN_PB14: u32 = 46;
pub const PIN_PB15: u32 = 47;
pub const PIN_PB16: u32 = 48;
pub const PIN_PB17: u32 = 49;
pub const PIN_PB22: u32 = 54;
pub const PIN_PB23: u32 = 55;
pub const PIN_PB30: u32 = 62;
pub const PIN_PB31: u32 = 63;
pub const FLASH_PAGE_SIZE: u32 = 64;
pub const FLASH_NB_OF_PAGES: u32 = 4096;
pub const FLASH_USER_PAGE_SIZE: u32 = 64;
pub const PORT_GROUPS: u32 = 2;
pub const ERR_NONE: u32 = 0;
pub const ERR_INVALID_DATA: i32 = -1;
pub const ERR_NO_CHANGE: i32 = -2;
pub const ERR_ABORTED: i32 = -3;
pub const ERR_BUSY: i32 = -4;
pub const ERR_SUSPEND: i32 = -5;
pub const ERR_IO: i32 = -6;
pub const ERR_REQ_FLUSHED: i32 = -7;
pub const ERR_TIMEOUT: i32 = -8;
pub const ERR_BAD_DATA: i32 = -9;
pub const ERR_NOT_FOUND: i32 = -10;
pub const ERR_UNSUPPORTED_DEV: i32 = -11;
pub const ERR_NO_MEMORY: i32 = -12;
pub const ERR_INVALID_ARG: i32 = -13;
pub const ERR_BAD_ADDRESS: i32 = -14;
pub const ERR_BAD_FORMAT: i32 = -15;
pub const ERR_BAD_FRQ: i32 = -16;
pub const ERR_DENIED: i32 = -17;
pub const ERR_ALREADY_INITIALIZED: i32 = -18;
pub const ERR_OVERFLOW: i32 = -19;
pub const ERR_NOT_INITIALIZED: i32 = -20;
pub const ERR_SAMPLERATE_UNAVAILABLE: i32 = -21;
pub const ERR_RESOLUTION_UNAVAILABLE: i32 = -22;
pub const ERR_BAUDRATE_UNAVAILABLE: i32 = -23;
pub const ERR_PACKET_COLLISION: i32 = -24;
pub const ERR_PROTOCOL: i32 = -25;
pub const ERR_PIN_MUX_INVALID: i32 = -26;
pub const ERR_UNSUPPORTED_OP: i32 = -27;
pub const ERR_NO_RESOURCE: i32 = -28;
pub const ERR_NOT_READY: i32 = -29;
pub const ERR_FAILURE: i32 = -30;
pub const ERR_WRONG_LENGTH: i32 = -31;
pub const GPIO_PIN_FUNCTION_OFF: u32 = 4294967295;
pub const CONF_PORT_EVCTRL_PORT_0: u32 = 0;
pub const CONF_PORTA_EVCTRL_PORTEI_0: u32 = 0;
pub const CONF_PORTA_EVCTRL_PID_0: u32 = 0;
pub const CONF_PORTA_EVCTRL_EVACT_0: u32 = 0;
pub const CONF_PORTB_EVCTRL_PORTEI_0: u32 = 0;
pub const CONF_PORTB_EVCTRL_PID_0: u32 = 0;
pub const CONF_PORTB_EVCTRL_EVACT_0: u32 = 0;
pub const CONF_PORT_EVCTRL_PORT_1: u32 = 0;
pub const CONF_PORTA_EVCTRL_PORTEI_1: u32 = 0;
pub const CONF_PORTA_EVCTRL_PID_1: u32 = 0;
pub const CONF_PORTA_EVCTRL_EVACT_1: u32 = 0;
pub const CONF_PORTB_EVCTRL_PORTEI_1: u32 = 0;
pub const CONF_PORTB_EVCTRL_PID_1: u32 = 0;
pub const CONF_PORTB_EVCTRL_EVACT_1: u32 = 0;
pub const CONF_PORT_EVCTRL_PORT_2: u32 = 0;
pub const CONF_PORTA_EVCTRL_PORTEI_2: u32 = 0;
pub const CONF_PORTA_EVCTRL_PID_2: u32 = 0;
pub const CONF_PORTA_EVCTRL_EVACT_2: u32 = 0;
pub const CONF_PORTB_EVCTRL_PORTEI_2: u32 = 0;
pub const CONF_PORTB_EVCTRL_PID_2: u32 = 0;
pub const CONF_PORTB_EVCTRL_EVACT_2: u32 = 0;
pub const CONF_PORT_EVCTRL_PORT_3: u32 = 0;
pub const CONF_PORTA_EVCTRL_PORTEI_3: u32 = 0;
pub const CONF_PORTA_EVCTRL_PID_3: u32 = 0;
pub const CONF_PORTA_EVCTRL_EVACT_3: u32 = 0;
pub const CONF_PORTB_EVCTRL_PORTEI_3: u32 = 0;
pub const CONF_PORTB_EVCTRL_PID_3: u32 = 0;
pub const CONF_PORTB_EVCTRL_EVACT_3: u32 = 0;
pub const I2C_M_RD: u32 = 1;
pub const I2C_M_BUSY: u32 = 256;
pub const I2C_M_TEN: u32 = 1024;
pub const I2C_M_SEVEN: u32 = 2048;
pub const I2C_M_FAIL: u32 = 4096;
pub const I2C_M_STOP: u32 = 32768;
pub const I2C_OK: u32 = 0;
pub const I2C_ACK: i32 = -1;
pub const I2C_NACK: i32 = -2;
pub const I2C_ERR_ARBLOST: i32 = -3;
pub const I2C_ERR_BAD_ADDRESS: i32 = -4;
pub const I2C_ERR_BUS: i32 = -5;
pub const I2C_ERR_BUSY: i32 = -6;
pub const I2c_ERR_PACKAGE_COLLISION: i32 = -7;
pub const I2C_STANDARD_MODE: u32 = 0;
pub const I2C_FASTMODE: u32 = 1;
pub const I2C_HIGHSPEED_MODE: u32 = 2;
pub const I2C_M_MAX_RETRY: u32 = 1;
pub const SPI_DUMMY_CHAR: u32 = 511;
pub const WATCH_RTC_REFERENCE_YEAR: u32 = 2020;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::core::ffi::c_uchar;
pub type __u_short = ::core::ffi::c_ushort;
pub type __u_int = ::core::ffi::c_uint;
pub type __u_long = ::core::ffi::c_ulong;
pub type __int8_t = ::core::ffi::c_schar;
pub type __uint8_t = ::core::ffi::c_uchar;
pub type __int16_t = ::core::ffi::c_short;
pub type __uint16_t = ::core::ffi::c_ushort;
pub type __int32_t = ::core::ffi::c_int;
pub type __uint32_t = ::core::ffi::c_uint;
pub type __int64_t = ::core::ffi::c_long;
pub type __uint64_t = ::core::ffi::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::core::ffi::c_long;
pub type __u_quad_t = ::core::ffi::c_ulong;
pub type __intmax_t = ::core::ffi::c_long;
pub type __uintmax_t = ::core::ffi::c_ulong;
pub type __dev_t = ::core::ffi::c_ulong;
pub type __uid_t = ::core::ffi::c_uint;
pub type __gid_t = ::core::ffi::c_uint;
pub type __ino_t = ::core::ffi::c_ulong;
pub type __ino64_t = ::core::ffi::c_ulong;
pub type __mode_t = ::core::ffi::c_uint;
pub type __nlink_t = ::core::ffi::c_ulong;
pub type __off_t = ::core::ffi::c_long;
pub type __off64_t = ::core::ffi::c_long;
pub type __pid_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::core::ffi::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::core::mem::MaybeUninit<__fsid_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::core::ffi::c_long;
pub type __rlim_t = ::core::ffi::c_ulong;
pub type __rlim64_t = ::core::ffi::c_ulong;
pub type __id_t = ::core::ffi::c_uint;
pub type __time_t = ::core::ffi::c_long;
pub type __useconds_t = ::core::ffi::c_uint;
pub type __suseconds_t = ::core::ffi::c_long;
pub type __daddr_t = ::core::ffi::c_int;
pub type __key_t = ::core::ffi::c_int;
pub type __clockid_t = ::core::ffi::c_int;
pub type __timer_t = *mut ::core::ffi::c_void;
pub type __blksize_t = ::core::ffi::c_long;
pub type __blkcnt_t = ::core::ffi::c_long;
pub type __blkcnt64_t = ::core::ffi::c_long;
pub type __fsblkcnt_t = ::core::ffi::c_ulong;
pub type __fsblkcnt64_t = ::core::ffi::c_ulong;
pub type __fsfilcnt_t = ::core::ffi::c_ulong;
pub type __fsfilcnt64_t = ::core::ffi::c_ulong;
pub type __fsword_t = ::core::ffi::c_long;
pub type __ssize_t = ::core::ffi::c_long;
pub type __syscall_slong_t = ::core::ffi::c_long;
pub type __syscall_ulong_t = ::core::ffi::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::core::ffi::c_char;
pub type __intptr_t = ::core::ffi::c_long;
pub type __socklen_t = ::core::ffi::c_uint;
pub type __sig_atomic_t = ::core::ffi::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::core::ffi::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::core::ffi::c_uint,
    pub __wchb: [::core::ffi::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<__mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::core::mem::MaybeUninit<_G_fpos_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::core::mem::MaybeUninit<_G_fpos64_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::core::ffi::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::core::ffi::c_int,
    pub _IO_read_ptr: *mut ::core::ffi::c_char,
    pub _IO_read_end: *mut ::core::ffi::c_char,
    pub _IO_read_base: *mut ::core::ffi::c_char,
    pub _IO_write_base: *mut ::core::ffi::c_char,
    pub _IO_write_ptr: *mut ::core::ffi::c_char,
    pub _IO_write_end: *mut ::core::ffi::c_char,
    pub _IO_buf_base: *mut ::core::ffi::c_char,
    pub _IO_buf_end: *mut ::core::ffi::c_char,
    pub _IO_save_base: *mut ::core::ffi::c_char,
    pub _IO_backup_base: *mut ::core::ffi::c_char,
    pub _IO_save_end: *mut ::core::ffi::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::core::ffi::c_int,
    pub _flags2: ::core::ffi::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::core::ffi::c_ushort,
    pub _vtable_offset: ::core::ffi::c_schar,
    pub _shortbuf: [::core::ffi::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::core::ffi::c_void,
    pub __pad5: usize,
    pub _mode: ::core::ffi::c_int,
    pub _unused2: [::core::ffi::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_FILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::core::ffi::c_char,
        __new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::core::ffi::c_int,
        __old: *const ::core::ffi::c_char,
        __newfd: ::core::ffi::c_int,
        __new: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::core::ffi::c_char,
        __pfx: *const ::core::ffi::c_char,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::core::ffi::c_char,
        __modes: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::core::ffi::c_char,
        __modes: *const ::core::ffi::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::core::ffi::c_int, __modes: *const ::core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::core::ffi::c_void,
        __len: usize,
        __modes: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::core::ffi::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::core::ffi::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::core::ffi::c_char,
        __modes: ::core::ffi::c_int,
        __n: usize,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::core::ffi::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::core::ffi::c_char,
        __maxlen: ::core::ffi::c_ulong,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::core::ffi::c_char,
        __maxlen: ::core::ffi::c_ulong,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::core::ffi::c_int,
        __fmt: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::core::ffi::c_int,
        __fmt: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::core::ffi::c_char, ...) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        ...
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::core::ffi::c_char,
        __format: *const ::core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn putw(__w: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::core::ffi::c_char,
        __n: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::core::ffi::c_char,
        __n: *mut usize,
        __delimiter: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::core::ffi::c_char,
        __n: *mut usize,
        __delimiter: ::core::ffi::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::core::ffi::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::core::ffi::c_char, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::core::ffi::c_int, __stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
        __n: ::core::ffi::c_ulong,
        __stream: *mut FILE,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::core::ffi::c_void,
        __size: ::core::ffi::c_ulong,
        __n: ::core::ffi::c_ulong,
        __s: *mut FILE,
    ) -> ::core::ffi::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::core::ffi::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::core::ffi::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::core::ffi::c_long,
        __whence: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::core::ffi::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::core::ffi::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::core::ffi::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::core::ffi::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::core::ffi::c_char,
        __modes: *const ::core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::core::ffi::c_int) -> ::core::ffi::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::core::ffi::c_schar;
pub type int_fast16_t = ::core::ffi::c_long;
pub type int_fast32_t = ::core::ffi::c_long;
pub type int_fast64_t = ::core::ffi::c_long;
pub type uint_fast8_t = ::core::ffi::c_uchar;
pub type uint_fast16_t = ::core::ffi::c_ulong;
pub type uint_fast32_t = ::core::ffi::c_ulong;
pub type uint_fast64_t = ::core::ffi::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::core::ffi::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::core::ffi::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type RoReg = u32;
pub type RoReg16 = u16;
pub type RoReg8 = u8;
pub type WoReg = u32;
pub type WoReg16 = u16;
pub type WoReg8 = u8;
pub type RwReg = u32;
pub type RwReg16 = u16;
pub type RwReg8 = u8;
#[doc = "<  2 Non Maskable Interrupt"]
pub const IRQn_NonMaskableInt_IRQn: IRQn = -14;
#[doc = "<  3 Hard Fault Interrupt"]
pub const IRQn_HardFault_IRQn: IRQn = -13;
#[doc = "< 11 SV Call Interrupt"]
pub const IRQn_SVCall_IRQn: IRQn = -5;
#[doc = "< 14 Pend SV Interrupt"]
pub const IRQn_PendSV_IRQn: IRQn = -2;
#[doc = "< 15 System Tick Interrupt"]
pub const IRQn_SysTick_IRQn: IRQn = -1;
#[doc = "<  0 SAML22J18A System Interrupts"]
pub const IRQn_SYSTEM_IRQn: IRQn = 0;
#[doc = "<  1 SAML22J18A Watchdog Timer (WDT)"]
pub const IRQn_WDT_IRQn: IRQn = 1;
#[doc = "<  2 SAML22J18A Real-Time Counter (RTC)"]
pub const IRQn_RTC_IRQn: IRQn = 2;
#[doc = "<  3 SAML22J18A External Interrupt Controller (EIC)"]
pub const IRQn_EIC_IRQn: IRQn = 3;
#[doc = "<  4 SAML22J18A Frequency Meter (FREQM)"]
pub const IRQn_FREQM_IRQn: IRQn = 4;
#[doc = "<  5 SAML22J18A Universal Serial Bus (USB)"]
pub const IRQn_USB_IRQn: IRQn = 5;
#[doc = "<  6 SAML22J18A Non-Volatile Memory Controller (NVMCTRL)"]
pub const IRQn_NVMCTRL_IRQn: IRQn = 6;
#[doc = "<  7 SAML22J18A Direct Memory Access Controller (DMAC)"]
pub const IRQn_DMAC_IRQn: IRQn = 7;
#[doc = "<  8 SAML22J18A Event System Interface (EVSYS)"]
pub const IRQn_EVSYS_IRQn: IRQn = 8;
#[doc = "<  9 SAML22J18A Serial Communication Interface 0 (SERCOM0)"]
pub const IRQn_SERCOM0_IRQn: IRQn = 9;
#[doc = "< 10 SAML22J18A Serial Communication Interface 1 (SERCOM1)"]
pub const IRQn_SERCOM1_IRQn: IRQn = 10;
#[doc = "< 11 SAML22J18A Serial Communication Interface 2 (SERCOM2)"]
pub const IRQn_SERCOM2_IRQn: IRQn = 11;
#[doc = "< 12 SAML22J18A Serial Communication Interface 3 (SERCOM3)"]
pub const IRQn_SERCOM3_IRQn: IRQn = 12;
#[doc = "< 15 SAML22J18A Timer Counter Control (TCC0)"]
pub const IRQn_TCC0_IRQn: IRQn = 15;
#[doc = "< 16 SAML22J18A Basic Timer Counter 0 (TC0)"]
pub const IRQn_TC0_IRQn: IRQn = 16;
#[doc = "< 17 SAML22J18A Basic Timer Counter 1 (TC1)"]
pub const IRQn_TC1_IRQn: IRQn = 17;
#[doc = "< 18 SAML22J18A Basic Timer Counter 2 (TC2)"]
pub const IRQn_TC2_IRQn: IRQn = 18;
#[doc = "< 19 SAML22J18A Basic Timer Counter 3 (TC3)"]
pub const IRQn_TC3_IRQn: IRQn = 19;
#[doc = "< 20 SAML22J18A Analog Digital Converter (ADC)"]
pub const IRQn_ADC_IRQn: IRQn = 20;
#[doc = "< 21 SAML22J18A Analog Comparators (AC)"]
pub const IRQn_AC_IRQn: IRQn = 21;
#[doc = "< 22 SAML22J18A Peripheral Touch Controller (PTC)"]
pub const IRQn_PTC_IRQn: IRQn = 22;
#[doc = "< 23 SAML22J18A Segment Liquid Crystal Display Controller (SLCD)"]
pub const IRQn_SLCD_IRQn: IRQn = 23;
#[doc = "< 24 SAML22J18A Advanced Encryption Standard (AES)"]
pub const IRQn_AES_IRQn: IRQn = 24;
#[doc = "< 25 SAML22J18A True Random Generator (TRNG)"]
pub const IRQn_TRNG_IRQn: IRQn = 25;
#[doc = "< Number of peripheral IDs"]
pub const IRQn_PERIPH_COUNT_IRQn: IRQn = 26;
#[doc = " Interrupt Number Definition"]
pub type IRQn = ::core::ffi::c_int;
#[doc = " Interrupt Number Definition"]
pub use self::IRQn as IRQn_Type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DeviceVectors {
    pub pvStack: *mut ::core::ffi::c_void,
    pub pfnReset_Handler: *mut ::core::ffi::c_void,
    pub pfnNonMaskableInt_Handler: *mut ::core::ffi::c_void,
    pub pfnHardFault_Handler: *mut ::core::ffi::c_void,
    pub pvReservedM12: *mut ::core::ffi::c_void,
    pub pvReservedM11: *mut ::core::ffi::c_void,
    pub pvReservedM10: *mut ::core::ffi::c_void,
    pub pvReservedM9: *mut ::core::ffi::c_void,
    pub pvReservedM8: *mut ::core::ffi::c_void,
    pub pvReservedM7: *mut ::core::ffi::c_void,
    pub pvReservedM6: *mut ::core::ffi::c_void,
    pub pfnSVCall_Handler: *mut ::core::ffi::c_void,
    pub pvReservedM4: *mut ::core::ffi::c_void,
    pub pvReservedM3: *mut ::core::ffi::c_void,
    pub pfnPendSV_Handler: *mut ::core::ffi::c_void,
    pub pfnSysTick_Handler: *mut ::core::ffi::c_void,
    pub pfnSYSTEM_Handler: *mut ::core::ffi::c_void,
    pub pfnWDT_Handler: *mut ::core::ffi::c_void,
    pub pfnRTC_Handler: *mut ::core::ffi::c_void,
    pub pfnEIC_Handler: *mut ::core::ffi::c_void,
    pub pfnFREQM_Handler: *mut ::core::ffi::c_void,
    pub pfnUSB_Handler: *mut ::core::ffi::c_void,
    pub pfnNVMCTRL_Handler: *mut ::core::ffi::c_void,
    pub pfnDMAC_Handler: *mut ::core::ffi::c_void,
    pub pfnEVSYS_Handler: *mut ::core::ffi::c_void,
    pub pfnSERCOM0_Handler: *mut ::core::ffi::c_void,
    pub pfnSERCOM1_Handler: *mut ::core::ffi::c_void,
    pub pfnSERCOM2_Handler: *mut ::core::ffi::c_void,
    pub pfnSERCOM3_Handler: *mut ::core::ffi::c_void,
    pub pvReserved13: *mut ::core::ffi::c_void,
    pub pvReserved14: *mut ::core::ffi::c_void,
    pub pfnTCC0_Handler: *mut ::core::ffi::c_void,
    pub pfnTC0_Handler: *mut ::core::ffi::c_void,
    pub pfnTC1_Handler: *mut ::core::ffi::c_void,
    pub pfnTC2_Handler: *mut ::core::ffi::c_void,
    pub pfnTC3_Handler: *mut ::core::ffi::c_void,
    pub pfnADC_Handler: *mut ::core::ffi::c_void,
    pub pfnAC_Handler: *mut ::core::ffi::c_void,
    pub pfnPTC_Handler: *mut ::core::ffi::c_void,
    pub pfnSLCD_Handler: *mut ::core::ffi::c_void,
    pub pfnAES_Handler: *mut ::core::ffi::c_void,
    pub pfnTRNG_Handler: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout__DeviceVectors() {
    const UNINIT: ::core::mem::MaybeUninit<_DeviceVectors> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DeviceVectors>(),
        336usize,
        concat!("Size of: ", stringify!(_DeviceVectors))
    );
    assert_eq!(
        ::core::mem::align_of::<_DeviceVectors>(),
        8usize,
        concat!("Alignment of ", stringify!(_DeviceVectors))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvStack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvStack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnReset_Handler) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnReset_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnNonMaskableInt_Handler) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnNonMaskableInt_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnHardFault_Handler) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnHardFault_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReservedM12) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM12)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReservedM11) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM11)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReservedM10) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM10)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReservedM9) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM9)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReservedM8) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReservedM7) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReservedM6) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnSVCall_Handler) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSVCall_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReservedM4) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReservedM3) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReservedM3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnPendSV_Handler) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnPendSV_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnSysTick_Handler) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSysTick_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnSYSTEM_Handler) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSYSTEM_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnWDT_Handler) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnWDT_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnRTC_Handler) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnRTC_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnEIC_Handler) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnEIC_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnFREQM_Handler) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnFREQM_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnUSB_Handler) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnUSB_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnNVMCTRL_Handler) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnNVMCTRL_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnDMAC_Handler) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnDMAC_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnEVSYS_Handler) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnEVSYS_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnSERCOM0_Handler) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSERCOM0_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnSERCOM1_Handler) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSERCOM1_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnSERCOM2_Handler) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSERCOM2_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnSERCOM3_Handler) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSERCOM3_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReserved13) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReserved13)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pvReserved14) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pvReserved14)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnTCC0_Handler) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnTCC0_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnTC0_Handler) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnTC0_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnTC1_Handler) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnTC1_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnTC2_Handler) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnTC2_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnTC3_Handler) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnTC3_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnADC_Handler) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnADC_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnAC_Handler) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnAC_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnPTC_Handler) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnPTC_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnSLCD_Handler) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnSLCD_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnAES_Handler) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnAES_Handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pfnTRNG_Handler) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_DeviceVectors),
            "::",
            stringify!(pfnTRNG_Handler)
        )
    );
}
pub type DeviceVectors = _DeviceVectors;
extern "C" {
    pub fn Reset_Handler();
}
extern "C" {
    pub fn NonMaskableInt_Handler();
}
extern "C" {
    pub fn HardFault_Handler();
}
extern "C" {
    pub fn SVCall_Handler();
}
extern "C" {
    pub fn PendSV_Handler();
}
extern "C" {
    pub fn SysTick_Handler();
}
extern "C" {
    pub fn SYSTEM_Handler();
}
extern "C" {
    pub fn WDT_Handler();
}
extern "C" {
    pub fn RTC_Handler();
}
extern "C" {
    pub fn EIC_Handler();
}
extern "C" {
    pub fn FREQM_Handler();
}
extern "C" {
    pub fn USB_Handler();
}
extern "C" {
    pub fn NVMCTRL_Handler();
}
extern "C" {
    pub fn DMAC_Handler();
}
extern "C" {
    pub fn EVSYS_Handler();
}
extern "C" {
    pub fn SERCOM0_Handler();
}
extern "C" {
    pub fn SERCOM1_Handler();
}
extern "C" {
    pub fn SERCOM2_Handler();
}
extern "C" {
    pub fn SERCOM3_Handler();
}
extern "C" {
    pub fn TCC0_Handler();
}
extern "C" {
    pub fn TC0_Handler();
}
extern "C" {
    pub fn TC1_Handler();
}
extern "C" {
    pub fn TC2_Handler();
}
extern "C" {
    pub fn TC3_Handler();
}
extern "C" {
    pub fn ADC_Handler();
}
extern "C" {
    pub fn AC_Handler();
}
extern "C" {
    pub fn PTC_Handler();
}
extern "C" {
    pub fn SLCD_Handler();
}
extern "C" {
    pub fn AES_Handler();
}
extern "C" {
    pub fn TRNG_Handler();
}
#[doc = " \\brief  Union type to access the Application Program Status Register (APSR)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union APSR_Type {
    #[doc = "< Structure used for bit  access"]
    pub b: APSR_Type__bindgen_ty_1,
    #[doc = "< Type      used for word access"]
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct APSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_APSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type__bindgen_ty_1))
    );
}
impl APSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn Q(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Q(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        _reserved0: u32,
        Q: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 27u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Q: u32 = unsafe { ::core::mem::transmute(Q) };
            Q as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_APSR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<APSR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<APSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(APSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<APSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(APSR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(APSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " \\brief  Union type to access the Interrupt Program Status Register (IPSR)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union IPSR_Type {
    #[doc = "< Structure used for bit  access"]
    pub b: IPSR_Type__bindgen_ty_1,
    #[doc = "< Type      used for word access"]
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct IPSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_IPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type__bindgen_ty_1))
    );
}
impl IPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 23u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 23u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ISR: u32, _reserved0: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 23u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_IPSR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<IPSR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<IPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(IPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<IPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(IPSR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " \\brief  Union type to access the Special-Purpose Program Status Registers (xPSR)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union xPSR_Type {
    #[doc = "< Structure used for bit  access"]
    pub b: xPSR_Type__bindgen_ty_1,
    #[doc = "< Type      used for word access"]
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct xPSR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_xPSR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type__bindgen_ty_1))
    );
}
impl xPSR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ISR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_ISR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 15u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn T(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_T(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_IT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Q(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Q(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn V(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_V(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Z(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Z(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn N(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_N(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ISR: u32,
        _reserved0: u32,
        T: u32,
        IT: u32,
        Q: u32,
        V: u32,
        C: u32,
        Z: u32,
        N: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let ISR: u32 = unsafe { ::core::mem::transmute(ISR) };
            ISR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 15u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let T: u32 = unsafe { ::core::mem::transmute(T) };
            T as u64
        });
        __bindgen_bitfield_unit.set(25usize, 2u8, {
            let IT: u32 = unsafe { ::core::mem::transmute(IT) };
            IT as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let Q: u32 = unsafe { ::core::mem::transmute(Q) };
            Q as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let V: u32 = unsafe { ::core::mem::transmute(V) };
            V as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let C: u32 = unsafe { ::core::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Z: u32 = unsafe { ::core::mem::transmute(Z) };
            Z as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let N: u32 = unsafe { ::core::mem::transmute(N) };
            N as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_xPSR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<xPSR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<xPSR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(xPSR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<xPSR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(xPSR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xPSR_Type),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " \\brief  Union type to access the Control Registers (CONTROL)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union CONTROL_Type {
    #[doc = "< Structure used for bit  access"]
    pub b: CONTROL_Type__bindgen_ty_1,
    #[doc = "< Type      used for word access"]
    pub w: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct CONTROL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_CONTROL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type__bindgen_ty_1))
    );
}
impl CONTROL_Type__bindgen_ty_1 {
    #[inline]
    pub fn nPRIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_nPRIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SPSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FPCA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FPCA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn _reserved0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set__reserved0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        nPRIV: u32,
        SPSEL: u32,
        FPCA: u32,
        _reserved0: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let nPRIV: u32 = unsafe { ::core::mem::transmute(nPRIV) };
            nPRIV as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SPSEL: u32 = unsafe { ::core::mem::transmute(SPSEL) };
            SPSEL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FPCA: u32 = unsafe { ::core::mem::transmute(FPCA) };
            FPCA as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let _reserved0: u32 = unsafe { ::core::mem::transmute(_reserved0) };
            _reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CONTROL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<CONTROL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CONTROL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CONTROL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(CONTROL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CONTROL_Type),
            "::",
            stringify!(w)
        )
    );
}
#[doc = " \\brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NVIC_Type {
    #[doc = "< Offset: 0x000 (R/W)  Interrupt Set Enable Register"]
    pub ISER: [u32; 1usize],
    pub RESERVED0: [u32; 31usize],
    #[doc = "< Offset: 0x080 (R/W)  Interrupt Clear Enable Register"]
    pub ICER: [u32; 1usize],
    pub RSERVED1: [u32; 31usize],
    #[doc = "< Offset: 0x100 (R/W)  Interrupt Set Pending Register"]
    pub ISPR: [u32; 1usize],
    pub RESERVED2: [u32; 31usize],
    #[doc = "< Offset: 0x180 (R/W)  Interrupt Clear Pending Register"]
    pub ICPR: [u32; 1usize],
    pub RESERVED3: [u32; 31usize],
    pub RESERVED4: [u32; 64usize],
    #[doc = "< Offset: 0x300 (R/W)  Interrupt Priority Register"]
    pub IP: [u32; 8usize],
}
#[test]
fn bindgen_test_layout_NVIC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<NVIC_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NVIC_Type>(),
        800usize,
        concat!("Size of: ", stringify!(NVIC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVIC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVIC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISER) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED0) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICER) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RSERVED1) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RSERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISPR) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ISPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED2) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICPR) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(ICPR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED3) as usize - ptr as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED4) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(RESERVED4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IP) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(NVIC_Type),
            "::",
            stringify!(IP)
        )
    );
}
#[doc = " \\brief  Structure type to access the System Control Block (SCB)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SCB_Type {
    #[doc = "< Offset: 0x000 (R/ )  CPUID Base Register"]
    pub CPUID: u32,
    #[doc = "< Offset: 0x004 (R/W)  Interrupt Control and State Register"]
    pub ICSR: u32,
    #[doc = "< Offset: 0x008 (R/W)  Vector Table Offset Register"]
    pub VTOR: u32,
    #[doc = "< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register"]
    pub AIRCR: u32,
    #[doc = "< Offset: 0x010 (R/W)  System Control Register"]
    pub SCR: u32,
    #[doc = "< Offset: 0x014 (R/W)  Configuration Control Register"]
    pub CCR: u32,
    pub RESERVED1: u32,
    #[doc = "< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED"]
    pub SHP: [u32; 2usize],
    #[doc = "< Offset: 0x024 (R/W)  System Handler Control and State Register"]
    pub SHCSR: u32,
}
#[test]
fn bindgen_test_layout_SCB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SCB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SCB_Type>(),
        40usize,
        concat!("Size of: ", stringify!(SCB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SCB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SCB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CPUID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CPUID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ICSR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(ICSR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VTOR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(VTOR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AIRCR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(AIRCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SCR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(CCR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESERVED1) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(RESERVED1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SHP) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SHCSR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SCB_Type),
            "::",
            stringify!(SHCSR)
        )
    );
}
#[doc = " \\brief  Structure type to access the System Timer (SysTick)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SysTick_Type {
    #[doc = "< Offset: 0x000 (R/W)  SysTick Control and Status Register"]
    pub CTRL: u32,
    #[doc = "< Offset: 0x004 (R/W)  SysTick Reload Value Register"]
    pub LOAD: u32,
    #[doc = "< Offset: 0x008 (R/W)  SysTick Current Value Register"]
    pub VAL: u32,
    #[doc = "< Offset: 0x00C (R/ )  SysTick Calibration Register"]
    pub CALIB: u32,
}
#[test]
fn bindgen_test_layout_SysTick_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SysTick_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SysTick_Type>(),
        16usize,
        concat!("Size of: ", stringify!(SysTick_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SysTick_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SysTick_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LOAD) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(LOAD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VAL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(VAL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CALIB) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SysTick_Type),
            "::",
            stringify!(CALIB)
        )
    );
}
#[doc = " \\brief  Structure type to access the Memory Protection Unit (MPU)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MPU_Type {
    #[doc = "< Offset: 0x000 (R/ )  MPU Type Register"]
    pub TYPE: u32,
    #[doc = "< Offset: 0x004 (R/W)  MPU Control Register"]
    pub CTRL: u32,
    #[doc = "< Offset: 0x008 (R/W)  MPU Region RNRber Register"]
    pub RNR: u32,
    #[doc = "< Offset: 0x00C (R/W)  MPU Region Base Address Register"]
    pub RBAR: u32,
    #[doc = "< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register"]
    pub RASR: u32,
}
#[test]
fn bindgen_test_layout_MPU_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MPU_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MPU_Type>(),
        20usize,
        concat!("Size of: ", stringify!(MPU_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MPU_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MPU_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TYPE) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(TYPE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RNR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RNR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RBAR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RBAR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RASR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MPU_Type),
            "::",
            stringify!(RASR)
        )
    );
}
extern "C" {
    #[doc = "< System Clock Frequency (Core Clock)"]
    pub static mut SystemCoreClock: u32;
}
extern "C" {
    pub fn SystemInit();
}
extern "C" {
    pub fn SystemCoreClockUpdate();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_CTRLA_Type__bindgen_ty_1))
    );
}
impl AC_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u8, ENABLE: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_CTRLB_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_CTRLB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_CTRLB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_CTRLB_Type__bindgen_ty_1))
    );
}
impl AC_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn START0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_START0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn START1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_START1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(START0: u8, START1: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let START0: u8 = unsafe { ::core::mem::transmute(START0) };
            START0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let START1: u8 = unsafe { ::core::mem::transmute(START1) };
            START1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_CTRLB_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_CTRLB_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_CTRLB_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_CTRLB_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_CTRLB_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_CTRLB_Type__bindgen_ty_2))
    );
}
impl AC_CTRLB_Type__bindgen_ty_2 {
    #[inline]
    pub fn START(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_START(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(START: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let START: u8 = unsafe { ::core::mem::transmute(START) };
            START as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_CTRLB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_CTRLB_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_CTRLB_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_CTRLB_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct AC_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_AC_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(AC_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(AC_EVCTRL_Type__bindgen_ty_1))
    );
}
impl AC_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn COMPEO0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COMPEO0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMPEO1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COMPEO1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINEO0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WINEO0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMPEI0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COMPEI0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMPEI1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COMPEI1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEI0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_INVEI0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEI1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_INVEI1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        COMPEO0: u16,
        COMPEO1: u16,
        WINEO0: u16,
        COMPEI0: u16,
        COMPEI1: u16,
        INVEI0: u16,
        INVEI1: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let COMPEO0: u16 = unsafe { ::core::mem::transmute(COMPEO0) };
            COMPEO0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let COMPEO1: u16 = unsafe { ::core::mem::transmute(COMPEO1) };
            COMPEO1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WINEO0: u16 = unsafe { ::core::mem::transmute(WINEO0) };
            WINEO0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let COMPEI0: u16 = unsafe { ::core::mem::transmute(COMPEI0) };
            COMPEI0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let COMPEI1: u16 = unsafe { ::core::mem::transmute(COMPEI1) };
            COMPEI1 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let INVEI0: u16 = unsafe { ::core::mem::transmute(INVEI0) };
            INVEI0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let INVEI1: u16 = unsafe { ::core::mem::transmute(INVEI1) };
            INVEI1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct AC_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_AC_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(AC_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(AC_EVCTRL_Type__bindgen_ty_2))
    );
}
impl AC_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn COMPEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_COMPEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn WINEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WINEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMPEI(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_COMPEI(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEI(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_INVEI(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        COMPEO: u16,
        WINEO: u16,
        COMPEI: u16,
        INVEI: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let COMPEO: u16 = unsafe { ::core::mem::transmute(COMPEO) };
            COMPEO as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WINEO: u16 = unsafe { ::core::mem::transmute(WINEO) };
            WINEO as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let COMPEI: u16 = unsafe { ::core::mem::transmute(COMPEI) };
            COMPEI as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let INVEI: u16 = unsafe { ::core::mem::transmute(INVEI) };
            INVEI as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_EVCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_EVCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(AC_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_EVCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(AC_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTENCLR_Type__bindgen_ty_1))
    );
}
impl AC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn COMP0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_COMP0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMP1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_COMP1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WIN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WIN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP0: u8, COMP1: u8, WIN0: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let COMP0: u8 = unsafe { ::core::mem::transmute(COMP0) };
            COMP0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let COMP1: u8 = unsafe { ::core::mem::transmute(COMP1) };
            COMP1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WIN0: u8 = unsafe { ::core::mem::transmute(WIN0) };
            WIN0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTENCLR_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTENCLR_Type__bindgen_ty_2))
    );
}
impl AC_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn COMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_COMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn WIN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WIN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP: u8, WIN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let COMP: u8 = unsafe { ::core::mem::transmute(COMP) };
            COMP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WIN: u8 = unsafe { ::core::mem::transmute(WIN) };
            WIN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTENSET_Type__bindgen_ty_1))
    );
}
impl AC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn COMP0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_COMP0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMP1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_COMP1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WIN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WIN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP0: u8, COMP1: u8, WIN0: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let COMP0: u8 = unsafe { ::core::mem::transmute(COMP0) };
            COMP0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let COMP1: u8 = unsafe { ::core::mem::transmute(COMP1) };
            COMP1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WIN0: u8 = unsafe { ::core::mem::transmute(WIN0) };
            WIN0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTENSET_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTENSET_Type__bindgen_ty_2))
    );
}
impl AC_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn COMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_COMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn WIN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WIN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP: u8, WIN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let COMP: u8 = unsafe { ::core::mem::transmute(COMP) };
            COMP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WIN: u8 = unsafe { ::core::mem::transmute(WIN) };
            WIN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTFLAG_Type__bindgen_ty_1))
    );
}
impl AC_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn COMP0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_COMP0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMP1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_COMP1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WIN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WIN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP0: u8, COMP1: u8, WIN0: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let COMP0: u8 = unsafe { ::core::mem::transmute(COMP0) };
            COMP0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let COMP1: u8 = unsafe { ::core::mem::transmute(COMP1) };
            COMP1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WIN0: u8 = unsafe { ::core::mem::transmute(WIN0) };
            WIN0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTFLAG_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTFLAG_Type__bindgen_ty_2))
    );
}
impl AC_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn COMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_COMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn WIN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WIN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP: u8, WIN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let COMP: u8 = unsafe { ::core::mem::transmute(COMP) };
            COMP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WIN: u8 = unsafe { ::core::mem::transmute(WIN) };
            WIN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_STATUSA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_STATUSA_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_STATUSA_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_STATUSA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_STATUSA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSA_Type__bindgen_ty_1))
    );
}
impl AC_STATUSA_Type__bindgen_ty_1 {
    #[inline]
    pub fn STATE0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STATE0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STATE1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STATE1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WSTATE0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_WSTATE0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        STATE0: u8,
        STATE1: u8,
        WSTATE0: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let STATE0: u8 = unsafe { ::core::mem::transmute(STATE0) };
            STATE0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let STATE1: u8 = unsafe { ::core::mem::transmute(STATE1) };
            STATE1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let WSTATE0: u8 = unsafe { ::core::mem::transmute(WSTATE0) };
            WSTATE0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_STATUSA_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_STATUSA_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSA_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSA_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSA_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSA_Type__bindgen_ty_2))
    );
}
impl AC_STATUSA_Type__bindgen_ty_2 {
    #[inline]
    pub fn STATE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STATE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(STATE: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let STATE: u8 = unsafe { ::core::mem::transmute(STATE) };
            STATE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_STATUSA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_STATUSA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSA_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_STATUSB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_STATUSB_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_STATUSB_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_STATUSB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_STATUSB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSB_Type__bindgen_ty_1))
    );
}
impl AC_STATUSB_Type__bindgen_ty_1 {
    #[inline]
    pub fn READY0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_READY0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn READY1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_READY1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(READY0: u8, READY1: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let READY0: u8 = unsafe { ::core::mem::transmute(READY0) };
            READY0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let READY1: u8 = unsafe { ::core::mem::transmute(READY1) };
            READY1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_STATUSB_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_STATUSB_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSB_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSB_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSB_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSB_Type__bindgen_ty_2))
    );
}
impl AC_STATUSB_Type__bindgen_ty_2 {
    #[inline]
    pub fn READY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_READY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(READY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let READY: u8 = unsafe { ::core::mem::transmute(READY) };
            READY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_STATUSB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_STATUSB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_STATUSB_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_STATUSB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_STATUSB_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_STATUSB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSB_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_STATUSB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_DBGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_DBGCTRL_Type__bindgen_ty_1))
    );
}
impl AC_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGRUN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGRUN: u8 = unsafe { ::core::mem::transmute(DBGRUN) };
            DBGRUN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_DBGCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_DBGCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_WINCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_WINCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_WINCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_WINCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_WINCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_WINCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_WINCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_WINCTRL_Type__bindgen_ty_1))
    );
}
impl AC_WINCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn WEN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WEN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINTSEL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_WINTSEL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WEN0: u8, WINTSEL0: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WEN0: u8 = unsafe { ::core::mem::transmute(WEN0) };
            WEN0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let WINTSEL0: u8 = unsafe { ::core::mem::transmute(WINTSEL0) };
            WINTSEL0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_WINCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_WINCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_WINCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_WINCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_WINCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_WINCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_WINCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_WINCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_SCALER_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_SCALER_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AC_SCALER_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AC_SCALER_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_SCALER_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AC_SCALER_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_SCALER_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_SCALER_Type__bindgen_ty_1))
    );
}
impl AC_SCALER_Type__bindgen_ty_1 {
    #[inline]
    pub fn VALUE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_VALUE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(VALUE: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let VALUE: u8 = unsafe { ::core::mem::transmute(VALUE) };
            VALUE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_SCALER_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_SCALER_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_SCALER_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AC_SCALER_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_SCALER_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AC_SCALER_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_SCALER_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_SCALER_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_COMPCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_COMPCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct AC_COMPCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_AC_COMPCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_COMPCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(AC_COMPCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_COMPCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(AC_COMPCTRL_Type__bindgen_ty_1))
    );
}
impl AC_COMPCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SINGLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SINGLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INTSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_INTSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MUXNEG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MUXNEG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn MUXPOS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MUXPOS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPEED(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SPEED(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn HYSTEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HYSTEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HYST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_HYST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FLEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_FLEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn OUT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_OUT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u32,
        SINGLE: u32,
        INTSEL: u32,
        RUNSTDBY: u32,
        MUXNEG: u32,
        MUXPOS: u32,
        SWAP: u32,
        SPEED: u32,
        HYSTEN: u32,
        HYST: u32,
        FLEN: u32,
        OUT: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SINGLE: u32 = unsafe { ::core::mem::transmute(SINGLE) };
            SINGLE as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let INTSEL: u32 = unsafe { ::core::mem::transmute(INTSEL) };
            INTSEL as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let MUXNEG: u32 = unsafe { ::core::mem::transmute(MUXNEG) };
            MUXNEG as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let MUXPOS: u32 = unsafe { ::core::mem::transmute(MUXPOS) };
            MUXPOS as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let SWAP: u32 = unsafe { ::core::mem::transmute(SWAP) };
            SWAP as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let SPEED: u32 = unsafe { ::core::mem::transmute(SPEED) };
            SPEED as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let HYSTEN: u32 = unsafe { ::core::mem::transmute(HYSTEN) };
            HYSTEN as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let HYST: u32 = unsafe { ::core::mem::transmute(HYST) };
            HYST as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let FLEN: u32 = unsafe { ::core::mem::transmute(FLEN) };
            FLEN as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let OUT: u32 = unsafe { ::core::mem::transmute(OUT) };
            OUT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_COMPCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_COMPCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_COMPCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(AC_COMPCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_COMPCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(AC_COMPCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_COMPCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_COMPCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AC_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AC_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: AC_SYNCBUSY_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct AC_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_AC_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AC_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(AC_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(AC_SYNCBUSY_Type__bindgen_ty_1))
    );
}
impl AC_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINCTRL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WINCTRL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMPCTRL0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COMPCTRL0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMPCTRL1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COMPCTRL1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        WINCTRL: u32,
        COMPCTRL0: u32,
        COMPCTRL1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WINCTRL: u32 = unsafe { ::core::mem::transmute(WINCTRL) };
            WINCTRL as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let COMPCTRL0: u32 = unsafe { ::core::mem::transmute(COMPCTRL0) };
            COMPCTRL0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let COMPCTRL1: u32 = unsafe { ::core::mem::transmute(COMPCTRL1) };
            COMPCTRL1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct AC_SYNCBUSY_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_AC_SYNCBUSY_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<AC_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(AC_SYNCBUSY_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(AC_SYNCBUSY_Type__bindgen_ty_2))
    );
}
impl AC_SYNCBUSY_Type__bindgen_ty_2 {
    #[inline]
    pub fn COMPCTRL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_COMPCTRL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMPCTRL: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let COMPCTRL: u32 = unsafe { ::core::mem::transmute(COMPCTRL) };
            COMPCTRL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AC_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AC_SYNCBUSY_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AC_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(AC_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AC_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(AC_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_SYNCBUSY_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AC_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Ac {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control A"]
    pub CTRLA: AC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x01 ( /W  8) Control B"]
    pub CTRLB: AC_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) Event Control"]
    pub EVCTRL: AC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: AC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: AC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: AC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x07 (R/   8) Status A"]
    pub STATUSA: AC_STATUSA_Type,
    #[doc = "< \\brief Offset: 0x08 (R/   8) Status B"]
    pub STATUSB: AC_STATUSB_Type,
    #[doc = "< \\brief Offset: 0x09 (R/W  8) Debug Control"]
    pub DBGCTRL: AC_DBGCTRL_Type,
    #[doc = "< \\brief Offset: 0x0A (R/W  8) Window Control"]
    pub WINCTRL: AC_WINCTRL_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Scaler n"]
    pub SCALER: [AC_SCALER_Type; 2usize],
    pub Reserved2: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Comparator Control n"]
    pub COMPCTRL: [AC_COMPCTRL_Type; 2usize],
    pub Reserved3: [RoReg8; 8usize],
    #[doc = "< \\brief Offset: 0x20 (R/  32) Synchronization Busy"]
    pub SYNCBUSY: AC_SYNCBUSY_Type,
}
#[test]
fn bindgen_test_layout_Ac() {
    const UNINIT: ::core::mem::MaybeUninit<Ac> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Ac>(),
        36usize,
        concat!("Size of: ", stringify!(Ac))
    );
    assert_eq!(
        ::core::mem::align_of::<Ac>(),
        4usize,
        concat!("Alignment of ", stringify!(Ac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ac), "::", stringify!(CTRLA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        1usize,
        concat!("Offset of field: ", stringify!(Ac), "::", stringify!(CTRLB))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUSA) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(STATUSA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUSB) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(STATUSB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WINCTRL) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(WINCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SCALER) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(SCALER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COMPCTRL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(COMPCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Ac),
            "::",
            stringify!(SYNCBUSY)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_ADC_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_CTRLA_Type__bindgen_ty_1))
    );
}
impl ADC_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u8,
        ENABLE: u8,
        RUNSTDBY: u8,
        ONDEMAND: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u8 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u8 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_ADC_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_CTRLB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CTRLB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_CTRLB_Type__bindgen_ty_1))
    );
}
impl ADC_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn PRESCALER(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_PRESCALER(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PRESCALER: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let PRESCALER: u8 = unsafe { ::core::mem::transmute(PRESCALER) };
            PRESCALER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_CTRLB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_CTRLB_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CTRLB_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_REFCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_REFCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_REFCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_ADC_REFCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_REFCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_REFCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_REFCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_REFCTRL_Type__bindgen_ty_1))
    );
}
impl ADC_REFCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn REFSEL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_REFSEL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn REFCOMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_REFCOMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(REFSEL: u8, REFCOMP: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let REFSEL: u8 = unsafe { ::core::mem::transmute(REFSEL) };
            REFSEL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let REFCOMP: u8 = unsafe { ::core::mem::transmute(REFCOMP) };
            REFCOMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_REFCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_REFCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_REFCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_REFCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_REFCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_REFCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_REFCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_REFCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_ADC_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_EVCTRL_Type__bindgen_ty_1))
    );
}
impl ADC_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn FLUSHEI(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FLUSHEI(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STARTEI(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STARTEI(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FLUSHINV(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FLUSHINV(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STARTINV(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STARTINV(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESRDYEO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RESRDYEO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINMONEO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WINMONEO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FLUSHEI: u8,
        STARTEI: u8,
        FLUSHINV: u8,
        STARTINV: u8,
        RESRDYEO: u8,
        WINMONEO: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FLUSHEI: u8 = unsafe { ::core::mem::transmute(FLUSHEI) };
            FLUSHEI as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let STARTEI: u8 = unsafe { ::core::mem::transmute(STARTEI) };
            STARTEI as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FLUSHINV: u8 = unsafe { ::core::mem::transmute(FLUSHINV) };
            FLUSHINV as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let STARTINV: u8 = unsafe { ::core::mem::transmute(STARTINV) };
            STARTINV as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RESRDYEO: u8 = unsafe { ::core::mem::transmute(RESRDYEO) };
            RESRDYEO as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let WINMONEO: u8 = unsafe { ::core::mem::transmute(WINMONEO) };
            WINMONEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_EVCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_EVCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_EVCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_ADC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_INTENCLR_Type__bindgen_ty_1))
    );
}
impl ADC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn RESRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RESRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVERRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVERRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINMON(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WINMON(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RESRDY: u8,
        OVERRUN: u8,
        WINMON: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RESRDY: u8 = unsafe { ::core::mem::transmute(RESRDY) };
            RESRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVERRUN: u8 = unsafe { ::core::mem::transmute(OVERRUN) };
            OVERRUN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WINMON: u8 = unsafe { ::core::mem::transmute(WINMON) };
            WINMON as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_ADC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_INTENSET_Type__bindgen_ty_1))
    );
}
impl ADC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn RESRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RESRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVERRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVERRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINMON(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WINMON(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RESRDY: u8,
        OVERRUN: u8,
        WINMON: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RESRDY: u8 = unsafe { ::core::mem::transmute(RESRDY) };
            RESRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVERRUN: u8 = unsafe { ::core::mem::transmute(OVERRUN) };
            OVERRUN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WINMON: u8 = unsafe { ::core::mem::transmute(WINMON) };
            WINMON as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_ADC_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_INTFLAG_Type__bindgen_ty_1))
    );
}
impl ADC_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn RESRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RESRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVERRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVERRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINMON(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WINMON(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RESRDY: u8,
        OVERRUN: u8,
        WINMON: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RESRDY: u8 = unsafe { ::core::mem::transmute(RESRDY) };
            RESRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVERRUN: u8 = unsafe { ::core::mem::transmute(OVERRUN) };
            OVERRUN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WINMON: u8 = unsafe { ::core::mem::transmute(WINMON) };
            WINMON as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_SEQSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_SEQSTATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_SEQSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_ADC_SEQSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_SEQSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_SEQSTATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SEQSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(ADC_SEQSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl ADC_SEQSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn SEQSTATE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_SEQSTATE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn SEQBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SEQBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SEQSTATE: u8, SEQBUSY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let SEQSTATE: u8 = unsafe { ::core::mem::transmute(SEQSTATE) };
            SEQSTATE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SEQBUSY: u8 = unsafe { ::core::mem::transmute(SEQBUSY) };
            SEQBUSY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_SEQSTATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_SEQSTATUS_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_SEQSTATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_SEQSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SEQSTATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_SEQSTATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SEQSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SEQSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_INPUTCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_INPUTCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_INPUTCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_ADC_INPUTCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_INPUTCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_INPUTCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INPUTCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(ADC_INPUTCTRL_Type__bindgen_ty_1)
        )
    );
}
impl ADC_INPUTCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn MUXPOS(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_MUXPOS(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn MUXNEG(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_MUXNEG(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MUXPOS: u16, MUXNEG: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let MUXPOS: u16 = unsafe { ::core::mem::transmute(MUXPOS) };
            MUXPOS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let MUXNEG: u16 = unsafe { ::core::mem::transmute(MUXNEG) };
            MUXNEG as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_INPUTCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_INPUTCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_INPUTCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_INPUTCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_INPUTCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_INPUTCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INPUTCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_INPUTCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_CTRLC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_CTRLC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_CTRLC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_ADC_CTRLC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_CTRLC_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_CTRLC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CTRLC_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_CTRLC_Type__bindgen_ty_1))
    );
}
impl ADC_CTRLC_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIFFMODE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DIFFMODE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LEFTADJ(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LEFTADJ(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FREERUN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_FREERUN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CORREN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CORREN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESSEL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_RESSEL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn R2R(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_R2R(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINMODE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_WINMODE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn DUALSEL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_DUALSEL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DIFFMODE: u16,
        LEFTADJ: u16,
        FREERUN: u16,
        CORREN: u16,
        RESSEL: u16,
        R2R: u16,
        WINMODE: u16,
        DUALSEL: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DIFFMODE: u16 = unsafe { ::core::mem::transmute(DIFFMODE) };
            DIFFMODE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LEFTADJ: u16 = unsafe { ::core::mem::transmute(LEFTADJ) };
            LEFTADJ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FREERUN: u16 = unsafe { ::core::mem::transmute(FREERUN) };
            FREERUN as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CORREN: u16 = unsafe { ::core::mem::transmute(CORREN) };
            CORREN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let RESSEL: u16 = unsafe { ::core::mem::transmute(RESSEL) };
            RESSEL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let R2R: u16 = unsafe { ::core::mem::transmute(R2R) };
            R2R as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let WINMODE: u16 = unsafe { ::core::mem::transmute(WINMODE) };
            WINMODE as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let DUALSEL: u16 = unsafe { ::core::mem::transmute(DUALSEL) };
            DUALSEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_CTRLC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_CTRLC_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_CTRLC_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_CTRLC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CTRLC_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_CTRLC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CTRLC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CTRLC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_AVGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_AVGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_AVGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_ADC_AVGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_AVGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_AVGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_AVGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_AVGCTRL_Type__bindgen_ty_1))
    );
}
impl ADC_AVGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SAMPLENUM(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_SAMPLENUM(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ADJRES(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_ADJRES(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SAMPLENUM: u8, ADJRES: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SAMPLENUM: u8 = unsafe { ::core::mem::transmute(SAMPLENUM) };
            SAMPLENUM as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let ADJRES: u8 = unsafe { ::core::mem::transmute(ADJRES) };
            ADJRES as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_AVGCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_AVGCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_AVGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_AVGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_AVGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_AVGCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AVGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_AVGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_SAMPCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_SAMPCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_SAMPCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_ADC_SAMPCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_SAMPCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_SAMPCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SAMPCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_SAMPCTRL_Type__bindgen_ty_1))
    );
}
impl ADC_SAMPCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SAMPLEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_SAMPLEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn OFFCOMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OFFCOMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SAMPLEN: u8, OFFCOMP: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let SAMPLEN: u8 = unsafe { ::core::mem::transmute(SAMPLEN) };
            SAMPLEN as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OFFCOMP: u8 = unsafe { ::core::mem::transmute(OFFCOMP) };
            OFFCOMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_SAMPCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_SAMPCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_SAMPCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_SAMPCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SAMPCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_SAMPCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SAMPCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SAMPCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_WINLT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_WINLT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_WINLT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_ADC_WINLT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_WINLT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_WINLT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_WINLT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_WINLT_Type__bindgen_ty_1))
    );
}
impl ADC_WINLT_Type__bindgen_ty_1 {
    #[inline]
    pub fn WINLT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_WINLT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WINLT: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let WINLT: u16 = unsafe { ::core::mem::transmute(WINLT) };
            WINLT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_WINLT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_WINLT_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_WINLT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_WINLT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_WINLT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_WINLT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_WINLT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_WINLT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_WINUT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_WINUT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_WINUT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_ADC_WINUT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_WINUT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_WINUT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_WINUT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_WINUT_Type__bindgen_ty_1))
    );
}
impl ADC_WINUT_Type__bindgen_ty_1 {
    #[inline]
    pub fn WINUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_WINUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WINUT: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let WINUT: u16 = unsafe { ::core::mem::transmute(WINUT) };
            WINUT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_WINUT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_WINUT_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_WINUT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_WINUT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_WINUT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_WINUT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_WINUT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_WINUT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_GAINCORR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_GAINCORR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_GAINCORR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_ADC_GAINCORR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_GAINCORR_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_GAINCORR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_GAINCORR_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_GAINCORR_Type__bindgen_ty_1))
    );
}
impl ADC_GAINCORR_Type__bindgen_ty_1 {
    #[inline]
    pub fn GAINCORR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_GAINCORR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(GAINCORR: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let GAINCORR: u16 = unsafe { ::core::mem::transmute(GAINCORR) };
            GAINCORR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_GAINCORR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_GAINCORR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_GAINCORR_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_GAINCORR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_GAINCORR_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_GAINCORR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_GAINCORR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_GAINCORR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_OFFSETCORR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_OFFSETCORR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_OFFSETCORR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_ADC_OFFSETCORR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_OFFSETCORR_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_OFFSETCORR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_OFFSETCORR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(ADC_OFFSETCORR_Type__bindgen_ty_1)
        )
    );
}
impl ADC_OFFSETCORR_Type__bindgen_ty_1 {
    #[inline]
    pub fn OFFSETCORR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_OFFSETCORR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(OFFSETCORR: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let OFFSETCORR: u16 = unsafe { ::core::mem::transmute(OFFSETCORR) };
            OFFSETCORR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_OFFSETCORR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_OFFSETCORR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_OFFSETCORR_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_OFFSETCORR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_OFFSETCORR_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_OFFSETCORR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_OFFSETCORR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_OFFSETCORR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_SWTRIG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_SWTRIG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_SWTRIG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_ADC_SWTRIG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_SWTRIG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_SWTRIG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SWTRIG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_SWTRIG_Type__bindgen_ty_1))
    );
}
impl ADC_SWTRIG_Type__bindgen_ty_1 {
    #[inline]
    pub fn FLUSH(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FLUSH(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn START(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_START(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(FLUSH: u8, START: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FLUSH: u8 = unsafe { ::core::mem::transmute(FLUSH) };
            FLUSH as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let START: u8 = unsafe { ::core::mem::transmute(START) };
            START as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_SWTRIG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_SWTRIG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_SWTRIG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_SWTRIG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SWTRIG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_SWTRIG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SWTRIG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SWTRIG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ADC_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_ADC_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_DBGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_DBGCTRL_Type__bindgen_ty_1))
    );
}
impl ADC_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGRUN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGRUN: u8 = unsafe { ::core::mem::transmute(DBGRUN) };
            DBGRUN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_DBGCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_DBGCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(ADC_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(ADC_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_ADC_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_SYNCBUSY_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SYNCBUSY_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_SYNCBUSY_Type__bindgen_ty_1))
    );
}
impl ADC_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INPUTCTRL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_INPUTCTRL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTRLC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CTRLC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AVGCTRL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AVGCTRL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SAMPCTRL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SAMPCTRL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINLT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WINLT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WINUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WINUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GAINCORR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GAINCORR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OFFSETCORR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OFFSETCORR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWTRIG(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u16,
        ENABLE: u16,
        INPUTCTRL: u16,
        CTRLC: u16,
        AVGCTRL: u16,
        SAMPCTRL: u16,
        WINLT: u16,
        WINUT: u16,
        GAINCORR: u16,
        OFFSETCORR: u16,
        SWTRIG: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u16 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let INPUTCTRL: u16 = unsafe { ::core::mem::transmute(INPUTCTRL) };
            INPUTCTRL as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CTRLC: u16 = unsafe { ::core::mem::transmute(CTRLC) };
            CTRLC as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let AVGCTRL: u16 = unsafe { ::core::mem::transmute(AVGCTRL) };
            AVGCTRL as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SAMPCTRL: u16 = unsafe { ::core::mem::transmute(SAMPCTRL) };
            SAMPCTRL as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let WINLT: u16 = unsafe { ::core::mem::transmute(WINLT) };
            WINLT as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let WINUT: u16 = unsafe { ::core::mem::transmute(WINUT) };
            WINUT as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let GAINCORR: u16 = unsafe { ::core::mem::transmute(GAINCORR) };
            GAINCORR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let OFFSETCORR: u16 = unsafe { ::core::mem::transmute(OFFSETCORR) };
            OFFSETCORR as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let SWTRIG: u16 = unsafe { ::core::mem::transmute(SWTRIG) };
            SWTRIG as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_SYNCBUSY_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_SYNCBUSY_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SYNCBUSY_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_RESULT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_RESULT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_RESULT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_ADC_RESULT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_RESULT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_RESULT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_RESULT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_RESULT_Type__bindgen_ty_1))
    );
}
impl ADC_RESULT_Type__bindgen_ty_1 {
    #[inline]
    pub fn RESULT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_RESULT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(RESULT: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let RESULT: u16 = unsafe { ::core::mem::transmute(RESULT) };
            RESULT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_RESULT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_RESULT_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_RESULT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_RESULT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_RESULT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_RESULT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_RESULT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_RESULT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_SEQCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_SEQCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_SEQCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_ADC_SEQCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_SEQCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ADC_SEQCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SEQCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_SEQCTRL_Type__bindgen_ty_1))
    );
}
impl ADC_SEQCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SEQEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SEQEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SEQEN: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SEQEN: u32 = unsafe { ::core::mem::transmute(SEQEN) };
            SEQEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_SEQCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_SEQCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_SEQCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(ADC_SEQCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_SEQCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(ADC_SEQCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SEQCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_SEQCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ADC_CALIB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: ADC_CALIB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct ADC_CALIB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_ADC_CALIB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ADC_CALIB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_CALIB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CALIB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_CALIB_Type__bindgen_ty_1))
    );
}
impl ADC_CALIB_Type__bindgen_ty_1 {
    #[inline]
    pub fn BIASCOMP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_BIASCOMP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn BIASREFBUF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_BIASREFBUF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BIASCOMP: u16, BIASREFBUF: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let BIASCOMP: u16 = unsafe { ::core::mem::transmute(BIASCOMP) };
            BIASCOMP as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let BIASREFBUF: u16 = unsafe { ::core::mem::transmute(BIASREFBUF) };
            BIASREFBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_ADC_CALIB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<ADC_CALIB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ADC_CALIB_Type>(),
        2usize,
        concat!("Size of: ", stringify!(ADC_CALIB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<ADC_CALIB_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(ADC_CALIB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CALIB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ADC_CALIB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Adc {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control A"]
    pub CTRLA: ADC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x01 (R/W  8) Control B"]
    pub CTRLB: ADC_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W  8) Reference Control"]
    pub REFCTRL: ADC_REFCTRL_Type,
    #[doc = "< \\brief Offset: 0x03 (R/W  8) Event Control"]
    pub EVCTRL: ADC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: ADC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: ADC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: ADC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x07 (R/   8) Sequence Status"]
    pub SEQSTATUS: ADC_SEQSTATUS_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 16) Input Control"]
    pub INPUTCTRL: ADC_INPUTCTRL_Type,
    #[doc = "< \\brief Offset: 0x0A (R/W 16) Control C"]
    pub CTRLC: ADC_CTRLC_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Average Control"]
    pub AVGCTRL: ADC_AVGCTRL_Type,
    #[doc = "< \\brief Offset: 0x0D (R/W  8) Sample Time Control"]
    pub SAMPCTRL: ADC_SAMPCTRL_Type,
    #[doc = "< \\brief Offset: 0x0E (R/W 16) Window Monitor Lower Threshold"]
    pub WINLT: ADC_WINLT_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 16) Window Monitor Upper Threshold"]
    pub WINUT: ADC_WINUT_Type,
    #[doc = "< \\brief Offset: 0x12 (R/W 16) Gain Correction"]
    pub GAINCORR: ADC_GAINCORR_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 16) Offset Correction"]
    pub OFFSETCORR: ADC_OFFSETCORR_Type,
    pub Reserved1: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x18 (R/W  8) Software Trigger"]
    pub SWTRIG: ADC_SWTRIG_Type,
    pub Reserved2: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x1C (R/W  8) Debug Control"]
    pub DBGCTRL: ADC_DBGCTRL_Type,
    pub Reserved3: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x20 (R/  16) Synchronization Busy"]
    pub SYNCBUSY: ADC_SYNCBUSY_Type,
    pub Reserved4: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x24 (R/  16) Result"]
    pub RESULT: ADC_RESULT_Type,
    pub Reserved5: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x28 (R/W 32) Sequence Control"]
    pub SEQCTRL: ADC_SEQCTRL_Type,
    #[doc = "< \\brief Offset: 0x2C (R/W 16) Calibration"]
    pub CALIB: ADC_CALIB_Type,
}
#[test]
fn bindgen_test_layout_Adc() {
    const UNINIT: ::core::mem::MaybeUninit<Adc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Adc>(),
        48usize,
        concat!("Size of: ", stringify!(Adc))
    );
    assert_eq!(
        ::core::mem::align_of::<Adc>(),
        4usize,
        concat!("Alignment of ", stringify!(Adc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).REFCTRL) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(REFCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SEQSTATUS) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(SEQSTATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INPUTCTRL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(INPUTCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLC) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(CTRLC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AVGCTRL) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(AVGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SAMPCTRL) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(SAMPCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WINLT) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(WINLT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WINUT) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(WINUT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GAINCORR) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(GAINCORR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OFFSETCORR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(OFFSETCORR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SWTRIG) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(SWTRIG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RESULT) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(RESULT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SEQCTRL) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(SEQCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CALIB) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Adc),
            "::",
            stringify!(CALIB)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AES_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct AES_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_AES_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AES_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(AES_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(AES_CTRLA_Type__bindgen_ty_1))
    );
}
impl AES_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AESMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_AESMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn CFBS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_CFBS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn KEYSIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_KEYSIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CIPHER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CIPHER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STARTMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_STARTMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LOD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LOD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KEYGEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KEYGEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XORKEY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XORKEY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTYPE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CTYPE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        AESMODE: u32,
        CFBS: u32,
        KEYSIZE: u32,
        CIPHER: u32,
        STARTMODE: u32,
        LOD: u32,
        KEYGEN: u32,
        XORKEY: u32,
        CTYPE: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let AESMODE: u32 = unsafe { ::core::mem::transmute(AESMODE) };
            AESMODE as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let CFBS: u32 = unsafe { ::core::mem::transmute(CFBS) };
            CFBS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let KEYSIZE: u32 = unsafe { ::core::mem::transmute(KEYSIZE) };
            KEYSIZE as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CIPHER: u32 = unsafe { ::core::mem::transmute(CIPHER) };
            CIPHER as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let STARTMODE: u32 = unsafe { ::core::mem::transmute(STARTMODE) };
            STARTMODE as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let LOD: u32 = unsafe { ::core::mem::transmute(LOD) };
            LOD as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let KEYGEN: u32 = unsafe { ::core::mem::transmute(KEYGEN) };
            KEYGEN as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let XORKEY: u32 = unsafe { ::core::mem::transmute(XORKEY) };
            XORKEY as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let CTYPE: u32 = unsafe { ::core::mem::transmute(CTYPE) };
            CTYPE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AES_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(AES_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(AES_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AES_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AES_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AES_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AES_CTRLB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AES_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_CTRLB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AES_CTRLB_Type__bindgen_ty_1))
    );
}
impl AES_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn START(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_START(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NEWMSG(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NEWMSG(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EOM(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EOM(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GFMUL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GFMUL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        START: u8,
        NEWMSG: u8,
        EOM: u8,
        GFMUL: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let START: u8 = unsafe { ::core::mem::transmute(START) };
            START as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NEWMSG: u8 = unsafe { ::core::mem::transmute(NEWMSG) };
            NEWMSG as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EOM: u8 = unsafe { ::core::mem::transmute(EOM) };
            EOM as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let GFMUL: u8 = unsafe { ::core::mem::transmute(GFMUL) };
            GFMUL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AES_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_CTRLB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_CTRLB_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AES_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_CTRLB_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AES_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AES_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AES_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AES_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AES_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AES_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AES_INTENCLR_Type__bindgen_ty_1))
    );
}
impl AES_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENCCMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENCCMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GFMCMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GFMCMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ENCCMP: u8, GFMCMP: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ENCCMP: u8 = unsafe { ::core::mem::transmute(ENCCMP) };
            ENCCMP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let GFMCMP: u8 = unsafe { ::core::mem::transmute(GFMCMP) };
            GFMCMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AES_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AES_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AES_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AES_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AES_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AES_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AES_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AES_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AES_INTENSET_Type__bindgen_ty_1))
    );
}
impl AES_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENCCMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENCCMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GFMCMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GFMCMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ENCCMP: u8, GFMCMP: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ENCCMP: u8 = unsafe { ::core::mem::transmute(ENCCMP) };
            ENCCMP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let GFMCMP: u8 = unsafe { ::core::mem::transmute(GFMCMP) };
            GFMCMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AES_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AES_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AES_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AES_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AES_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AES_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AES_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AES_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AES_INTFLAG_Type__bindgen_ty_1))
    );
}
impl AES_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENCCMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENCCMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GFMCMP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_GFMCMP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ENCCMP: u8, GFMCMP: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ENCCMP: u8 = unsafe { ::core::mem::transmute(ENCCMP) };
            ENCCMP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let GFMCMP: u8 = unsafe { ::core::mem::transmute(GFMCMP) };
            GFMCMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AES_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AES_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AES_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_DATABUFPTR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AES_DATABUFPTR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AES_DATABUFPTR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AES_DATABUFPTR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AES_DATABUFPTR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AES_DATABUFPTR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_DATABUFPTR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(AES_DATABUFPTR_Type__bindgen_ty_1)
        )
    );
}
impl AES_DATABUFPTR_Type__bindgen_ty_1 {
    #[inline]
    pub fn INDATAPTR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_INDATAPTR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(INDATAPTR: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let INDATAPTR: u8 = unsafe { ::core::mem::transmute(INDATAPTR) };
            INDATAPTR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AES_DATABUFPTR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_DATABUFPTR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_DATABUFPTR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AES_DATABUFPTR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_DATABUFPTR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AES_DATABUFPTR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_DATABUFPTR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_DATABUFPTR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: AES_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct AES_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_AES_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<AES_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(AES_DBGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(AES_DBGCTRL_Type__bindgen_ty_1))
    );
}
impl AES_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGRUN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGRUN: u8 = unsafe { ::core::mem::transmute(DBGRUN) };
            DBGRUN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_AES_DBGCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_DBGCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(AES_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(AES_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_KEYWORD_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_AES_KEYWORD_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_KEYWORD_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_KEYWORD_Type>(),
        4usize,
        concat!("Size of: ", stringify!(AES_KEYWORD_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_KEYWORD_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(AES_KEYWORD_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_KEYWORD_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_INDATA_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_AES_INDATA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_INDATA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_INDATA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(AES_INDATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_INDATA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(AES_INDATA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_INDATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_INTVECTV_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_AES_INTVECTV_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_INTVECTV_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_INTVECTV_Type>(),
        4usize,
        concat!("Size of: ", stringify!(AES_INTVECTV_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_INTVECTV_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(AES_INTVECTV_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_INTVECTV_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_HASHKEY_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_AES_HASHKEY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_HASHKEY_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_HASHKEY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(AES_HASHKEY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_HASHKEY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(AES_HASHKEY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_HASHKEY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_GHASH_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_AES_GHASH_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_GHASH_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_GHASH_Type>(),
        4usize,
        concat!("Size of: ", stringify!(AES_GHASH_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_GHASH_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(AES_GHASH_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_GHASH_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_CIPLEN_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_AES_CIPLEN_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_CIPLEN_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_CIPLEN_Type>(),
        4usize,
        concat!("Size of: ", stringify!(AES_CIPLEN_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_CIPLEN_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(AES_CIPLEN_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_CIPLEN_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union AES_RANDSEED_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_AES_RANDSEED_Type() {
    const UNINIT: ::core::mem::MaybeUninit<AES_RANDSEED_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<AES_RANDSEED_Type>(),
        4usize,
        concat!("Size of: ", stringify!(AES_RANDSEED_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<AES_RANDSEED_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(AES_RANDSEED_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AES_RANDSEED_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Aes {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Control A"]
    pub CTRLA: AES_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Control B"]
    pub CTRLB: AES_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: AES_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: AES_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x07 (R/W  8) Interrupt Flag Status"]
    pub INTFLAG: AES_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W  8) Data buffer pointer"]
    pub DATABUFPTR: AES_DATABUFPTR_Type,
    #[doc = "< \\brief Offset: 0x09 ( /W  8) Debug control"]
    pub DBGCTRL: AES_DBGCTRL_Type,
    pub Reserved1: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x0C ( /W 32) Keyword n"]
    pub KEYWORD: [AES_KEYWORD_Type; 8usize],
    pub Reserved2: [RoReg8; 12usize],
    #[doc = "< \\brief Offset: 0x38 (R/W 32) Indata"]
    pub INDATA: AES_INDATA_Type,
    #[doc = "< \\brief Offset: 0x3C ( /W 32) Initialisation Vector n"]
    pub INTVECTV: [AES_INTVECTV_Type; 4usize],
    pub Reserved3: [RoReg8; 16usize],
    #[doc = "< \\brief Offset: 0x5C (R/W 32) Hash key n"]
    pub HASHKEY: [AES_HASHKEY_Type; 4usize],
    #[doc = "< \\brief Offset: 0x6C (R/W 32) Galois Hash n"]
    pub GHASH: [AES_GHASH_Type; 4usize],
    pub Reserved4: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x80 (R/W 32) Cipher Length"]
    pub CIPLEN: AES_CIPLEN_Type,
    #[doc = "< \\brief Offset: 0x84 (R/W 32) Random Seed"]
    pub RANDSEED: AES_RANDSEED_Type,
}
#[test]
fn bindgen_test_layout_Aes() {
    const UNINIT: ::core::mem::MaybeUninit<Aes> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Aes>(),
        136usize,
        concat!("Size of: ", stringify!(Aes))
    );
    assert_eq!(
        ::core::mem::align_of::<Aes>(),
        4usize,
        concat!("Alignment of ", stringify!(Aes))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DATABUFPTR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(DATABUFPTR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KEYWORD) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(KEYWORD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INDATA) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(INDATA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTVECTV) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(INTVECTV)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HASHKEY) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(HASHKEY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GHASH) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(GHASH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CIPLEN) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(CIPLEN)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RANDSEED) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(Aes),
            "::",
            stringify!(RANDSEED)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CCL_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: CCL_CTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCL_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_CCL_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<CCL_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(CCL_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CCL_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(CCL_CTRL_Type__bindgen_ty_1))
    );
}
impl CCL_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u8,
        ENABLE: u8,
        RUNSTDBY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u8 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CCL_CTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<CCL_CTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CCL_CTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(CCL_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CCL_CTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(CCL_CTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCL_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCL_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CCL_SEQCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: CCL_SEQCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CCL_SEQCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_CCL_SEQCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<CCL_SEQCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(CCL_SEQCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CCL_SEQCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(CCL_SEQCTRL_Type__bindgen_ty_1))
    );
}
impl CCL_SEQCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SEQSEL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_SEQSEL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SEQSEL: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SEQSEL: u8 = unsafe { ::core::mem::transmute(SEQSEL) };
            SEQSEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CCL_SEQCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<CCL_SEQCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CCL_SEQCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(CCL_SEQCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CCL_SEQCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(CCL_SEQCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCL_SEQCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCL_SEQCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CCL_LUTCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: CCL_LUTCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct CCL_LUTCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_CCL_LUTCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<CCL_LUTCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(CCL_LUTCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<CCL_LUTCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(CCL_LUTCTRL_Type__bindgen_ty_1))
    );
}
impl CCL_LUTCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_FILTSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn EDGESEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EDGESEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INSEL0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_INSEL0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn INSEL1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_INSEL1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn INSEL2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_INSEL2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LUTEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LUTEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LUTEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LUTEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRUTH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_TRUTH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u32,
        FILTSEL: u32,
        EDGESEL: u32,
        INSEL0: u32,
        INSEL1: u32,
        INSEL2: u32,
        INVEI: u32,
        LUTEI: u32,
        LUTEO: u32,
        TRUTH: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let FILTSEL: u32 = unsafe { ::core::mem::transmute(FILTSEL) };
            FILTSEL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EDGESEL: u32 = unsafe { ::core::mem::transmute(EDGESEL) };
            EDGESEL as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let INSEL0: u32 = unsafe { ::core::mem::transmute(INSEL0) };
            INSEL0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let INSEL1: u32 = unsafe { ::core::mem::transmute(INSEL1) };
            INSEL1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let INSEL2: u32 = unsafe { ::core::mem::transmute(INSEL2) };
            INSEL2 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let INVEI: u32 = unsafe { ::core::mem::transmute(INVEI) };
            INVEI as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let LUTEI: u32 = unsafe { ::core::mem::transmute(LUTEI) };
            LUTEI as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let LUTEO: u32 = unsafe { ::core::mem::transmute(LUTEO) };
            LUTEO as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let TRUTH: u32 = unsafe { ::core::mem::transmute(TRUTH) };
            TRUTH as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_CCL_LUTCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<CCL_LUTCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CCL_LUTCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(CCL_LUTCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<CCL_LUTCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(CCL_LUTCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCL_LUTCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCL_LUTCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Ccl {
    #[doc = "< \\brief Offset: 0x0 (R/W  8) Control"]
    pub CTRL: CCL_CTRL_Type,
    pub Reserved1: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x4 (R/W  8) SEQ Control x"]
    pub SEQCTRL: [CCL_SEQCTRL_Type; 2usize],
    pub Reserved2: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x8 (R/W 32) LUT Control x"]
    pub LUTCTRL: [CCL_LUTCTRL_Type; 4usize],
}
#[test]
fn bindgen_test_layout_Ccl() {
    const UNINIT: ::core::mem::MaybeUninit<Ccl> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Ccl>(),
        24usize,
        concat!("Size of: ", stringify!(Ccl))
    );
    assert_eq!(
        ::core::mem::align_of::<Ccl>(),
        4usize,
        concat!("Alignment of ", stringify!(Ccl))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ccl), "::", stringify!(CTRL))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Ccl),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SEQCTRL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Ccl),
            "::",
            stringify!(SEQCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Ccl),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LUTCTRL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Ccl),
            "::",
            stringify!(LUTCTRL)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DMAC_CTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_CTRL_Type__bindgen_ty_1))
    );
}
impl DMAC_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DMAENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DMAENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CRCENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CRCENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEN0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LVLEN0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEN1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LVLEN1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEN2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LVLEN2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEN3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LVLEN3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u16,
        DMAENABLE: u16,
        CRCENABLE: u16,
        LVLEN0: u16,
        LVLEN1: u16,
        LVLEN2: u16,
        LVLEN3: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u16 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DMAENABLE: u16 = unsafe { ::core::mem::transmute(DMAENABLE) };
            DMAENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CRCENABLE: u16 = unsafe { ::core::mem::transmute(CRCENABLE) };
            CRCENABLE as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let LVLEN0: u16 = unsafe { ::core::mem::transmute(LVLEN0) };
            LVLEN0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let LVLEN1: u16 = unsafe { ::core::mem::transmute(LVLEN1) };
            LVLEN1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let LVLEN2: u16 = unsafe { ::core::mem::transmute(LVLEN2) };
            LVLEN2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let LVLEN3: u16 = unsafe { ::core::mem::transmute(LVLEN3) };
            LVLEN3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CTRL_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_CTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_CTRL_Type__bindgen_ty_2))
    );
}
impl DMAC_CTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn LVLEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_LVLEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LVLEN: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let LVLEN: u16 = unsafe { ::core::mem::transmute(LVLEN) };
            LVLEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_CTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_CTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_CTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CRCCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CRCCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CRCCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CRCCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_CRCCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_CRCCTRL_Type__bindgen_ty_1))
    );
}
impl DMAC_CRCCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn CRCBEATSIZE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_CRCBEATSIZE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CRCPOLY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_CRCPOLY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CRCSRC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_CRCSRC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CRCBEATSIZE: u16,
        CRCPOLY: u16,
        CRCSRC: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let CRCBEATSIZE: u16 = unsafe { ::core::mem::transmute(CRCBEATSIZE) };
            CRCBEATSIZE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let CRCPOLY: u16 = unsafe { ::core::mem::transmute(CRCPOLY) };
            CRCPOLY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let CRCSRC: u16 = unsafe { ::core::mem::transmute(CRCSRC) };
            CRCSRC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CRCCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_CRCCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_CRCCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_CRCCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CRCDATAIN_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CRCDATAIN_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CRCDATAIN_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CRCDATAIN_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCDATAIN_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_CRCDATAIN_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCDATAIN_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CRCDATAIN_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CRCDATAIN_Type__bindgen_ty_1 {
    #[inline]
    pub fn CRCDATAIN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_CRCDATAIN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CRCDATAIN: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let CRCDATAIN: u32 = unsafe { ::core::mem::transmute(CRCDATAIN) };
            CRCDATAIN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CRCDATAIN_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_CRCDATAIN_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCDATAIN_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_CRCDATAIN_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCDATAIN_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_CRCDATAIN_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCDATAIN_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCDATAIN_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CRCCHKSUM_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CRCCHKSUM_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CRCCHKSUM_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CRCCHKSUM_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCCHKSUM_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_CRCCHKSUM_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCCHKSUM_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CRCCHKSUM_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CRCCHKSUM_Type__bindgen_ty_1 {
    #[inline]
    pub fn CRCCHKSUM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_CRCCHKSUM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CRCCHKSUM: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let CRCCHKSUM: u32 = unsafe { ::core::mem::transmute(CRCCHKSUM) };
            CRCCHKSUM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CRCCHKSUM_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_CRCCHKSUM_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCCHKSUM_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_CRCCHKSUM_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCCHKSUM_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_CRCCHKSUM_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCCHKSUM_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCCHKSUM_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CRCSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CRCSTATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CRCSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CRCSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CRCSTATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CRCSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CRCSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn CRCBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CRCBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CRCZERO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CRCZERO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CRCBUSY: u8, CRCZERO: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CRCBUSY: u8 = unsafe { ::core::mem::transmute(CRCBUSY) };
            CRCBUSY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CRCZERO: u8 = unsafe { ::core::mem::transmute(CRCZERO) };
            CRCZERO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CRCSTATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_CRCSTATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_CRCSTATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CRCSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CRCSTATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CRCSTATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CRCSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_DBGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_DBGCTRL_Type__bindgen_ty_1))
    );
}
impl DMAC_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGRUN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGRUN: u8 = unsafe { ::core::mem::transmute(DBGRUN) };
            DBGRUN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_DBGCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_DBGCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_QOSCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_QOSCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_QOSCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_QOSCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_QOSCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_QOSCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_QOSCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_QOSCTRL_Type__bindgen_ty_1))
    );
}
impl DMAC_QOSCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn WRBQOS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_WRBQOS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FQOS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_FQOS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DQOS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_DQOS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WRBQOS: u8, FQOS: u8, DQOS: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let WRBQOS: u8 = unsafe { ::core::mem::transmute(WRBQOS) };
            WRBQOS as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let FQOS: u8 = unsafe { ::core::mem::transmute(FQOS) };
            FQOS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let DQOS: u8 = unsafe { ::core::mem::transmute(DQOS) };
            DQOS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_QOSCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_QOSCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_QOSCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_QOSCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_QOSCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_QOSCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_QOSCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_QOSCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_SWTRIGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_SWTRIGCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DMAC_SWTRIGCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_SWTRIGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_SWTRIGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_SWTRIGCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_SWTRIGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_SWTRIGCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_SWTRIGCTRL_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_SWTRIGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWTRIG0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWTRIG15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWTRIG0: u32,
        SWTRIG1: u32,
        SWTRIG2: u32,
        SWTRIG3: u32,
        SWTRIG4: u32,
        SWTRIG5: u32,
        SWTRIG6: u32,
        SWTRIG7: u32,
        SWTRIG8: u32,
        SWTRIG9: u32,
        SWTRIG10: u32,
        SWTRIG11: u32,
        SWTRIG12: u32,
        SWTRIG13: u32,
        SWTRIG14: u32,
        SWTRIG15: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWTRIG0: u32 = unsafe { ::core::mem::transmute(SWTRIG0) };
            SWTRIG0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SWTRIG1: u32 = unsafe { ::core::mem::transmute(SWTRIG1) };
            SWTRIG1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SWTRIG2: u32 = unsafe { ::core::mem::transmute(SWTRIG2) };
            SWTRIG2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SWTRIG3: u32 = unsafe { ::core::mem::transmute(SWTRIG3) };
            SWTRIG3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SWTRIG4: u32 = unsafe { ::core::mem::transmute(SWTRIG4) };
            SWTRIG4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SWTRIG5: u32 = unsafe { ::core::mem::transmute(SWTRIG5) };
            SWTRIG5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SWTRIG6: u32 = unsafe { ::core::mem::transmute(SWTRIG6) };
            SWTRIG6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SWTRIG7: u32 = unsafe { ::core::mem::transmute(SWTRIG7) };
            SWTRIG7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SWTRIG8: u32 = unsafe { ::core::mem::transmute(SWTRIG8) };
            SWTRIG8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SWTRIG9: u32 = unsafe { ::core::mem::transmute(SWTRIG9) };
            SWTRIG9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let SWTRIG10: u32 = unsafe { ::core::mem::transmute(SWTRIG10) };
            SWTRIG10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let SWTRIG11: u32 = unsafe { ::core::mem::transmute(SWTRIG11) };
            SWTRIG11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let SWTRIG12: u32 = unsafe { ::core::mem::transmute(SWTRIG12) };
            SWTRIG12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let SWTRIG13: u32 = unsafe { ::core::mem::transmute(SWTRIG13) };
            SWTRIG13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let SWTRIG14: u32 = unsafe { ::core::mem::transmute(SWTRIG14) };
            SWTRIG14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let SWTRIG15: u32 = unsafe { ::core::mem::transmute(SWTRIG15) };
            SWTRIG15 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_SWTRIGCTRL_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_SWTRIGCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_SWTRIGCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_SWTRIGCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_SWTRIGCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_SWTRIGCTRL_Type__bindgen_ty_2)
        )
    );
}
impl DMAC_SWTRIGCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn SWTRIG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_SWTRIG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWTRIG: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let SWTRIG: u32 = unsafe { ::core::mem::transmute(SWTRIG) };
            SWTRIG as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_SWTRIGCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_SWTRIGCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_SWTRIGCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_SWTRIGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_SWTRIGCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_SWTRIGCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_SWTRIGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_SWTRIGCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_SWTRIGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_PRICTRL0_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_PRICTRL0_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_PRICTRL0_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_PRICTRL0_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_PRICTRL0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_PRICTRL0_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_PRICTRL0_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_PRICTRL0_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_PRICTRL0_Type__bindgen_ty_1 {
    #[inline]
    pub fn LVLPRI0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LVLPRI0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn RRLVLEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RRLVLEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLPRI1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LVLPRI1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn RRLVLEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RRLVLEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLPRI2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LVLPRI2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn RRLVLEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RRLVLEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLPRI3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LVLPRI3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn RRLVLEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RRLVLEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LVLPRI0: u32,
        RRLVLEN0: u32,
        LVLPRI1: u32,
        RRLVLEN1: u32,
        LVLPRI2: u32,
        RRLVLEN2: u32,
        LVLPRI3: u32,
        RRLVLEN3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let LVLPRI0: u32 = unsafe { ::core::mem::transmute(LVLPRI0) };
            LVLPRI0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RRLVLEN0: u32 = unsafe { ::core::mem::transmute(RRLVLEN0) };
            RRLVLEN0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let LVLPRI1: u32 = unsafe { ::core::mem::transmute(LVLPRI1) };
            LVLPRI1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let RRLVLEN1: u32 = unsafe { ::core::mem::transmute(RRLVLEN1) };
            RRLVLEN1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let LVLPRI2: u32 = unsafe { ::core::mem::transmute(LVLPRI2) };
            LVLPRI2 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let RRLVLEN2: u32 = unsafe { ::core::mem::transmute(RRLVLEN2) };
            RRLVLEN2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let LVLPRI3: u32 = unsafe { ::core::mem::transmute(LVLPRI3) };
            LVLPRI3 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let RRLVLEN3: u32 = unsafe { ::core::mem::transmute(RRLVLEN3) };
            RRLVLEN3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_PRICTRL0_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_PRICTRL0_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_PRICTRL0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_PRICTRL0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_PRICTRL0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_PRICTRL0_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_PRICTRL0_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_PRICTRL0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_INTPEND_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_INTPEND_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_INTPEND_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_INTPEND_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_INTPEND_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_INTPEND_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_INTPEND_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_INTPEND_Type__bindgen_ty_1))
    );
}
impl DMAC_INTPEND_Type__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn TERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCMPL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TCMPL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SUSP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SUSP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_FERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BUSY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PEND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ID: u16,
        TERR: u16,
        TCMPL: u16,
        SUSP: u16,
        FERR: u16,
        BUSY: u16,
        PEND: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ID: u16 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let TERR: u16 = unsafe { ::core::mem::transmute(TERR) };
            TERR as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TCMPL: u16 = unsafe { ::core::mem::transmute(TCMPL) };
            TCMPL as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let SUSP: u16 = unsafe { ::core::mem::transmute(SUSP) };
            SUSP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FERR: u16 = unsafe { ::core::mem::transmute(FERR) };
            FERR as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let BUSY: u16 = unsafe { ::core::mem::transmute(BUSY) };
            BUSY as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PEND: u16 = unsafe { ::core::mem::transmute(PEND) };
            PEND as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_INTPEND_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_INTPEND_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_INTPEND_Type>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_INTPEND_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_INTPEND_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_INTPEND_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_INTPEND_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_INTPEND_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_INTSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_INTSTATUS_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DMAC_INTSTATUS_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_INTSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_INTSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_INTSTATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_INTSTATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_INTSTATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_INTSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_INTSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn CHINT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHINT15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CHINT0: u32,
        CHINT1: u32,
        CHINT2: u32,
        CHINT3: u32,
        CHINT4: u32,
        CHINT5: u32,
        CHINT6: u32,
        CHINT7: u32,
        CHINT8: u32,
        CHINT9: u32,
        CHINT10: u32,
        CHINT11: u32,
        CHINT12: u32,
        CHINT13: u32,
        CHINT14: u32,
        CHINT15: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CHINT0: u32 = unsafe { ::core::mem::transmute(CHINT0) };
            CHINT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CHINT1: u32 = unsafe { ::core::mem::transmute(CHINT1) };
            CHINT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CHINT2: u32 = unsafe { ::core::mem::transmute(CHINT2) };
            CHINT2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CHINT3: u32 = unsafe { ::core::mem::transmute(CHINT3) };
            CHINT3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CHINT4: u32 = unsafe { ::core::mem::transmute(CHINT4) };
            CHINT4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CHINT5: u32 = unsafe { ::core::mem::transmute(CHINT5) };
            CHINT5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let CHINT6: u32 = unsafe { ::core::mem::transmute(CHINT6) };
            CHINT6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CHINT7: u32 = unsafe { ::core::mem::transmute(CHINT7) };
            CHINT7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CHINT8: u32 = unsafe { ::core::mem::transmute(CHINT8) };
            CHINT8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CHINT9: u32 = unsafe { ::core::mem::transmute(CHINT9) };
            CHINT9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CHINT10: u32 = unsafe { ::core::mem::transmute(CHINT10) };
            CHINT10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let CHINT11: u32 = unsafe { ::core::mem::transmute(CHINT11) };
            CHINT11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let CHINT12: u32 = unsafe { ::core::mem::transmute(CHINT12) };
            CHINT12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let CHINT13: u32 = unsafe { ::core::mem::transmute(CHINT13) };
            CHINT13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CHINT14: u32 = unsafe { ::core::mem::transmute(CHINT14) };
            CHINT14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let CHINT15: u32 = unsafe { ::core::mem::transmute(CHINT15) };
            CHINT15 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_INTSTATUS_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_INTSTATUS_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_INTSTATUS_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_INTSTATUS_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_INTSTATUS_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_INTSTATUS_Type__bindgen_ty_2)
        )
    );
}
impl DMAC_INTSTATUS_Type__bindgen_ty_2 {
    #[inline]
    pub fn CHINT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_CHINT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CHINT: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let CHINT: u32 = unsafe { ::core::mem::transmute(CHINT) };
            CHINT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_INTSTATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_INTSTATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_INTSTATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_INTSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_INTSTATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_INTSTATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_INTSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_INTSTATUS_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_INTSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_BUSYCH_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_BUSYCH_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DMAC_BUSYCH_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_BUSYCH_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_BUSYCH_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BUSYCH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_BUSYCH_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BUSYCH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_BUSYCH_Type__bindgen_ty_1))
    );
}
impl DMAC_BUSYCH_Type__bindgen_ty_1 {
    #[inline]
    pub fn BUSYCH0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSYCH15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BUSYCH0: u32,
        BUSYCH1: u32,
        BUSYCH2: u32,
        BUSYCH3: u32,
        BUSYCH4: u32,
        BUSYCH5: u32,
        BUSYCH6: u32,
        BUSYCH7: u32,
        BUSYCH8: u32,
        BUSYCH9: u32,
        BUSYCH10: u32,
        BUSYCH11: u32,
        BUSYCH12: u32,
        BUSYCH13: u32,
        BUSYCH14: u32,
        BUSYCH15: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BUSYCH0: u32 = unsafe { ::core::mem::transmute(BUSYCH0) };
            BUSYCH0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BUSYCH1: u32 = unsafe { ::core::mem::transmute(BUSYCH1) };
            BUSYCH1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BUSYCH2: u32 = unsafe { ::core::mem::transmute(BUSYCH2) };
            BUSYCH2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let BUSYCH3: u32 = unsafe { ::core::mem::transmute(BUSYCH3) };
            BUSYCH3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let BUSYCH4: u32 = unsafe { ::core::mem::transmute(BUSYCH4) };
            BUSYCH4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let BUSYCH5: u32 = unsafe { ::core::mem::transmute(BUSYCH5) };
            BUSYCH5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BUSYCH6: u32 = unsafe { ::core::mem::transmute(BUSYCH6) };
            BUSYCH6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BUSYCH7: u32 = unsafe { ::core::mem::transmute(BUSYCH7) };
            BUSYCH7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let BUSYCH8: u32 = unsafe { ::core::mem::transmute(BUSYCH8) };
            BUSYCH8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let BUSYCH9: u32 = unsafe { ::core::mem::transmute(BUSYCH9) };
            BUSYCH9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let BUSYCH10: u32 = unsafe { ::core::mem::transmute(BUSYCH10) };
            BUSYCH10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let BUSYCH11: u32 = unsafe { ::core::mem::transmute(BUSYCH11) };
            BUSYCH11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let BUSYCH12: u32 = unsafe { ::core::mem::transmute(BUSYCH12) };
            BUSYCH12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let BUSYCH13: u32 = unsafe { ::core::mem::transmute(BUSYCH13) };
            BUSYCH13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let BUSYCH14: u32 = unsafe { ::core::mem::transmute(BUSYCH14) };
            BUSYCH14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let BUSYCH15: u32 = unsafe { ::core::mem::transmute(BUSYCH15) };
            BUSYCH15 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_BUSYCH_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_BUSYCH_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BUSYCH_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_BUSYCH_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BUSYCH_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_BUSYCH_Type__bindgen_ty_2))
    );
}
impl DMAC_BUSYCH_Type__bindgen_ty_2 {
    #[inline]
    pub fn BUSYCH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_BUSYCH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BUSYCH: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let BUSYCH: u32 = unsafe { ::core::mem::transmute(BUSYCH) };
            BUSYCH as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_BUSYCH_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_BUSYCH_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_BUSYCH_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_BUSYCH_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BUSYCH_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_BUSYCH_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BUSYCH_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BUSYCH_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BUSYCH_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_PENDCH_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_PENDCH_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DMAC_PENDCH_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_PENDCH_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_PENDCH_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_PENDCH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_PENDCH_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_PENDCH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_PENDCH_Type__bindgen_ty_1))
    );
}
impl DMAC_PENDCH_Type__bindgen_ty_1 {
    #[inline]
    pub fn PENDCH0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH8(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH8(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH9(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH9(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH10(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH10(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH11(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH11(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH12(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH12(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH13(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH13(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH14(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH14(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PENDCH15(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH15(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PENDCH0: u32,
        PENDCH1: u32,
        PENDCH2: u32,
        PENDCH3: u32,
        PENDCH4: u32,
        PENDCH5: u32,
        PENDCH6: u32,
        PENDCH7: u32,
        PENDCH8: u32,
        PENDCH9: u32,
        PENDCH10: u32,
        PENDCH11: u32,
        PENDCH12: u32,
        PENDCH13: u32,
        PENDCH14: u32,
        PENDCH15: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PENDCH0: u32 = unsafe { ::core::mem::transmute(PENDCH0) };
            PENDCH0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PENDCH1: u32 = unsafe { ::core::mem::transmute(PENDCH1) };
            PENDCH1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PENDCH2: u32 = unsafe { ::core::mem::transmute(PENDCH2) };
            PENDCH2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PENDCH3: u32 = unsafe { ::core::mem::transmute(PENDCH3) };
            PENDCH3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PENDCH4: u32 = unsafe { ::core::mem::transmute(PENDCH4) };
            PENDCH4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PENDCH5: u32 = unsafe { ::core::mem::transmute(PENDCH5) };
            PENDCH5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PENDCH6: u32 = unsafe { ::core::mem::transmute(PENDCH6) };
            PENDCH6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PENDCH7: u32 = unsafe { ::core::mem::transmute(PENDCH7) };
            PENDCH7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let PENDCH8: u32 = unsafe { ::core::mem::transmute(PENDCH8) };
            PENDCH8 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let PENDCH9: u32 = unsafe { ::core::mem::transmute(PENDCH9) };
            PENDCH9 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PENDCH10: u32 = unsafe { ::core::mem::transmute(PENDCH10) };
            PENDCH10 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PENDCH11: u32 = unsafe { ::core::mem::transmute(PENDCH11) };
            PENDCH11 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PENDCH12: u32 = unsafe { ::core::mem::transmute(PENDCH12) };
            PENDCH12 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PENDCH13: u32 = unsafe { ::core::mem::transmute(PENDCH13) };
            PENDCH13 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let PENDCH14: u32 = unsafe { ::core::mem::transmute(PENDCH14) };
            PENDCH14 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PENDCH15: u32 = unsafe { ::core::mem::transmute(PENDCH15) };
            PENDCH15 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_PENDCH_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_PENDCH_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_PENDCH_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_PENDCH_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_PENDCH_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_PENDCH_Type__bindgen_ty_2))
    );
}
impl DMAC_PENDCH_Type__bindgen_ty_2 {
    #[inline]
    pub fn PENDCH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_PENDCH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PENDCH: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let PENDCH: u32 = unsafe { ::core::mem::transmute(PENDCH) };
            PENDCH as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_PENDCH_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_PENDCH_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_PENDCH_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_PENDCH_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_PENDCH_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_PENDCH_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_PENDCH_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_PENDCH_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_PENDCH_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_ACTIVE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_ACTIVE_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DMAC_ACTIVE_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_ACTIVE_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_ACTIVE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_ACTIVE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_ACTIVE_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_ACTIVE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_ACTIVE_Type__bindgen_ty_1))
    );
}
impl DMAC_ACTIVE_Type__bindgen_ty_1 {
    #[inline]
    pub fn LVLEX0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LVLEX0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEX1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LVLEX1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEX2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LVLEX2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVLEX3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LVLEX3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ID(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn ABUSY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ABUSY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BTCNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_BTCNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LVLEX0: u32,
        LVLEX1: u32,
        LVLEX2: u32,
        LVLEX3: u32,
        ID: u32,
        ABUSY: u32,
        BTCNT: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LVLEX0: u32 = unsafe { ::core::mem::transmute(LVLEX0) };
            LVLEX0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LVLEX1: u32 = unsafe { ::core::mem::transmute(LVLEX1) };
            LVLEX1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LVLEX2: u32 = unsafe { ::core::mem::transmute(LVLEX2) };
            LVLEX2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let LVLEX3: u32 = unsafe { ::core::mem::transmute(LVLEX3) };
            LVLEX3 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let ID: u32 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ABUSY: u32 = unsafe { ::core::mem::transmute(ABUSY) };
            ABUSY as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let BTCNT: u32 = unsafe { ::core::mem::transmute(BTCNT) };
            BTCNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_ACTIVE_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_ACTIVE_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_ACTIVE_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_ACTIVE_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_ACTIVE_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_ACTIVE_Type__bindgen_ty_2))
    );
}
impl DMAC_ACTIVE_Type__bindgen_ty_2 {
    #[inline]
    pub fn LVLEX(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LVLEX(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LVLEX: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let LVLEX: u32 = unsafe { ::core::mem::transmute(LVLEX) };
            LVLEX as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_ACTIVE_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_ACTIVE_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_ACTIVE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_ACTIVE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_ACTIVE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_ACTIVE_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_ACTIVE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_ACTIVE_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_ACTIVE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_BASEADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_BASEADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_BASEADDR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_BASEADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BASEADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_BASEADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BASEADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_BASEADDR_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_BASEADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn BASEADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_BASEADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BASEADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let BASEADDR: u32 = unsafe { ::core::mem::transmute(BASEADDR) };
            BASEADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_BASEADDR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_BASEADDR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_BASEADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_BASEADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BASEADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_BASEADDR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BASEADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BASEADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_WRBADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_WRBADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_WRBADDR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_WRBADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_WRBADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_WRBADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_WRBADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_WRBADDR_Type__bindgen_ty_1))
    );
}
impl DMAC_WRBADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn WRBADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_WRBADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WRBADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let WRBADDR: u32 = unsafe { ::core::mem::transmute(WRBADDR) };
            WRBADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_WRBADDR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_WRBADDR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_WRBADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_WRBADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_WRBADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_WRBADDR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_WRBADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_WRBADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHID_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHID_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHID_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CHID_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHID_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHID_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHID_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHID_Type__bindgen_ty_1))
    );
}
impl DMAC_CHID_Type__bindgen_ty_1 {
    #[inline]
    pub fn ID(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ID(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ID: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let ID: u8 = unsafe { ::core::mem::transmute(ID) };
            ID as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHID_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_CHID_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHID_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHID_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHID_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHID_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHID_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHID_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHCTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHCTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHCTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CHCTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHCTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHCTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHCTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHCTRLA_Type__bindgen_ty_1))
    );
}
impl DMAC_CHCTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u8,
        ENABLE: u8,
        RUNSTDBY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u8 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHCTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_CHCTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHCTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHCTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHCTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHCTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHCTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHCTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHCTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHCTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHCTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CHCTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHCTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_CHCTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHCTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_CHCTRLB_Type__bindgen_ty_1))
    );
}
impl DMAC_CHCTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn EVACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_EVACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn EVIE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVIE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVOE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVOE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LVL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_LVL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TRIGSRC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_TRIGSRC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn TRIGACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TRIGACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EVACT: u32,
        EVIE: u32,
        EVOE: u32,
        LVL: u32,
        TRIGSRC: u32,
        TRIGACT: u32,
        CMD: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let EVACT: u32 = unsafe { ::core::mem::transmute(EVACT) };
            EVACT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EVIE: u32 = unsafe { ::core::mem::transmute(EVIE) };
            EVIE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EVOE: u32 = unsafe { ::core::mem::transmute(EVOE) };
            EVOE as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let LVL: u32 = unsafe { ::core::mem::transmute(LVL) };
            LVL as u64
        });
        __bindgen_bitfield_unit.set(8usize, 6u8, {
            let TRIGSRC: u32 = unsafe { ::core::mem::transmute(TRIGSRC) };
            TRIGSRC as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let TRIGACT: u32 = unsafe { ::core::mem::transmute(TRIGACT) };
            TRIGACT as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let CMD: u32 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHCTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_CHCTRLB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHCTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_CHCTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHCTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_CHCTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHCTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHCTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHINTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHINTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHINTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CHINTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHINTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHINTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHINTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CHINTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CHINTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn TERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCMPL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TCMPL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SUSP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SUSP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(TERR: u8, TCMPL: u8, SUSP: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TERR: u8 = unsafe { ::core::mem::transmute(TERR) };
            TERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TCMPL: u8 = unsafe { ::core::mem::transmute(TCMPL) };
            TCMPL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SUSP: u8 = unsafe { ::core::mem::transmute(SUSP) };
            SUSP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHINTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_CHINTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHINTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHINTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHINTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHINTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHINTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHINTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHINTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHINTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHINTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CHINTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHINTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHINTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHINTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CHINTENSET_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CHINTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn TERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCMPL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TCMPL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SUSP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SUSP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(TERR: u8, TCMPL: u8, SUSP: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TERR: u8 = unsafe { ::core::mem::transmute(TERR) };
            TERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TCMPL: u8 = unsafe { ::core::mem::transmute(TCMPL) };
            TCMPL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SUSP: u8 = unsafe { ::core::mem::transmute(SUSP) };
            SUSP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHINTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_CHINTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHINTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHINTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHINTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHINTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHINTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHINTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHINTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHINTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHINTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CHINTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHINTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHINTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHINTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CHINTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CHINTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn TERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCMPL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TCMPL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SUSP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SUSP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(TERR: u8, TCMPL: u8, SUSP: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TERR: u8 = unsafe { ::core::mem::transmute(TERR) };
            TERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TCMPL: u8 = unsafe { ::core::mem::transmute(TCMPL) };
            TCMPL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SUSP: u8 = unsafe { ::core::mem::transmute(SUSP) };
            SUSP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHINTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_CHINTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHINTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHINTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHINTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHINTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHINTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHINTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_CHSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_CHSTATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_CHSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_CHSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHSTATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_CHSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_CHSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn PEND(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PEND(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PEND: u8, BUSY: u8, FERR: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PEND: u8 = unsafe { ::core::mem::transmute(PEND) };
            PEND as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BUSY: u8 = unsafe { ::core::mem::transmute(BUSY) };
            BUSY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FERR: u8 = unsafe { ::core::mem::transmute(FERR) };
            FERR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_CHSTATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_CHSTATUS_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_CHSTATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DMAC_CHSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_CHSTATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DMAC_CHSTATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_CHSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_BTCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_BTCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_BTCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_BTCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BTCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_BTCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BTCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_BTCTRL_Type__bindgen_ty_1))
    );
}
impl DMAC_BTCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn VALID(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_VALID(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVOSEL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_EVOSEL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn BLOCKACT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_BLOCKACT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn BEATSIZE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_BEATSIZE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SRCINC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SRCINC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DSTINC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DSTINC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STEPSEL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_STEPSEL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STEPSIZE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_STEPSIZE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VALID: u16,
        EVOSEL: u16,
        BLOCKACT: u16,
        BEATSIZE: u16,
        SRCINC: u16,
        DSTINC: u16,
        STEPSEL: u16,
        STEPSIZE: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VALID: u16 = unsafe { ::core::mem::transmute(VALID) };
            VALID as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let EVOSEL: u16 = unsafe { ::core::mem::transmute(EVOSEL) };
            EVOSEL as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let BLOCKACT: u16 = unsafe { ::core::mem::transmute(BLOCKACT) };
            BLOCKACT as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let BEATSIZE: u16 = unsafe { ::core::mem::transmute(BEATSIZE) };
            BEATSIZE as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let SRCINC: u16 = unsafe { ::core::mem::transmute(SRCINC) };
            SRCINC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DSTINC: u16 = unsafe { ::core::mem::transmute(DSTINC) };
            DSTINC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let STEPSEL: u16 = unsafe { ::core::mem::transmute(STEPSEL) };
            STEPSEL as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let STEPSIZE: u16 = unsafe { ::core::mem::transmute(STEPSIZE) };
            STEPSIZE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_BTCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_BTCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_BTCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_BTCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BTCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_BTCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BTCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BTCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_BTCNT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_BTCNT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_BTCNT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_BTCNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_BTCNT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_BTCNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BTCNT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_BTCNT_Type__bindgen_ty_1))
    );
}
impl DMAC_BTCNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn BTCNT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_BTCNT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BTCNT: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let BTCNT: u16 = unsafe { ::core::mem::transmute(BTCNT) };
            BTCNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_BTCNT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_BTCNT_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_BTCNT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(DMAC_BTCNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_BTCNT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(DMAC_BTCNT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BTCNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_BTCNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_SRCADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_SRCADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_SRCADDR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_SRCADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_SRCADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_SRCADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_SRCADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_SRCADDR_Type__bindgen_ty_1))
    );
}
impl DMAC_SRCADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn SRCADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SRCADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SRCADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SRCADDR: u32 = unsafe { ::core::mem::transmute(SRCADDR) };
            SRCADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_SRCADDR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_SRCADDR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_SRCADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_SRCADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_SRCADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_SRCADDR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_SRCADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_SRCADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_DSTADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_DSTADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_DSTADDR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_DSTADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_DSTADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_DSTADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_DSTADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_DSTADDR_Type__bindgen_ty_1))
    );
}
impl DMAC_DSTADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DSTADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DSTADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DSTADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DSTADDR: u32 = unsafe { ::core::mem::transmute(DSTADDR) };
            DSTADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_DSTADDR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_DSTADDR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_DSTADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_DSTADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_DSTADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_DSTADDR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_DSTADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_DSTADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DMAC_DESCADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DMAC_DESCADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DMAC_DESCADDR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DMAC_DESCADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DMAC_DESCADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_DESCADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_DESCADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(DMAC_DESCADDR_Type__bindgen_ty_1)
        )
    );
}
impl DMAC_DESCADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DESCADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DESCADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DESCADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DESCADDR: u32 = unsafe { ::core::mem::transmute(DESCADDR) };
            DESCADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DMAC_DESCADDR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DMAC_DESCADDR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DMAC_DESCADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DMAC_DESCADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DMAC_DESCADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DMAC_DESCADDR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_DESCADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DMAC_DESCADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Dmac {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) Control"]
    pub CTRL: DMAC_CTRL_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) CRC Control"]
    pub CRCCTRL: DMAC_CRCCTRL_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) CRC Data Input"]
    pub CRCDATAIN: DMAC_CRCDATAIN_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) CRC Checksum"]
    pub CRCCHKSUM: DMAC_CRCCHKSUM_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) CRC Status"]
    pub CRCSTATUS: DMAC_CRCSTATUS_Type,
    #[doc = "< \\brief Offset: 0x0D (R/W  8) Debug Control"]
    pub DBGCTRL: DMAC_DBGCTRL_Type,
    #[doc = "< \\brief Offset: 0x0E (R/W  8) QOS Control"]
    pub QOSCTRL: DMAC_QOSCTRL_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Software Trigger Control"]
    pub SWTRIGCTRL: DMAC_SWTRIGCTRL_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) Priority Control 0"]
    pub PRICTRL0: DMAC_PRICTRL0_Type,
    pub Reserved2: [RoReg8; 8usize],
    #[doc = "< \\brief Offset: 0x20 (R/W 16) Interrupt Pending"]
    pub INTPEND: DMAC_INTPEND_Type,
    pub Reserved3: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x24 (R/  32) Interrupt Status"]
    pub INTSTATUS: DMAC_INTSTATUS_Type,
    #[doc = "< \\brief Offset: 0x28 (R/  32) Busy Channels"]
    pub BUSYCH: DMAC_BUSYCH_Type,
    #[doc = "< \\brief Offset: 0x2C (R/  32) Pending Channels"]
    pub PENDCH: DMAC_PENDCH_Type,
    #[doc = "< \\brief Offset: 0x30 (R/  32) Active Channel and Levels"]
    pub ACTIVE: DMAC_ACTIVE_Type,
    #[doc = "< \\brief Offset: 0x34 (R/W 32) Descriptor Memory Section Base Address"]
    pub BASEADDR: DMAC_BASEADDR_Type,
    #[doc = "< \\brief Offset: 0x38 (R/W 32) Write-Back Memory Section Base Address"]
    pub WRBADDR: DMAC_WRBADDR_Type,
    pub Reserved4: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x3F (R/W  8) Channel ID"]
    pub CHID: DMAC_CHID_Type,
    #[doc = "< \\brief Offset: 0x40 (R/W  8) Channel Control A"]
    pub CHCTRLA: DMAC_CHCTRLA_Type,
    pub Reserved5: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x44 (R/W 32) Channel Control B"]
    pub CHCTRLB: DMAC_CHCTRLB_Type,
    pub Reserved6: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x4C (R/W  8) Channel Interrupt Enable Clear"]
    pub CHINTENCLR: DMAC_CHINTENCLR_Type,
    #[doc = "< \\brief Offset: 0x4D (R/W  8) Channel Interrupt Enable Set"]
    pub CHINTENSET: DMAC_CHINTENSET_Type,
    #[doc = "< \\brief Offset: 0x4E (R/W  8) Channel Interrupt Flag Status and Clear"]
    pub CHINTFLAG: DMAC_CHINTFLAG_Type,
    #[doc = "< \\brief Offset: 0x4F (R/   8) Channel Status"]
    pub CHSTATUS: DMAC_CHSTATUS_Type,
}
#[test]
fn bindgen_test_layout_Dmac() {
    const UNINIT: ::core::mem::MaybeUninit<Dmac> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Dmac>(),
        80usize,
        concat!("Size of: ", stringify!(Dmac))
    );
    assert_eq!(
        ::core::mem::align_of::<Dmac>(),
        4usize,
        concat!("Alignment of ", stringify!(Dmac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCCTRL) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CRCCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCDATAIN) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CRCDATAIN)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCCHKSUM) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CRCCHKSUM)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CRCSTATUS) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CRCSTATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QOSCTRL) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(QOSCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SWTRIGCTRL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(SWTRIGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PRICTRL0) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(PRICTRL0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTPEND) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(INTPEND)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTSTATUS) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(INTSTATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BUSYCH) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(BUSYCH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PENDCH) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(PENDCH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ACTIVE) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(ACTIVE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BASEADDR) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(BASEADDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WRBADDR) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(WRBADDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CHID) as usize - ptr as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CHCTRLA) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHCTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CHCTRLB) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHCTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CHINTENCLR) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHINTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CHINTENSET) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHINTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CHINTFLAG) as usize - ptr as usize },
        78usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHINTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CHSTATUS) as usize - ptr as usize },
        79usize,
        concat!(
            "Offset of field: ",
            stringify!(Dmac),
            "::",
            stringify!(CHSTATUS)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DmacDescriptor {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) Block Transfer Control"]
    pub BTCTRL: DMAC_BTCTRL_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) Block Transfer Count"]
    pub BTCNT: DMAC_BTCNT_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Block Transfer Source Address"]
    pub SRCADDR: DMAC_SRCADDR_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) Block Transfer Destination Address"]
    pub DSTADDR: DMAC_DSTADDR_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W 32) Next Descriptor Address"]
    pub DESCADDR: DMAC_DESCADDR_Type,
}
#[test]
fn bindgen_test_layout_DmacDescriptor() {
    const UNINIT: ::core::mem::MaybeUninit<DmacDescriptor> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DmacDescriptor>(),
        16usize,
        concat!("Size of: ", stringify!(DmacDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<DmacDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(DmacDescriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BTCTRL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DmacDescriptor),
            "::",
            stringify!(BTCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BTCNT) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DmacDescriptor),
            "::",
            stringify!(BTCNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SRCADDR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DmacDescriptor),
            "::",
            stringify!(SRCADDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DSTADDR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DmacDescriptor),
            "::",
            stringify!(DSTADDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DESCADDR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DmacDescriptor),
            "::",
            stringify!(DESCADDR)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_CTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DSU_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DSU_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_CTRL_Type__bindgen_ty_1))
    );
}
impl DSU_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CRC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CRC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MBIST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MBIST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ARR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ARR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SMSA(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SMSA(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u8,
        CRC: u8,
        MBIST: u8,
        CE: u8,
        ARR: u8,
        SMSA: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CRC: u8 = unsafe { ::core::mem::transmute(CRC) };
            CRC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let MBIST: u8 = unsafe { ::core::mem::transmute(MBIST) };
            MBIST as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CE: u8 = unsafe { ::core::mem::transmute(CE) };
            CE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let ARR: u8 = unsafe { ::core::mem::transmute(ARR) };
            ARR as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SMSA: u8 = unsafe { ::core::mem::transmute(SMSA) };
            SMSA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_CTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_CTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_CTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_CTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_STATUSA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_STATUSA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DSU_STATUSA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DSU_STATUSA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_STATUSA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_STATUSA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_STATUSA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_STATUSA_Type__bindgen_ty_1))
    );
}
impl DSU_STATUSA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DONE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DONE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CRSTEXT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CRSTEXT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAIL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FAIL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DONE: u8,
        CRSTEXT: u8,
        BERR: u8,
        FAIL: u8,
        PERR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DONE: u8 = unsafe { ::core::mem::transmute(DONE) };
            DONE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CRSTEXT: u8 = unsafe { ::core::mem::transmute(CRSTEXT) };
            CRSTEXT as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BERR: u8 = unsafe { ::core::mem::transmute(BERR) };
            BERR as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let FAIL: u8 = unsafe { ::core::mem::transmute(FAIL) };
            FAIL as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PERR: u8 = unsafe { ::core::mem::transmute(PERR) };
            PERR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_STATUSA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_STATUSA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_STATUSA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_STATUSA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_STATUSA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_STATUSA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_STATUSA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_STATUSA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_STATUSB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_STATUSB_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: DSU_STATUSB_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DSU_STATUSB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DSU_STATUSB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_STATUSB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_STATUSB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_STATUSB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_STATUSB_Type__bindgen_ty_1))
    );
}
impl DSU_STATUSB_Type__bindgen_ty_1 {
    #[inline]
    pub fn PROT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PROT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DBGPRES(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGPRES(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DCCD0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DCCD0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DCCD1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DCCD1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HPE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HPE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PROT: u8,
        DBGPRES: u8,
        DCCD0: u8,
        DCCD1: u8,
        HPE: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PROT: u8 = unsafe { ::core::mem::transmute(PROT) };
            PROT as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DBGPRES: u8 = unsafe { ::core::mem::transmute(DBGPRES) };
            DBGPRES as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DCCD0: u8 = unsafe { ::core::mem::transmute(DCCD0) };
            DCCD0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DCCD1: u8 = unsafe { ::core::mem::transmute(DCCD1) };
            DCCD1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HPE: u8 = unsafe { ::core::mem::transmute(HPE) };
            HPE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct DSU_STATUSB_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_DSU_STATUSB_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<DSU_STATUSB_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_STATUSB_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_STATUSB_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_STATUSB_Type__bindgen_ty_2))
    );
}
impl DSU_STATUSB_Type__bindgen_ty_2 {
    #[inline]
    pub fn DCCD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_DCCD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DCCD: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let DCCD: u8 = unsafe { ::core::mem::transmute(DCCD) };
            DCCD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_STATUSB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_STATUSB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_STATUSB_Type>(),
        1usize,
        concat!("Size of: ", stringify!(DSU_STATUSB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_STATUSB_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(DSU_STATUSB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_STATUSB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_STATUSB_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_STATUSB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_ADDR_Type__bindgen_ty_1))
    );
}
impl DSU_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn AMOD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_AMOD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(AMOD: u32, ADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let AMOD: u32 = unsafe { ::core::mem::transmute(AMOD) };
            AMOD as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_ADDR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_ADDR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_ADDR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_LENGTH_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_LENGTH_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_LENGTH_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_LENGTH_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_LENGTH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_LENGTH_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_LENGTH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_LENGTH_Type__bindgen_ty_1))
    );
}
impl DSU_LENGTH_Type__bindgen_ty_1 {
    #[inline]
    pub fn LENGTH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_LENGTH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LENGTH: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let LENGTH: u32 = unsafe { ::core::mem::transmute(LENGTH) };
            LENGTH as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_LENGTH_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_LENGTH_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_LENGTH_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_LENGTH_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_LENGTH_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_LENGTH_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_LENGTH_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_LENGTH_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_DATA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_DATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DATA_Type__bindgen_ty_1))
    );
}
impl DSU_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DATA: u32 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_DATA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_DATA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_DATA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DATA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DATA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_DCC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_DCC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_DCC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_DCC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_DCC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DCC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DCC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DCC_Type__bindgen_ty_1))
    );
}
impl DSU_DCC_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DATA: u32 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_DCC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_DCC_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_DCC_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DCC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DCC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DCC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DCC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DCC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_DID_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_DID_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_DID_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_DID_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_DID_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DID_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DID_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DID_Type__bindgen_ty_1))
    );
}
impl DSU_DID_Type__bindgen_ty_1 {
    #[inline]
    pub fn DEVSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_DEVSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn REVISION(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_REVISION(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn DIE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_DIE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn SERIES(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_SERIES(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn FAMILY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_FAMILY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn PROCESSOR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_PROCESSOR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DEVSEL: u32,
        REVISION: u32,
        DIE: u32,
        SERIES: u32,
        FAMILY: u32,
        PROCESSOR: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let DEVSEL: u32 = unsafe { ::core::mem::transmute(DEVSEL) };
            DEVSEL as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let REVISION: u32 = unsafe { ::core::mem::transmute(REVISION) };
            REVISION as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let DIE: u32 = unsafe { ::core::mem::transmute(DIE) };
            DIE as u64
        });
        __bindgen_bitfield_unit.set(16usize, 6u8, {
            let SERIES: u32 = unsafe { ::core::mem::transmute(SERIES) };
            SERIES as u64
        });
        __bindgen_bitfield_unit.set(23usize, 5u8, {
            let FAMILY: u32 = unsafe { ::core::mem::transmute(FAMILY) };
            FAMILY as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let PROCESSOR: u32 = unsafe { ::core::mem::transmute(PROCESSOR) };
            PROCESSOR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_DID_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_DID_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_DID_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DID_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DID_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DID_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DID_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DID_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_DCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_DCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_DCFG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_DCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_DCFG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DCFG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DCFG_Type__bindgen_ty_1))
    );
}
impl DSU_DCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn DCFG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DCFG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DCFG: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DCFG: u32 = unsafe { ::core::mem::transmute(DCFG) };
            DCFG as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_DCFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_DCFG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_DCFG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_DCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_DCFG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_DCFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_DCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_ENTRY0_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_ENTRY0_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_ENTRY0_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_ENTRY0_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_ENTRY0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_ENTRY0_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_ENTRY0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_ENTRY0_Type__bindgen_ty_1))
    );
}
impl DSU_ENTRY0_Type__bindgen_ty_1 {
    #[inline]
    pub fn EPRES(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EPRES(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FMT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FMT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADDOFF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_ADDOFF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EPRES: u32,
        FMT: u32,
        ADDOFF: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EPRES: u32 = unsafe { ::core::mem::transmute(EPRES) };
            EPRES as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FMT: u32 = unsafe { ::core::mem::transmute(FMT) };
            FMT as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let ADDOFF: u32 = unsafe { ::core::mem::transmute(ADDOFF) };
            ADDOFF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_ENTRY0_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_ENTRY0_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_ENTRY0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_ENTRY0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_ENTRY0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_ENTRY0_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_ENTRY0_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_ENTRY0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_ENTRY1_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_DSU_ENTRY1_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_ENTRY1_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_ENTRY1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_ENTRY1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_ENTRY1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_ENTRY1_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_ENTRY1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_END_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_END_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_END_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_END_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_END_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_END_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_END_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_END_Type__bindgen_ty_1))
    );
}
impl DSU_END_Type__bindgen_ty_1 {
    #[inline]
    pub fn END(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_END(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(END: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let END: u32 = unsafe { ::core::mem::transmute(END) };
            END as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_END_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_END_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_END_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_END_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_END_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_END_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_END_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_END_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_MEMTYPE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_MEMTYPE_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_MEMTYPE_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_MEMTYPE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_MEMTYPE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_MEMTYPE_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_MEMTYPE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_MEMTYPE_Type__bindgen_ty_1))
    );
}
impl DSU_MEMTYPE_Type__bindgen_ty_1 {
    #[inline]
    pub fn SMEMP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SMEMP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SMEMP: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SMEMP: u32 = unsafe { ::core::mem::transmute(SMEMP) };
            SMEMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_MEMTYPE_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_MEMTYPE_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_MEMTYPE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_MEMTYPE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_MEMTYPE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_MEMTYPE_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_MEMTYPE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_MEMTYPE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID4_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_PID4_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_PID4_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_PID4_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID4_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID4_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID4_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID4_Type__bindgen_ty_1))
    );
}
impl DSU_PID4_Type__bindgen_ty_1 {
    #[inline]
    pub fn JEPCC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_JEPCC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn FKBC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FKBC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(JEPCC: u32, FKBC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let JEPCC: u32 = unsafe { ::core::mem::transmute(JEPCC) };
            JEPCC as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let FKBC: u32 = unsafe { ::core::mem::transmute(FKBC) };
            FKBC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_PID4_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_PID4_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_PID4_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID4_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID4_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID4_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID4_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID4_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID5_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_DSU_PID5_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_PID5_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_PID5_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID5_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID5_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID5_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID5_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID6_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_DSU_PID6_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_PID6_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_PID6_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID6_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID6_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID6_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID6_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID7_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_DSU_PID7_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_PID7_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_PID7_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID7_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID7_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID7_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID7_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID0_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_PID0_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_PID0_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_PID0_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID0_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID0_Type__bindgen_ty_1))
    );
}
impl DSU_PID0_Type__bindgen_ty_1 {
    #[inline]
    pub fn PARTNBL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PARTNBL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PARTNBL: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PARTNBL: u32 = unsafe { ::core::mem::transmute(PARTNBL) };
            PARTNBL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_PID0_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_PID0_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_PID0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID0_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID0_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID1_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_PID1_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_PID1_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_PID1_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID1_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID1_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID1_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID1_Type__bindgen_ty_1))
    );
}
impl DSU_PID1_Type__bindgen_ty_1 {
    #[inline]
    pub fn PARTNBH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_PARTNBH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn JEPIDCL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_JEPIDCL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PARTNBH: u32, JEPIDCL: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let PARTNBH: u32 = unsafe { ::core::mem::transmute(PARTNBH) };
            PARTNBH as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let JEPIDCL: u32 = unsafe { ::core::mem::transmute(JEPIDCL) };
            JEPIDCL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_PID1_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_PID1_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_PID1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID1_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID1_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID2_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_PID2_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_PID2_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_PID2_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID2_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID2_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID2_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID2_Type__bindgen_ty_1))
    );
}
impl DSU_PID2_Type__bindgen_ty_1 {
    #[inline]
    pub fn JEPIDCH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_JEPIDCH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn JEPU(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_JEPU(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn REVISION(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_REVISION(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        JEPIDCH: u32,
        JEPU: u32,
        REVISION: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let JEPIDCH: u32 = unsafe { ::core::mem::transmute(JEPIDCH) };
            JEPIDCH as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let JEPU: u32 = unsafe { ::core::mem::transmute(JEPU) };
            JEPU as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let REVISION: u32 = unsafe { ::core::mem::transmute(REVISION) };
            REVISION as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_PID2_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_PID2_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_PID2_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID2_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID2_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID2_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID2_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_PID3_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_PID3_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_PID3_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_PID3_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_PID3_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID3_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID3_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID3_Type__bindgen_ty_1))
    );
}
impl DSU_PID3_Type__bindgen_ty_1 {
    #[inline]
    pub fn CUSMOD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CUSMOD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn REVAND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_REVAND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CUSMOD: u32, REVAND: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let CUSMOD: u32 = unsafe { ::core::mem::transmute(CUSMOD) };
            CUSMOD as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let REVAND: u32 = unsafe { ::core::mem::transmute(REVAND) };
            REVAND as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_PID3_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_PID3_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_PID3_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_PID3_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_PID3_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_PID3_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID3_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_PID3_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_CID0_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_CID0_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_CID0_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_CID0_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CID0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID0_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID0_Type__bindgen_ty_1))
    );
}
impl DSU_CID0_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREAMBLEB0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PREAMBLEB0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PREAMBLEB0: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PREAMBLEB0: u32 = unsafe { ::core::mem::transmute(PREAMBLEB0) };
            PREAMBLEB0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_CID0_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_CID0_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_CID0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID0_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID0_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_CID1_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_CID1_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_CID1_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_CID1_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CID1_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID1_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID1_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID1_Type__bindgen_ty_1))
    );
}
impl DSU_CID1_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREAMBLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_PREAMBLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CCLASS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CCLASS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PREAMBLE: u32, CCLASS: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let PREAMBLE: u32 = unsafe { ::core::mem::transmute(PREAMBLE) };
            PREAMBLE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let CCLASS: u32 = unsafe { ::core::mem::transmute(CCLASS) };
            CCLASS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_CID1_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_CID1_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_CID1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID1_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID1_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_CID2_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_CID2_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_CID2_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_CID2_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CID2_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID2_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID2_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID2_Type__bindgen_ty_1))
    );
}
impl DSU_CID2_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREAMBLEB2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PREAMBLEB2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PREAMBLEB2: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PREAMBLEB2: u32 = unsafe { ::core::mem::transmute(PREAMBLEB2) };
            PREAMBLEB2 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_CID2_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_CID2_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_CID2_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID2_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID2_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID2_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID2_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union DSU_CID3_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: DSU_CID3_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct DSU_CID3_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_DSU_CID3_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<DSU_CID3_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID3_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID3_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID3_Type__bindgen_ty_1))
    );
}
impl DSU_CID3_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREAMBLEB3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PREAMBLEB3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PREAMBLEB3: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PREAMBLEB3: u32 = unsafe { ::core::mem::transmute(PREAMBLEB3) };
            PREAMBLEB3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_DSU_CID3_Type() {
    const UNINIT: ::core::mem::MaybeUninit<DSU_CID3_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<DSU_CID3_Type>(),
        4usize,
        concat!("Size of: ", stringify!(DSU_CID3_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<DSU_CID3_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(DSU_CID3_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID3_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DSU_CID3_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Dsu {
    #[doc = "< \\brief Offset: 0x0000 ( /W  8) Control"]
    pub CTRL: DSU_CTRL_Type,
    #[doc = "< \\brief Offset: 0x0001 (R/W  8) Status A"]
    pub STATUSA: DSU_STATUSA_Type,
    #[doc = "< \\brief Offset: 0x0002 (R/   8) Status B"]
    pub STATUSB: DSU_STATUSB_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0004 (R/W 32) Address"]
    pub ADDR: DSU_ADDR_Type,
    #[doc = "< \\brief Offset: 0x0008 (R/W 32) Length"]
    pub LENGTH: DSU_LENGTH_Type,
    #[doc = "< \\brief Offset: 0x000C (R/W 32) Data"]
    pub DATA: DSU_DATA_Type,
    #[doc = "< \\brief Offset: 0x0010 (R/W 32) Debug Communication Channel n"]
    pub DCC: [DSU_DCC_Type; 2usize],
    #[doc = "< \\brief Offset: 0x0018 (R/  32) Device Identification"]
    pub DID: DSU_DID_Type,
    pub Reserved2: [RoReg8; 212usize],
    #[doc = "< \\brief Offset: 0x00F0 (R/W 32) Device Configuration"]
    pub DCFG: [DSU_DCFG_Type; 2usize],
    pub Reserved3: [RoReg8; 3848usize],
    #[doc = "< \\brief Offset: 0x1000 (R/  32) CoreSight ROM Table Entry 0"]
    pub ENTRY0: DSU_ENTRY0_Type,
    #[doc = "< \\brief Offset: 0x1004 (R/  32) CoreSight ROM Table Entry 1"]
    pub ENTRY1: DSU_ENTRY1_Type,
    #[doc = "< \\brief Offset: 0x1008 (R/  32) CoreSight ROM Table End"]
    pub END: DSU_END_Type,
    pub Reserved4: [RoReg8; 4032usize],
    #[doc = "< \\brief Offset: 0x1FCC (R/  32) CoreSight ROM Table Memory Type"]
    pub MEMTYPE: DSU_MEMTYPE_Type,
    #[doc = "< \\brief Offset: 0x1FD0 (R/  32) Peripheral Identification 4"]
    pub PID4: DSU_PID4_Type,
    #[doc = "< \\brief Offset: 0x1FD4 (R/  32) Peripheral Identification 5"]
    pub PID5: DSU_PID5_Type,
    #[doc = "< \\brief Offset: 0x1FD8 (R/  32) Peripheral Identification 6"]
    pub PID6: DSU_PID6_Type,
    #[doc = "< \\brief Offset: 0x1FDC (R/  32) Peripheral Identification 7"]
    pub PID7: DSU_PID7_Type,
    #[doc = "< \\brief Offset: 0x1FE0 (R/  32) Peripheral Identification 0"]
    pub PID0: DSU_PID0_Type,
    #[doc = "< \\brief Offset: 0x1FE4 (R/  32) Peripheral Identification 1"]
    pub PID1: DSU_PID1_Type,
    #[doc = "< \\brief Offset: 0x1FE8 (R/  32) Peripheral Identification 2"]
    pub PID2: DSU_PID2_Type,
    #[doc = "< \\brief Offset: 0x1FEC (R/  32) Peripheral Identification 3"]
    pub PID3: DSU_PID3_Type,
    #[doc = "< \\brief Offset: 0x1FF0 (R/  32) Component Identification 0"]
    pub CID0: DSU_CID0_Type,
    #[doc = "< \\brief Offset: 0x1FF4 (R/  32) Component Identification 1"]
    pub CID1: DSU_CID1_Type,
    #[doc = "< \\brief Offset: 0x1FF8 (R/  32) Component Identification 2"]
    pub CID2: DSU_CID2_Type,
    #[doc = "< \\brief Offset: 0x1FFC (R/  32) Component Identification 3"]
    pub CID3: DSU_CID3_Type,
}
#[test]
fn bindgen_test_layout_Dsu() {
    const UNINIT: ::core::mem::MaybeUninit<Dsu> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Dsu>(),
        8192usize,
        concat!("Size of: ", stringify!(Dsu))
    );
    assert_eq!(
        ::core::mem::align_of::<Dsu>(),
        4usize,
        concat!("Alignment of ", stringify!(Dsu))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(CTRL))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUSA) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(STATUSA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUSB) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(STATUSB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ADDR) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(ADDR))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LENGTH) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(LENGTH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DATA) as usize - ptr as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(DATA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DCC) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(DCC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DID) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(DID))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DCFG) as usize - ptr as usize },
        240usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(DCFG))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ENTRY0) as usize - ptr as usize },
        4096usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(ENTRY0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ENTRY1) as usize - ptr as usize },
        4100usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(ENTRY1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).END) as usize - ptr as usize },
        4104usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(END))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        4108usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MEMTYPE) as usize - ptr as usize },
        8140usize,
        concat!(
            "Offset of field: ",
            stringify!(Dsu),
            "::",
            stringify!(MEMTYPE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID4) as usize - ptr as usize },
        8144usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID4))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID5) as usize - ptr as usize },
        8148usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID5))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID6) as usize - ptr as usize },
        8152usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID6))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID7) as usize - ptr as usize },
        8156usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID7))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID0) as usize - ptr as usize },
        8160usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID0))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID1) as usize - ptr as usize },
        8164usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID2) as usize - ptr as usize },
        8168usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID3) as usize - ptr as usize },
        8172usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(PID3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CID0) as usize - ptr as usize },
        8176usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(CID0))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CID1) as usize - ptr as usize },
        8180usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(CID1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CID2) as usize - ptr as usize },
        8184usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(CID2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CID3) as usize - ptr as usize },
        8188usize,
        concat!("Offset of field: ", stringify!(Dsu), "::", stringify!(CID3))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EIC_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_EIC_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(EIC_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(EIC_CTRLA_Type__bindgen_ty_1))
    );
}
impl EIC_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CKSEL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CKSEL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u8, ENABLE: u8, CKSEL: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CKSEL: u8 = unsafe { ::core::mem::transmute(CKSEL) };
            CKSEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EIC_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EIC_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(EIC_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(EIC_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_NMICTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_NMICTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EIC_NMICTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_EIC_NMICTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_NMICTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(EIC_NMICTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_NMICTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(EIC_NMICTRL_Type__bindgen_ty_1))
    );
}
impl EIC_NMICTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn NMISENSE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_NMISENSE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn NMIFILTEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NMIFILTEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NMIASYNCH(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NMIASYNCH(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NMISENSE: u8,
        NMIFILTEN: u8,
        NMIASYNCH: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let NMISENSE: u8 = unsafe { ::core::mem::transmute(NMISENSE) };
            NMISENSE as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NMIFILTEN: u8 = unsafe { ::core::mem::transmute(NMIFILTEN) };
            NMIFILTEN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NMIASYNCH: u8 = unsafe { ::core::mem::transmute(NMIASYNCH) };
            NMIASYNCH as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_NMICTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EIC_NMICTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EIC_NMICTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(EIC_NMICTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_NMICTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(EIC_NMICTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_NMICTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_NMICTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_NMIFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_NMIFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_NMIFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_EIC_NMIFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_NMIFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(EIC_NMIFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_NMIFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(EIC_NMIFLAG_Type__bindgen_ty_1))
    );
}
impl EIC_NMIFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn NMI(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NMI(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(NMI: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NMI: u16 = unsafe { ::core::mem::transmute(NMI) };
            NMI as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_NMIFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EIC_NMIFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EIC_NMIFLAG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(EIC_NMIFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_NMIFLAG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(EIC_NMIFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_NMIFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_NMIFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EIC_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_SYNCBUSY_Type__bindgen_ty_1))
    );
}
impl EIC_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u32, ENABLE: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EIC_SYNCBUSY_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EIC_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EIC_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_EVCTRL_Type__bindgen_ty_1))
    );
}
impl EIC_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn EXTINTEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINTEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EXTINTEO: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let EXTINTEO: u32 = unsafe { ::core::mem::transmute(EXTINTEO) };
            EXTINTEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EIC_EVCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EIC_EVCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_EVCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EIC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTENCLR_Type__bindgen_ty_1))
    );
}
impl EIC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn EXTINT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EXTINT: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let EXTINT: u32 = unsafe { ::core::mem::transmute(EXTINT) };
            EXTINT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EIC_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EIC_INTENCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTENCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EIC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTENSET_Type__bindgen_ty_1))
    );
}
impl EIC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn EXTINT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EXTINT: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let EXTINT: u32 = unsafe { ::core::mem::transmute(EXTINT) };
            EXTINT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EIC_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EIC_INTENSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTENSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EIC_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTFLAG_Type__bindgen_ty_1))
    );
}
impl EIC_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn EXTINT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_EXTINT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EXTINT: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let EXTINT: u32 = unsafe { ::core::mem::transmute(EXTINT) };
            EXTINT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EIC_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EIC_INTFLAG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_INTFLAG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_ASYNCH_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_ASYNCH_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_ASYNCH_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EIC_ASYNCH_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_ASYNCH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_ASYNCH_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_ASYNCH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_ASYNCH_Type__bindgen_ty_1))
    );
}
impl EIC_ASYNCH_Type__bindgen_ty_1 {
    #[inline]
    pub fn ASYNCH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_ASYNCH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ASYNCH: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let ASYNCH: u32 = unsafe { ::core::mem::transmute(ASYNCH) };
            ASYNCH as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_ASYNCH_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EIC_ASYNCH_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EIC_ASYNCH_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_ASYNCH_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_ASYNCH_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_ASYNCH_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_ASYNCH_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_ASYNCH_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EIC_CONFIG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EIC_CONFIG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EIC_CONFIG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EIC_CONFIG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EIC_CONFIG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_CONFIG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_CONFIG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_CONFIG_Type__bindgen_ty_1))
    );
}
impl EIC_CONFIG_Type__bindgen_ty_1 {
    #[inline]
    pub fn SENSE0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SENSE7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SENSE7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTEN7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FILTEN7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SENSE0: u32,
        FILTEN0: u32,
        SENSE1: u32,
        FILTEN1: u32,
        SENSE2: u32,
        FILTEN2: u32,
        SENSE3: u32,
        FILTEN3: u32,
        SENSE4: u32,
        FILTEN4: u32,
        SENSE5: u32,
        FILTEN5: u32,
        SENSE6: u32,
        FILTEN6: u32,
        SENSE7: u32,
        FILTEN7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SENSE0: u32 = unsafe { ::core::mem::transmute(SENSE0) };
            SENSE0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let FILTEN0: u32 = unsafe { ::core::mem::transmute(FILTEN0) };
            FILTEN0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let SENSE1: u32 = unsafe { ::core::mem::transmute(SENSE1) };
            SENSE1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let FILTEN1: u32 = unsafe { ::core::mem::transmute(FILTEN1) };
            FILTEN1 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let SENSE2: u32 = unsafe { ::core::mem::transmute(SENSE2) };
            SENSE2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let FILTEN2: u32 = unsafe { ::core::mem::transmute(FILTEN2) };
            FILTEN2 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let SENSE3: u32 = unsafe { ::core::mem::transmute(SENSE3) };
            SENSE3 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FILTEN3: u32 = unsafe { ::core::mem::transmute(FILTEN3) };
            FILTEN3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let SENSE4: u32 = unsafe { ::core::mem::transmute(SENSE4) };
            SENSE4 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let FILTEN4: u32 = unsafe { ::core::mem::transmute(FILTEN4) };
            FILTEN4 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let SENSE5: u32 = unsafe { ::core::mem::transmute(SENSE5) };
            SENSE5 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let FILTEN5: u32 = unsafe { ::core::mem::transmute(FILTEN5) };
            FILTEN5 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let SENSE6: u32 = unsafe { ::core::mem::transmute(SENSE6) };
            SENSE6 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let FILTEN6: u32 = unsafe { ::core::mem::transmute(FILTEN6) };
            FILTEN6 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 3u8, {
            let SENSE7: u32 = unsafe { ::core::mem::transmute(SENSE7) };
            SENSE7 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let FILTEN7: u32 = unsafe { ::core::mem::transmute(FILTEN7) };
            FILTEN7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EIC_CONFIG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EIC_CONFIG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EIC_CONFIG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EIC_CONFIG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EIC_CONFIG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EIC_CONFIG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_CONFIG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EIC_CONFIG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Eic {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control"]
    pub CTRLA: EIC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x01 (R/W  8) NMI Control"]
    pub NMICTRL: EIC_NMICTRL_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) NMI Interrupt Flag"]
    pub NMIFLAG: EIC_NMIFLAG_Type,
    #[doc = "< \\brief Offset: 0x04 (R/  32) Syncbusy register"]
    pub SYNCBUSY: EIC_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) Event Control"]
    pub EVCTRL: EIC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W 32) Interrupt Enable Clear"]
    pub INTENCLR: EIC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Interrupt Enable Set"]
    pub INTENSET: EIC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) Interrupt Flag Status and Clear"]
    pub INTFLAG: EIC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W 32) EIC Asynchronous edge Detection Enable"]
    pub ASYNCH: EIC_ASYNCH_Type,
    #[doc = "< \\brief Offset: 0x1C (R/W 32) Configuration n"]
    pub CONFIG: [EIC_CONFIG_Type; 2usize],
}
#[test]
fn bindgen_test_layout_Eic() {
    const UNINIT: ::core::mem::MaybeUninit<Eic> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Eic>(),
        36usize,
        concat!("Size of: ", stringify!(Eic))
    );
    assert_eq!(
        ::core::mem::align_of::<Eic>(),
        4usize,
        concat!("Alignment of ", stringify!(Eic))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NMICTRL) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(NMICTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NMIFLAG) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(NMIFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ASYNCH) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(ASYNCH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CONFIG) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Eic),
            "::",
            stringify!(CONFIG)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(EVSYS_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(EVSYS_CTRLA_Type__bindgen_ty_1))
    );
}
impl EVSYS_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EVSYS_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(EVSYS_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(EVSYS_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_CHSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_CHSTATUS_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EVSYS_CHSTATUS_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_CHSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_CHSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CHSTATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_CHSTATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CHSTATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_CHSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl EVSYS_CHSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn USRRDY0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USRRDY7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        USRRDY0: u32,
        USRRDY1: u32,
        USRRDY2: u32,
        USRRDY3: u32,
        USRRDY4: u32,
        USRRDY5: u32,
        USRRDY6: u32,
        USRRDY7: u32,
        CHBUSY0: u32,
        CHBUSY1: u32,
        CHBUSY2: u32,
        CHBUSY3: u32,
        CHBUSY4: u32,
        CHBUSY5: u32,
        CHBUSY6: u32,
        CHBUSY7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let USRRDY0: u32 = unsafe { ::core::mem::transmute(USRRDY0) };
            USRRDY0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let USRRDY1: u32 = unsafe { ::core::mem::transmute(USRRDY1) };
            USRRDY1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let USRRDY2: u32 = unsafe { ::core::mem::transmute(USRRDY2) };
            USRRDY2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let USRRDY3: u32 = unsafe { ::core::mem::transmute(USRRDY3) };
            USRRDY3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let USRRDY4: u32 = unsafe { ::core::mem::transmute(USRRDY4) };
            USRRDY4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let USRRDY5: u32 = unsafe { ::core::mem::transmute(USRRDY5) };
            USRRDY5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let USRRDY6: u32 = unsafe { ::core::mem::transmute(USRRDY6) };
            USRRDY6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let USRRDY7: u32 = unsafe { ::core::mem::transmute(USRRDY7) };
            USRRDY7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let CHBUSY0: u32 = unsafe { ::core::mem::transmute(CHBUSY0) };
            CHBUSY0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let CHBUSY1: u32 = unsafe { ::core::mem::transmute(CHBUSY1) };
            CHBUSY1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let CHBUSY2: u32 = unsafe { ::core::mem::transmute(CHBUSY2) };
            CHBUSY2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let CHBUSY3: u32 = unsafe { ::core::mem::transmute(CHBUSY3) };
            CHBUSY3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let CHBUSY4: u32 = unsafe { ::core::mem::transmute(CHBUSY4) };
            CHBUSY4 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let CHBUSY5: u32 = unsafe { ::core::mem::transmute(CHBUSY5) };
            CHBUSY5 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let CHBUSY6: u32 = unsafe { ::core::mem::transmute(CHBUSY6) };
            CHBUSY6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let CHBUSY7: u32 = unsafe { ::core::mem::transmute(CHBUSY7) };
            CHBUSY7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_CHSTATUS_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_CHSTATUS_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CHSTATUS_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_CHSTATUS_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CHSTATUS_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_CHSTATUS_Type__bindgen_ty_2)
        )
    );
}
impl EVSYS_CHSTATUS_Type__bindgen_ty_2 {
    #[inline]
    pub fn USRRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_USRRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn CHBUSY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_CHBUSY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(USRRDY: u32, CHBUSY: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let USRRDY: u32 = unsafe { ::core::mem::transmute(USRRDY) };
            USRRDY as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let CHBUSY: u32 = unsafe { ::core::mem::transmute(CHBUSY) };
            CHBUSY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_CHSTATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EVSYS_CHSTATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CHSTATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_CHSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CHSTATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_CHSTATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CHSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CHSTATUS_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CHSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EVSYS_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl EVSYS_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVR0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVR0: u32,
        OVR1: u32,
        OVR2: u32,
        OVR3: u32,
        OVR4: u32,
        OVR5: u32,
        OVR6: u32,
        OVR7: u32,
        EVD0: u32,
        EVD1: u32,
        EVD2: u32,
        EVD3: u32,
        EVD4: u32,
        EVD5: u32,
        EVD6: u32,
        EVD7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVR0: u32 = unsafe { ::core::mem::transmute(OVR0) };
            OVR0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVR1: u32 = unsafe { ::core::mem::transmute(OVR1) };
            OVR1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OVR2: u32 = unsafe { ::core::mem::transmute(OVR2) };
            OVR2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let OVR3: u32 = unsafe { ::core::mem::transmute(OVR3) };
            OVR3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OVR4: u32 = unsafe { ::core::mem::transmute(OVR4) };
            OVR4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let OVR5: u32 = unsafe { ::core::mem::transmute(OVR5) };
            OVR5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let OVR6: u32 = unsafe { ::core::mem::transmute(OVR6) };
            OVR6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVR7: u32 = unsafe { ::core::mem::transmute(OVR7) };
            OVR7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let EVD0: u32 = unsafe { ::core::mem::transmute(EVD0) };
            EVD0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let EVD1: u32 = unsafe { ::core::mem::transmute(EVD1) };
            EVD1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let EVD2: u32 = unsafe { ::core::mem::transmute(EVD2) };
            EVD2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let EVD3: u32 = unsafe { ::core::mem::transmute(EVD3) };
            EVD3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let EVD4: u32 = unsafe { ::core::mem::transmute(EVD4) };
            EVD4 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let EVD5: u32 = unsafe { ::core::mem::transmute(EVD5) };
            EVD5 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let EVD6: u32 = unsafe { ::core::mem::transmute(EVD6) };
            EVD6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let EVD7: u32 = unsafe { ::core::mem::transmute(EVD7) };
            EVD7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTENCLR_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTENCLR_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTENCLR_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_INTENCLR_Type__bindgen_ty_2)
        )
    );
}
impl EVSYS_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn OVR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_OVR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_EVD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(OVR: u32, EVD: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let OVR: u32 = unsafe { ::core::mem::transmute(OVR) };
            OVR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let EVD: u32 = unsafe { ::core::mem::transmute(EVD) };
            EVD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EVSYS_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTENCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTENCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EVSYS_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl EVSYS_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVR0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVR0: u32,
        OVR1: u32,
        OVR2: u32,
        OVR3: u32,
        OVR4: u32,
        OVR5: u32,
        OVR6: u32,
        OVR7: u32,
        EVD0: u32,
        EVD1: u32,
        EVD2: u32,
        EVD3: u32,
        EVD4: u32,
        EVD5: u32,
        EVD6: u32,
        EVD7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVR0: u32 = unsafe { ::core::mem::transmute(OVR0) };
            OVR0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVR1: u32 = unsafe { ::core::mem::transmute(OVR1) };
            OVR1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OVR2: u32 = unsafe { ::core::mem::transmute(OVR2) };
            OVR2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let OVR3: u32 = unsafe { ::core::mem::transmute(OVR3) };
            OVR3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OVR4: u32 = unsafe { ::core::mem::transmute(OVR4) };
            OVR4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let OVR5: u32 = unsafe { ::core::mem::transmute(OVR5) };
            OVR5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let OVR6: u32 = unsafe { ::core::mem::transmute(OVR6) };
            OVR6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVR7: u32 = unsafe { ::core::mem::transmute(OVR7) };
            OVR7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let EVD0: u32 = unsafe { ::core::mem::transmute(EVD0) };
            EVD0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let EVD1: u32 = unsafe { ::core::mem::transmute(EVD1) };
            EVD1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let EVD2: u32 = unsafe { ::core::mem::transmute(EVD2) };
            EVD2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let EVD3: u32 = unsafe { ::core::mem::transmute(EVD3) };
            EVD3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let EVD4: u32 = unsafe { ::core::mem::transmute(EVD4) };
            EVD4 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let EVD5: u32 = unsafe { ::core::mem::transmute(EVD5) };
            EVD5 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let EVD6: u32 = unsafe { ::core::mem::transmute(EVD6) };
            EVD6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let EVD7: u32 = unsafe { ::core::mem::transmute(EVD7) };
            EVD7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTENSET_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTENSET_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTENSET_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_INTENSET_Type__bindgen_ty_2)
        )
    );
}
impl EVSYS_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn OVR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_OVR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_EVD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(OVR: u32, EVD: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let OVR: u32 = unsafe { ::core::mem::transmute(OVR) };
            OVR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let EVD: u32 = unsafe { ::core::mem::transmute(EVD) };
            EVD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EVSYS_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTENSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTENSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EVSYS_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl EVSYS_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVR0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVR7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVR7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVD7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVR0: u32,
        OVR1: u32,
        OVR2: u32,
        OVR3: u32,
        OVR4: u32,
        OVR5: u32,
        OVR6: u32,
        OVR7: u32,
        EVD0: u32,
        EVD1: u32,
        EVD2: u32,
        EVD3: u32,
        EVD4: u32,
        EVD5: u32,
        EVD6: u32,
        EVD7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVR0: u32 = unsafe { ::core::mem::transmute(OVR0) };
            OVR0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVR1: u32 = unsafe { ::core::mem::transmute(OVR1) };
            OVR1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let OVR2: u32 = unsafe { ::core::mem::transmute(OVR2) };
            OVR2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let OVR3: u32 = unsafe { ::core::mem::transmute(OVR3) };
            OVR3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OVR4: u32 = unsafe { ::core::mem::transmute(OVR4) };
            OVR4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let OVR5: u32 = unsafe { ::core::mem::transmute(OVR5) };
            OVR5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let OVR6: u32 = unsafe { ::core::mem::transmute(OVR6) };
            OVR6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let OVR7: u32 = unsafe { ::core::mem::transmute(OVR7) };
            OVR7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let EVD0: u32 = unsafe { ::core::mem::transmute(EVD0) };
            EVD0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let EVD1: u32 = unsafe { ::core::mem::transmute(EVD1) };
            EVD1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let EVD2: u32 = unsafe { ::core::mem::transmute(EVD2) };
            EVD2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let EVD3: u32 = unsafe { ::core::mem::transmute(EVD3) };
            EVD3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let EVD4: u32 = unsafe { ::core::mem::transmute(EVD4) };
            EVD4 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let EVD5: u32 = unsafe { ::core::mem::transmute(EVD5) };
            EVD5 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let EVD6: u32 = unsafe { ::core::mem::transmute(EVD6) };
            EVD6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let EVD7: u32 = unsafe { ::core::mem::transmute(EVD7) };
            EVD7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTFLAG_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTFLAG_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTFLAG_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_INTFLAG_Type__bindgen_ty_2)
        )
    );
}
impl EVSYS_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn OVR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_OVR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn EVD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_EVD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(OVR: u32, EVD: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let OVR: u32 = unsafe { ::core::mem::transmute(OVR) };
            OVR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let EVD: u32 = unsafe { ::core::mem::transmute(EVD) };
            EVD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EVSYS_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EVSYS_INTFLAG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_INTFLAG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_SWEVT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_SWEVT_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: EVSYS_SWEVT_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_SWEVT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_SWEVT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_SWEVT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_SWEVT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_SWEVT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_SWEVT_Type__bindgen_ty_1))
    );
}
impl EVSYS_SWEVT_Type__bindgen_ty_1 {
    #[inline]
    pub fn CHANNEL0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHANNEL0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHANNEL1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHANNEL1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHANNEL2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHANNEL2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHANNEL3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHANNEL3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHANNEL4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHANNEL4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHANNEL5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHANNEL5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHANNEL6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHANNEL6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CHANNEL7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHANNEL7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CHANNEL0: u32,
        CHANNEL1: u32,
        CHANNEL2: u32,
        CHANNEL3: u32,
        CHANNEL4: u32,
        CHANNEL5: u32,
        CHANNEL6: u32,
        CHANNEL7: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CHANNEL0: u32 = unsafe { ::core::mem::transmute(CHANNEL0) };
            CHANNEL0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CHANNEL1: u32 = unsafe { ::core::mem::transmute(CHANNEL1) };
            CHANNEL1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CHANNEL2: u32 = unsafe { ::core::mem::transmute(CHANNEL2) };
            CHANNEL2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CHANNEL3: u32 = unsafe { ::core::mem::transmute(CHANNEL3) };
            CHANNEL3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CHANNEL4: u32 = unsafe { ::core::mem::transmute(CHANNEL4) };
            CHANNEL4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CHANNEL5: u32 = unsafe { ::core::mem::transmute(CHANNEL5) };
            CHANNEL5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let CHANNEL6: u32 = unsafe { ::core::mem::transmute(CHANNEL6) };
            CHANNEL6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CHANNEL7: u32 = unsafe { ::core::mem::transmute(CHANNEL7) };
            CHANNEL7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_SWEVT_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_SWEVT_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_SWEVT_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_SWEVT_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_SWEVT_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_SWEVT_Type__bindgen_ty_2))
    );
}
impl EVSYS_SWEVT_Type__bindgen_ty_2 {
    #[inline]
    pub fn CHANNEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_CHANNEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CHANNEL: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let CHANNEL: u32 = unsafe { ::core::mem::transmute(CHANNEL) };
            CHANNEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_SWEVT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EVSYS_SWEVT_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EVSYS_SWEVT_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_SWEVT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_SWEVT_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_SWEVT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_SWEVT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_SWEVT_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_SWEVT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_CHANNEL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_CHANNEL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_CHANNEL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_CHANNEL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CHANNEL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_CHANNEL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CHANNEL_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(EVSYS_CHANNEL_Type__bindgen_ty_1)
        )
    );
}
impl EVSYS_CHANNEL_Type__bindgen_ty_1 {
    #[inline]
    pub fn EVGEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_EVGEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn PATH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PATH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn EDGSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_EDGSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EVGEN: u32,
        PATH: u32,
        EDGSEL: u32,
        RUNSTDBY: u32,
        ONDEMAND: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let EVGEN: u32 = unsafe { ::core::mem::transmute(EVGEN) };
            EVGEN as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let PATH: u32 = unsafe { ::core::mem::transmute(PATH) };
            PATH as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let EDGSEL: u32 = unsafe { ::core::mem::transmute(EDGSEL) };
            EDGSEL as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let ONDEMAND: u32 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_CHANNEL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EVSYS_CHANNEL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EVSYS_CHANNEL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_CHANNEL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_CHANNEL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_CHANNEL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CHANNEL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_CHANNEL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union EVSYS_USER_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: EVSYS_USER_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct EVSYS_USER_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_EVSYS_USER_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<EVSYS_USER_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_USER_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_USER_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_USER_Type__bindgen_ty_1))
    );
}
impl EVSYS_USER_Type__bindgen_ty_1 {
    #[inline]
    pub fn CHANNEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CHANNEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CHANNEL: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let CHANNEL: u32 = unsafe { ::core::mem::transmute(CHANNEL) };
            CHANNEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_EVSYS_USER_Type() {
    const UNINIT: ::core::mem::MaybeUninit<EVSYS_USER_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<EVSYS_USER_Type>(),
        4usize,
        concat!("Size of: ", stringify!(EVSYS_USER_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<EVSYS_USER_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(EVSYS_USER_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_USER_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EVSYS_USER_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Evsys {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control"]
    pub CTRLA: EVSYS_CTRLA_Type,
    pub Reserved1: [RoReg8; 11usize],
    #[doc = "< \\brief Offset: 0x0C (R/  32) Channel Status"]
    pub CHSTATUS: EVSYS_CHSTATUS_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Interrupt Enable Clear"]
    pub INTENCLR: EVSYS_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) Interrupt Enable Set"]
    pub INTENSET: EVSYS_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W 32) Interrupt Flag Status and Clear"]
    pub INTFLAG: EVSYS_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x1C ( /W 32) Software Event"]
    pub SWEVT: EVSYS_SWEVT_Type,
    #[doc = "< \\brief Offset: 0x20 (R/W 32) Channel n"]
    pub CHANNEL: [EVSYS_CHANNEL_Type; 8usize],
    pub Reserved2: [RoReg8; 64usize],
    #[doc = "< \\brief Offset: 0x80 (R/W 32) User Multiplexer n"]
    pub USER: [EVSYS_USER_Type; 31usize],
}
#[test]
fn bindgen_test_layout_Evsys() {
    const UNINIT: ::core::mem::MaybeUninit<Evsys> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Evsys>(),
        252usize,
        concat!("Size of: ", stringify!(Evsys))
    );
    assert_eq!(
        ::core::mem::align_of::<Evsys>(),
        4usize,
        concat!("Alignment of ", stringify!(Evsys))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CHSTATUS) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(CHSTATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SWEVT) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(SWEVT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CHANNEL) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(CHANNEL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).USER) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Evsys),
            "::",
            stringify!(USER)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FREQM_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: FREQM_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FREQM_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_FREQM_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FREQM_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(FREQM_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(FREQM_CTRLA_Type__bindgen_ty_1))
    );
}
impl FREQM_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u8, ENABLE: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_FREQM_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<FREQM_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FREQM_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(FREQM_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(FREQM_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FREQM_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: FREQM_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FREQM_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_FREQM_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FREQM_CTRLB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(FREQM_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_CTRLB_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(FREQM_CTRLB_Type__bindgen_ty_1))
    );
}
impl FREQM_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn START(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_START(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(START: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let START: u8 = unsafe { ::core::mem::transmute(START) };
            START as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_FREQM_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<FREQM_CTRLB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FREQM_CTRLB_Type>(),
        1usize,
        concat!("Size of: ", stringify!(FREQM_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_CTRLB_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(FREQM_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FREQM_CFGA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: FREQM_CFGA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct FREQM_CFGA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_FREQM_CFGA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FREQM_CFGA_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(FREQM_CFGA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_CFGA_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(FREQM_CFGA_Type__bindgen_ty_1))
    );
}
impl FREQM_CFGA_Type__bindgen_ty_1 {
    #[inline]
    pub fn REFNUM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_REFNUM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(REFNUM: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let REFNUM: u16 = unsafe { ::core::mem::transmute(REFNUM) };
            REFNUM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_FREQM_CFGA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<FREQM_CFGA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FREQM_CFGA_Type>(),
        2usize,
        concat!("Size of: ", stringify!(FREQM_CFGA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_CFGA_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(FREQM_CFGA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_CFGA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_CFGA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FREQM_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: FREQM_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FREQM_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_FREQM_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FREQM_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(FREQM_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(FREQM_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl FREQM_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DONE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DONE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DONE: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DONE: u8 = unsafe { ::core::mem::transmute(DONE) };
            DONE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_FREQM_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<FREQM_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FREQM_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(FREQM_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(FREQM_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FREQM_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: FREQM_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FREQM_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_FREQM_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FREQM_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(FREQM_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(FREQM_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl FREQM_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DONE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DONE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DONE: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DONE: u8 = unsafe { ::core::mem::transmute(DONE) };
            DONE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_FREQM_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<FREQM_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FREQM_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(FREQM_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(FREQM_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FREQM_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: FREQM_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FREQM_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_FREQM_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FREQM_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(FREQM_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(FREQM_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl FREQM_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn DONE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DONE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DONE: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DONE: u8 = unsafe { ::core::mem::transmute(DONE) };
            DONE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_FREQM_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<FREQM_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FREQM_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(FREQM_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(FREQM_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FREQM_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: FREQM_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct FREQM_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_FREQM_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FREQM_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(FREQM_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(FREQM_STATUS_Type__bindgen_ty_1))
    );
}
impl FREQM_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn BUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BUSY: u8, OVF: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BUSY: u8 = unsafe { ::core::mem::transmute(BUSY) };
            BUSY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_FREQM_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<FREQM_STATUS_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FREQM_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(FREQM_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(FREQM_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FREQM_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: FREQM_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct FREQM_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_FREQM_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FREQM_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(FREQM_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(FREQM_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl FREQM_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u32, ENABLE: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_FREQM_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<FREQM_SYNCBUSY_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FREQM_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(FREQM_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(FREQM_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FREQM_VALUE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: FREQM_VALUE_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct FREQM_VALUE_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_FREQM_VALUE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<FREQM_VALUE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(FREQM_VALUE_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_VALUE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(FREQM_VALUE_Type__bindgen_ty_1))
    );
}
impl FREQM_VALUE_Type__bindgen_ty_1 {
    #[inline]
    pub fn VALUE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_VALUE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(VALUE: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let VALUE: u32 = unsafe { ::core::mem::transmute(VALUE) };
            VALUE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_FREQM_VALUE_Type() {
    const UNINIT: ::core::mem::MaybeUninit<FREQM_VALUE_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<FREQM_VALUE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(FREQM_VALUE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<FREQM_VALUE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(FREQM_VALUE_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_VALUE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FREQM_VALUE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Freqm {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control A Register"]
    pub CTRLA: FREQM_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x01 ( /W  8) Control B Register"]
    pub CTRLB: FREQM_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) Config A register"]
    pub CFGA: FREQM_CFGA_Type,
    pub Reserved1: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x08 (R/W  8) Interrupt Enable Clear Register"]
    pub INTENCLR: FREQM_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x09 (R/W  8) Interrupt Enable Set Register"]
    pub INTENSET: FREQM_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x0A (R/W  8) Interrupt Flag Register"]
    pub INTFLAG: FREQM_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0B (R/W  8) Status Register"]
    pub STATUS: FREQM_STATUS_Type,
    #[doc = "< \\brief Offset: 0x0C (R/  32) Synchronization Busy Register"]
    pub SYNCBUSY: FREQM_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x10 (R/  32) Count Value Register"]
    pub VALUE: FREQM_VALUE_Type,
}
#[test]
fn bindgen_test_layout_Freqm() {
    const UNINIT: ::core::mem::MaybeUninit<Freqm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Freqm>(),
        20usize,
        concat!("Size of: ", stringify!(Freqm))
    );
    assert_eq!(
        ::core::mem::align_of::<Freqm>(),
        4usize,
        concat!("Alignment of ", stringify!(Freqm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Freqm),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Freqm),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFGA) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Freqm),
            "::",
            stringify!(CFGA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Freqm),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Freqm),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(Freqm),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Freqm),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(Freqm),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Freqm),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VALUE) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Freqm),
            "::",
            stringify!(VALUE)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GCLK_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: GCLK_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct GCLK_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_GCLK_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(GCLK_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(GCLK_CTRLA_Type__bindgen_ty_1))
    );
}
impl GCLK_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_GCLK_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<GCLK_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GCLK_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(GCLK_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(GCLK_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GCLK_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: GCLK_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: GCLK_SYNCBUSY_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct GCLK_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_GCLK_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(GCLK_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(GCLK_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl GCLK_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GENCTRL0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GENCTRL0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GENCTRL1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GENCTRL1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GENCTRL2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GENCTRL2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GENCTRL3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GENCTRL3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GENCTRL4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GENCTRL4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        GENCTRL0: u32,
        GENCTRL1: u32,
        GENCTRL2: u32,
        GENCTRL3: u32,
        GENCTRL4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let GENCTRL0: u32 = unsafe { ::core::mem::transmute(GENCTRL0) };
            GENCTRL0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let GENCTRL1: u32 = unsafe { ::core::mem::transmute(GENCTRL1) };
            GENCTRL1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let GENCTRL2: u32 = unsafe { ::core::mem::transmute(GENCTRL2) };
            GENCTRL2 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let GENCTRL3: u32 = unsafe { ::core::mem::transmute(GENCTRL3) };
            GENCTRL3 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let GENCTRL4: u32 = unsafe { ::core::mem::transmute(GENCTRL4) };
            GENCTRL4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct GCLK_SYNCBUSY_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_GCLK_SYNCBUSY_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(GCLK_SYNCBUSY_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(GCLK_SYNCBUSY_Type__bindgen_ty_2)
        )
    );
}
impl GCLK_SYNCBUSY_Type__bindgen_ty_2 {
    #[inline]
    pub fn GENCTRL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_GENCTRL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(GENCTRL: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(2usize, 5u8, {
            let GENCTRL: u32 = unsafe { ::core::mem::transmute(GENCTRL) };
            GENCTRL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_GCLK_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<GCLK_SYNCBUSY_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GCLK_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(GCLK_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(GCLK_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_SYNCBUSY_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GCLK_GENCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: GCLK_GENCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct GCLK_GENCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_GCLK_GENCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_GENCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(GCLK_GENCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_GENCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(GCLK_GENCTRL_Type__bindgen_ty_1))
    );
}
impl GCLK_GENCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SRC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SRC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn GENEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GENEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IDC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IDC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OOV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OOV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DIVSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DIVSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_DIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SRC: u32,
        GENEN: u32,
        IDC: u32,
        OOV: u32,
        OE: u32,
        DIVSEL: u32,
        RUNSTDBY: u32,
        DIV: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SRC: u32 = unsafe { ::core::mem::transmute(SRC) };
            SRC as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let GENEN: u32 = unsafe { ::core::mem::transmute(GENEN) };
            GENEN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let IDC: u32 = unsafe { ::core::mem::transmute(IDC) };
            IDC as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let OOV: u32 = unsafe { ::core::mem::transmute(OOV) };
            OOV as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let OE: u32 = unsafe { ::core::mem::transmute(OE) };
            OE as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let DIVSEL: u32 = unsafe { ::core::mem::transmute(DIVSEL) };
            DIVSEL as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let DIV: u32 = unsafe { ::core::mem::transmute(DIV) };
            DIV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_GCLK_GENCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<GCLK_GENCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GCLK_GENCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(GCLK_GENCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_GENCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(GCLK_GENCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_GENCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_GENCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union GCLK_PCHCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: GCLK_PCHCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct GCLK_PCHCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_GCLK_PCHCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<GCLK_PCHCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(GCLK_PCHCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_PCHCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(GCLK_PCHCTRL_Type__bindgen_ty_1))
    );
}
impl GCLK_PCHCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn GEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_GEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn CHEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CHEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WRTLOCK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WRTLOCK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        GEN: u32,
        CHEN: u32,
        WRTLOCK: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let GEN: u32 = unsafe { ::core::mem::transmute(GEN) };
            GEN as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let CHEN: u32 = unsafe { ::core::mem::transmute(CHEN) };
            CHEN as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let WRTLOCK: u32 = unsafe { ::core::mem::transmute(WRTLOCK) };
            WRTLOCK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_GCLK_PCHCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<GCLK_PCHCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<GCLK_PCHCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(GCLK_PCHCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<GCLK_PCHCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(GCLK_PCHCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_PCHCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GCLK_PCHCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Gclk {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control"]
    pub CTRLA: GCLK_CTRLA_Type,
    pub Reserved1: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x04 (R/  32) Synchronization Busy"]
    pub SYNCBUSY: GCLK_SYNCBUSY_Type,
    pub Reserved2: [RoReg8; 24usize],
    #[doc = "< \\brief Offset: 0x20 (R/W 32) Generic Clock Generator Control"]
    pub GENCTRL: [GCLK_GENCTRL_Type; 5usize],
    pub Reserved3: [RoReg8; 76usize],
    #[doc = "< \\brief Offset: 0x80 (R/W 32) Peripheral Clock Control"]
    pub PCHCTRL: [GCLK_PCHCTRL_Type; 30usize],
}
#[test]
fn bindgen_test_layout_Gclk() {
    const UNINIT: ::core::mem::MaybeUninit<Gclk> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Gclk>(),
        248usize,
        concat!("Size of: ", stringify!(Gclk))
    );
    assert_eq!(
        ::core::mem::align_of::<Gclk>(),
        4usize,
        concat!("Alignment of ", stringify!(Gclk))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Gclk),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Gclk),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Gclk),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Gclk),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GENCTRL) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Gclk),
            "::",
            stringify!(GENCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Gclk),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PCHCTRL) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Gclk),
            "::",
            stringify!(PCHCTRL)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MCLK_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MCLK_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCLK_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_MCLK_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MCLK_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(MCLK_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(MCLK_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl MCLK_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn CKRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CKRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CKRDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CKRDY: u8 = unsafe { ::core::mem::transmute(CKRDY) };
            CKRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MCLK_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MCLK_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MCLK_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(MCLK_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(MCLK_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MCLK_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MCLK_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCLK_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_MCLK_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MCLK_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(MCLK_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(MCLK_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl MCLK_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn CKRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CKRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CKRDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CKRDY: u8 = unsafe { ::core::mem::transmute(CKRDY) };
            CKRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MCLK_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MCLK_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MCLK_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(MCLK_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(MCLK_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MCLK_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MCLK_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCLK_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_MCLK_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MCLK_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(MCLK_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(MCLK_INTFLAG_Type__bindgen_ty_1))
    );
}
impl MCLK_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn CKRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CKRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CKRDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CKRDY: u8 = unsafe { ::core::mem::transmute(CKRDY) };
            CKRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MCLK_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MCLK_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MCLK_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(MCLK_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(MCLK_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MCLK_CPUDIV_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MCLK_CPUDIV_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCLK_CPUDIV_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_MCLK_CPUDIV_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MCLK_CPUDIV_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(MCLK_CPUDIV_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_CPUDIV_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(MCLK_CPUDIV_Type__bindgen_ty_1))
    );
}
impl MCLK_CPUDIV_Type__bindgen_ty_1 {
    #[inline]
    pub fn CPUDIV(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_CPUDIV(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CPUDIV: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let CPUDIV: u8 = unsafe { ::core::mem::transmute(CPUDIV) };
            CPUDIV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MCLK_CPUDIV_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MCLK_CPUDIV_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MCLK_CPUDIV_Type>(),
        1usize,
        concat!("Size of: ", stringify!(MCLK_CPUDIV_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_CPUDIV_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(MCLK_CPUDIV_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_CPUDIV_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_CPUDIV_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MCLK_BUPDIV_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MCLK_BUPDIV_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct MCLK_BUPDIV_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_MCLK_BUPDIV_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MCLK_BUPDIV_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(MCLK_BUPDIV_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_BUPDIV_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(MCLK_BUPDIV_Type__bindgen_ty_1))
    );
}
impl MCLK_BUPDIV_Type__bindgen_ty_1 {
    #[inline]
    pub fn BUPDIV(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_BUPDIV(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BUPDIV: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BUPDIV: u8 = unsafe { ::core::mem::transmute(BUPDIV) };
            BUPDIV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MCLK_BUPDIV_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MCLK_BUPDIV_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MCLK_BUPDIV_Type>(),
        1usize,
        concat!("Size of: ", stringify!(MCLK_BUPDIV_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_BUPDIV_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(MCLK_BUPDIV_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_BUPDIV_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_BUPDIV_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MCLK_AHBMASK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MCLK_AHBMASK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MCLK_AHBMASK_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_MCLK_AHBMASK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MCLK_AHBMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(MCLK_AHBMASK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_AHBMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MCLK_AHBMASK_Type__bindgen_ty_1))
    );
}
impl MCLK_AHBMASK_Type__bindgen_ty_1 {
    #[inline]
    pub fn HPB0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HPB0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HPB1_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HPB1_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HPB2_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HPB2_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DMAC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DMAC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USB_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USB_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DSU_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DSU_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PAC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PAC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NVMCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NVMCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HSRAM_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HSRAM_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NVMCTRL_PICACHU_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NVMCTRL_PICACHU_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        HPB0_: u32,
        HPB1_: u32,
        HPB2_: u32,
        DMAC_: u32,
        USB_: u32,
        DSU_: u32,
        PAC_: u32,
        NVMCTRL_: u32,
        HSRAM_: u32,
        NVMCTRL_PICACHU_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let HPB0_: u32 = unsafe { ::core::mem::transmute(HPB0_) };
            HPB0_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HPB1_: u32 = unsafe { ::core::mem::transmute(HPB1_) };
            HPB1_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HPB2_: u32 = unsafe { ::core::mem::transmute(HPB2_) };
            HPB2_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DMAC_: u32 = unsafe { ::core::mem::transmute(DMAC_) };
            DMAC_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let USB_: u32 = unsafe { ::core::mem::transmute(USB_) };
            USB_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DSU_: u32 = unsafe { ::core::mem::transmute(DSU_) };
            DSU_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PAC_: u32 = unsafe { ::core::mem::transmute(PAC_) };
            PAC_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let NVMCTRL_: u32 = unsafe { ::core::mem::transmute(NVMCTRL_) };
            NVMCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let HSRAM_: u32 = unsafe { ::core::mem::transmute(HSRAM_) };
            HSRAM_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let NVMCTRL_PICACHU_: u32 = unsafe { ::core::mem::transmute(NVMCTRL_PICACHU_) };
            NVMCTRL_PICACHU_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MCLK_AHBMASK_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MCLK_AHBMASK_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MCLK_AHBMASK_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MCLK_AHBMASK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_AHBMASK_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MCLK_AHBMASK_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_AHBMASK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_AHBMASK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MCLK_APBAMASK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MCLK_APBAMASK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MCLK_APBAMASK_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_MCLK_APBAMASK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MCLK_APBAMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(MCLK_APBAMASK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_APBAMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MCLK_APBAMASK_Type__bindgen_ty_1)
        )
    );
}
impl MCLK_APBAMASK_Type__bindgen_ty_1 {
    #[inline]
    pub fn PAC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PAC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PM_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PM_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCLK_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCLK_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RSTC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RSTC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSCCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSCCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC32KCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC32KCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SUPC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SUPC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GCLK_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GCLK_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WDT_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WDT_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RTC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RTC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EIC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EIC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FREQM_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FREQM_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PAC_: u32,
        PM_: u32,
        MCLK_: u32,
        RSTC_: u32,
        OSCCTRL_: u32,
        OSC32KCTRL_: u32,
        SUPC_: u32,
        GCLK_: u32,
        WDT_: u32,
        RTC_: u32,
        EIC_: u32,
        FREQM_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PAC_: u32 = unsafe { ::core::mem::transmute(PAC_) };
            PAC_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PM_: u32 = unsafe { ::core::mem::transmute(PM_) };
            PM_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MCLK_: u32 = unsafe { ::core::mem::transmute(MCLK_) };
            MCLK_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RSTC_: u32 = unsafe { ::core::mem::transmute(RSTC_) };
            RSTC_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OSCCTRL_: u32 = unsafe { ::core::mem::transmute(OSCCTRL_) };
            OSCCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let OSC32KCTRL_: u32 = unsafe { ::core::mem::transmute(OSC32KCTRL_) };
            OSC32KCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SUPC_: u32 = unsafe { ::core::mem::transmute(SUPC_) };
            SUPC_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let GCLK_: u32 = unsafe { ::core::mem::transmute(GCLK_) };
            GCLK_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let WDT_: u32 = unsafe { ::core::mem::transmute(WDT_) };
            WDT_ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let RTC_: u32 = unsafe { ::core::mem::transmute(RTC_) };
            RTC_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EIC_: u32 = unsafe { ::core::mem::transmute(EIC_) };
            EIC_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let FREQM_: u32 = unsafe { ::core::mem::transmute(FREQM_) };
            FREQM_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MCLK_APBAMASK_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MCLK_APBAMASK_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MCLK_APBAMASK_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MCLK_APBAMASK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_APBAMASK_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MCLK_APBAMASK_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_APBAMASK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_APBAMASK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MCLK_APBBMASK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MCLK_APBBMASK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MCLK_APBBMASK_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_MCLK_APBBMASK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MCLK_APBBMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(MCLK_APBBMASK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_APBBMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MCLK_APBBMASK_Type__bindgen_ty_1)
        )
    );
}
impl MCLK_APBBMASK_Type__bindgen_ty_1 {
    #[inline]
    pub fn USB_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USB_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DSU_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DSU_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NVMCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NVMCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PORT_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PORT_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        USB_: u32,
        DSU_: u32,
        NVMCTRL_: u32,
        PORT_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let USB_: u32 = unsafe { ::core::mem::transmute(USB_) };
            USB_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DSU_: u32 = unsafe { ::core::mem::transmute(DSU_) };
            DSU_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let NVMCTRL_: u32 = unsafe { ::core::mem::transmute(NVMCTRL_) };
            NVMCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PORT_: u32 = unsafe { ::core::mem::transmute(PORT_) };
            PORT_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MCLK_APBBMASK_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MCLK_APBBMASK_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MCLK_APBBMASK_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MCLK_APBBMASK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_APBBMASK_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MCLK_APBBMASK_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_APBBMASK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_APBBMASK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MCLK_APBCMASK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MCLK_APBCMASK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MCLK_APBCMASK_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_MCLK_APBCMASK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MCLK_APBCMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(MCLK_APBCMASK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_APBCMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(MCLK_APBCMASK_Type__bindgen_ty_1)
        )
    );
}
impl MCLK_APBCMASK_Type__bindgen_ty_1 {
    #[inline]
    pub fn EVSYS_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVSYS_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM1_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM1_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM2_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM2_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM3_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM3_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM4_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM4_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM5_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM5_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCC0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCC0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC1_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC1_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC2_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC2_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC3_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC3_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ADC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PTC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PTC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLCD_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLCD_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AES_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AES_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRNG_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TRNG_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EVSYS_: u32,
        SERCOM0_: u32,
        SERCOM1_: u32,
        SERCOM2_: u32,
        SERCOM3_: u32,
        SERCOM4_: u32,
        SERCOM5_: u32,
        TCC0_: u32,
        TC0_: u32,
        TC1_: u32,
        TC2_: u32,
        TC3_: u32,
        ADC_: u32,
        AC_: u32,
        PTC_: u32,
        SLCD_: u32,
        AES_: u32,
        TRNG_: u32,
        CCL_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EVSYS_: u32 = unsafe { ::core::mem::transmute(EVSYS_) };
            EVSYS_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SERCOM0_: u32 = unsafe { ::core::mem::transmute(SERCOM0_) };
            SERCOM0_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SERCOM1_: u32 = unsafe { ::core::mem::transmute(SERCOM1_) };
            SERCOM1_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SERCOM2_: u32 = unsafe { ::core::mem::transmute(SERCOM2_) };
            SERCOM2_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SERCOM3_: u32 = unsafe { ::core::mem::transmute(SERCOM3_) };
            SERCOM3_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SERCOM4_: u32 = unsafe { ::core::mem::transmute(SERCOM4_) };
            SERCOM4_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SERCOM5_: u32 = unsafe { ::core::mem::transmute(SERCOM5_) };
            SERCOM5_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let TCC0_: u32 = unsafe { ::core::mem::transmute(TCC0_) };
            TCC0_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let TC0_: u32 = unsafe { ::core::mem::transmute(TC0_) };
            TC0_ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TC1_: u32 = unsafe { ::core::mem::transmute(TC1_) };
            TC1_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let TC2_: u32 = unsafe { ::core::mem::transmute(TC2_) };
            TC2_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let TC3_: u32 = unsafe { ::core::mem::transmute(TC3_) };
            TC3_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ADC_: u32 = unsafe { ::core::mem::transmute(ADC_) };
            ADC_ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let AC_: u32 = unsafe { ::core::mem::transmute(AC_) };
            AC_ as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let PTC_: u32 = unsafe { ::core::mem::transmute(PTC_) };
            PTC_ as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let SLCD_: u32 = unsafe { ::core::mem::transmute(SLCD_) };
            SLCD_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let AES_: u32 = unsafe { ::core::mem::transmute(AES_) };
            AES_ as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let TRNG_: u32 = unsafe { ::core::mem::transmute(TRNG_) };
            TRNG_ as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let CCL_: u32 = unsafe { ::core::mem::transmute(CCL_) };
            CCL_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MCLK_APBCMASK_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MCLK_APBCMASK_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MCLK_APBCMASK_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MCLK_APBCMASK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MCLK_APBCMASK_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MCLK_APBCMASK_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_APBCMASK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MCLK_APBCMASK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Mclk {
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x01 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: MCLK_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: MCLK_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x03 (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: MCLK_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) CPU Clock Division"]
    pub CPUDIV: MCLK_CPUDIV_Type,
    pub Reserved2: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x06 (R/W  8) Backup Clock Division"]
    pub BUPDIV: MCLK_BUPDIV_Type,
    pub Reserved3: [RoReg8; 9usize],
    #[doc = "< \\brief Offset: 0x10 (R/W 32) AHB Mask"]
    pub AHBMASK: MCLK_AHBMASK_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) APBA Mask"]
    pub APBAMASK: MCLK_APBAMASK_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W 32) APBB Mask"]
    pub APBBMASK: MCLK_APBBMASK_Type,
    #[doc = "< \\brief Offset: 0x1C (R/W 32) APBC Mask"]
    pub APBCMASK: MCLK_APBCMASK_Type,
}
#[test]
fn bindgen_test_layout_Mclk() {
    const UNINIT: ::core::mem::MaybeUninit<Mclk> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Mclk>(),
        32usize,
        concat!("Size of: ", stringify!(Mclk))
    );
    assert_eq!(
        ::core::mem::align_of::<Mclk>(),
        4usize,
        concat!("Alignment of ", stringify!(Mclk))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Mclk),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Mclk),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Mclk),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Mclk),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CPUDIV) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Mclk),
            "::",
            stringify!(CPUDIV)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Mclk),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BUPDIV) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Mclk),
            "::",
            stringify!(BUPDIV)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(Mclk),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AHBMASK) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Mclk),
            "::",
            stringify!(AHBMASK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).APBAMASK) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Mclk),
            "::",
            stringify!(APBAMASK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).APBBMASK) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Mclk),
            "::",
            stringify!(APBBMASK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).APBCMASK) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Mclk),
            "::",
            stringify!(APBCMASK)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_POSITION_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MTB_POSITION_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MTB_POSITION_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_MTB_POSITION_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MTB_POSITION_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_POSITION_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_POSITION_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_POSITION_Type__bindgen_ty_1))
    );
}
impl MTB_POSITION_Type__bindgen_ty_1 {
    #[inline]
    pub fn WRAP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WRAP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POINTER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_POINTER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WRAP: u32, POINTER: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WRAP: u32 = unsafe { ::core::mem::transmute(WRAP) };
            WRAP as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let POINTER: u32 = unsafe { ::core::mem::transmute(POINTER) };
            POINTER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MTB_POSITION_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_POSITION_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_POSITION_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_POSITION_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_POSITION_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_POSITION_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_POSITION_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_POSITION_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_MASTER_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MTB_MASTER_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MTB_MASTER_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_MTB_MASTER_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MTB_MASTER_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_MASTER_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_MASTER_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_MASTER_Type__bindgen_ty_1))
    );
}
impl MTB_MASTER_Type__bindgen_ty_1 {
    #[inline]
    pub fn MASK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_MASK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn TSTARTEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TSTARTEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TSTOPEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TSTOPEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SFRWPRIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SFRWPRIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMPRIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RAMPRIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HALTREQ(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HALTREQ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MASK: u32,
        TSTARTEN: u32,
        TSTOPEN: u32,
        SFRWPRIV: u32,
        RAMPRIV: u32,
        HALTREQ: u32,
        EN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let MASK: u32 = unsafe { ::core::mem::transmute(MASK) };
            MASK as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let TSTARTEN: u32 = unsafe { ::core::mem::transmute(TSTARTEN) };
            TSTARTEN as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let TSTOPEN: u32 = unsafe { ::core::mem::transmute(TSTOPEN) };
            TSTOPEN as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SFRWPRIV: u32 = unsafe { ::core::mem::transmute(SFRWPRIV) };
            SFRWPRIV as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let RAMPRIV: u32 = unsafe { ::core::mem::transmute(RAMPRIV) };
            RAMPRIV as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let HALTREQ: u32 = unsafe { ::core::mem::transmute(HALTREQ) };
            HALTREQ as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let EN: u32 = unsafe { ::core::mem::transmute(EN) };
            EN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MTB_MASTER_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_MASTER_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_MASTER_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_MASTER_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_MASTER_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_MASTER_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_MASTER_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_MASTER_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_FLOW_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: MTB_FLOW_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct MTB_FLOW_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_MTB_FLOW_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<MTB_FLOW_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_FLOW_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_FLOW_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_FLOW_Type__bindgen_ty_1))
    );
}
impl MTB_FLOW_Type__bindgen_ty_1 {
    #[inline]
    pub fn AUTOSTOP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AUTOSTOP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AUTOHALT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AUTOHALT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WATERMARK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_WATERMARK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AUTOSTOP: u32,
        AUTOHALT: u32,
        WATERMARK: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AUTOSTOP: u32 = unsafe { ::core::mem::transmute(AUTOSTOP) };
            AUTOSTOP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AUTOHALT: u32 = unsafe { ::core::mem::transmute(AUTOHALT) };
            AUTOHALT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let WATERMARK: u32 = unsafe { ::core::mem::transmute(WATERMARK) };
            WATERMARK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_MTB_FLOW_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_FLOW_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_FLOW_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_FLOW_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_FLOW_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_FLOW_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_FLOW_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_FLOW_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_BASE_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_BASE_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_BASE_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_BASE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_BASE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_BASE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_BASE_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_BASE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_ITCTRL_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_ITCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_ITCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_ITCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_ITCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_ITCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_ITCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_ITCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_CLAIMSET_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_CLAIMSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_CLAIMSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_CLAIMSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_CLAIMSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_CLAIMSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_CLAIMSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_CLAIMSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_CLAIMCLR_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_CLAIMCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_CLAIMCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_CLAIMCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_CLAIMCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_CLAIMCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_CLAIMCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_CLAIMCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_LOCKACCESS_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_LOCKACCESS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_LOCKACCESS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_LOCKACCESS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_LOCKACCESS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_LOCKACCESS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_LOCKACCESS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_LOCKACCESS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_LOCKSTATUS_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_LOCKSTATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_LOCKSTATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_LOCKSTATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_LOCKSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_LOCKSTATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_LOCKSTATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_LOCKSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_AUTHSTATUS_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_AUTHSTATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_AUTHSTATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_AUTHSTATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_AUTHSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_AUTHSTATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_AUTHSTATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_AUTHSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_DEVARCH_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_DEVARCH_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_DEVARCH_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_DEVARCH_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_DEVARCH_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_DEVARCH_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_DEVARCH_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_DEVARCH_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_DEVID_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_DEVID_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_DEVID_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_DEVID_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_DEVID_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_DEVID_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_DEVID_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_DEVID_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_DEVTYPE_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_DEVTYPE_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_DEVTYPE_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_DEVTYPE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_DEVTYPE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_DEVTYPE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_DEVTYPE_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_DEVTYPE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID4_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID4_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_PID4_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_PID4_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID4_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID4_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID4_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID4_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID5_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID5_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_PID5_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_PID5_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID5_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID5_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID5_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID5_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID6_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID6_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_PID6_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_PID6_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID6_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID6_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID6_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID6_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID7_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID7_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_PID7_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_PID7_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID7_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID7_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID7_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID7_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID0_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID0_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_PID0_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_PID0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID0_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID1_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID1_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_PID1_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_PID1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID1_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID2_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID2_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_PID2_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_PID2_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID2_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID2_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID2_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_PID3_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_PID3_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_PID3_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_PID3_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_PID3_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_PID3_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_PID3_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_PID3_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_CID0_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_CID0_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_CID0_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_CID0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_CID0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_CID0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_CID0_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_CID0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_CID1_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_CID1_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_CID1_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_CID1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_CID1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_CID1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_CID1_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_CID1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_CID2_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_CID2_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_CID2_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_CID2_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_CID2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_CID2_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_CID2_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_CID2_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MTB_CID3_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_MTB_CID3_Type() {
    const UNINIT: ::core::mem::MaybeUninit<MTB_CID3_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<MTB_CID3_Type>(),
        4usize,
        concat!("Size of: ", stringify!(MTB_CID3_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<MTB_CID3_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(MTB_CID3_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MTB_CID3_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Mtb {
    #[doc = "< \\brief Offset: 0x000 (R/W 32) MTB Position"]
    pub POSITION: MTB_POSITION_Type,
    #[doc = "< \\brief Offset: 0x004 (R/W 32) MTB Master"]
    pub MASTER: MTB_MASTER_Type,
    #[doc = "< \\brief Offset: 0x008 (R/W 32) MTB Flow"]
    pub FLOW: MTB_FLOW_Type,
    #[doc = "< \\brief Offset: 0x00C (R/  32) MTB Base"]
    pub BASE: MTB_BASE_Type,
    pub Reserved1: [RoReg8; 3824usize],
    #[doc = "< \\brief Offset: 0xF00 (R/W 32) MTB Integration Mode Control"]
    pub ITCTRL: MTB_ITCTRL_Type,
    pub Reserved2: [RoReg8; 156usize],
    #[doc = "< \\brief Offset: 0xFA0 (R/W 32) MTB Claim Set"]
    pub CLAIMSET: MTB_CLAIMSET_Type,
    #[doc = "< \\brief Offset: 0xFA4 (R/W 32) MTB Claim Clear"]
    pub CLAIMCLR: MTB_CLAIMCLR_Type,
    pub Reserved3: [RoReg8; 8usize],
    #[doc = "< \\brief Offset: 0xFB0 (R/W 32) MTB Lock Access"]
    pub LOCKACCESS: MTB_LOCKACCESS_Type,
    #[doc = "< \\brief Offset: 0xFB4 (R/  32) MTB Lock Status"]
    pub LOCKSTATUS: MTB_LOCKSTATUS_Type,
    #[doc = "< \\brief Offset: 0xFB8 (R/  32) MTB Authentication Status"]
    pub AUTHSTATUS: MTB_AUTHSTATUS_Type,
    #[doc = "< \\brief Offset: 0xFBC (R/  32) MTB Device Architecture"]
    pub DEVARCH: MTB_DEVARCH_Type,
    pub Reserved4: [RoReg8; 8usize],
    #[doc = "< \\brief Offset: 0xFC8 (R/  32) MTB Device Configuration"]
    pub DEVID: MTB_DEVID_Type,
    #[doc = "< \\brief Offset: 0xFCC (R/  32) MTB Device Type"]
    pub DEVTYPE: MTB_DEVTYPE_Type,
    #[doc = "< \\brief Offset: 0xFD0 (R/  32) Peripheral Identification 4"]
    pub PID4: MTB_PID4_Type,
    #[doc = "< \\brief Offset: 0xFD4 (R/  32) Peripheral Identification 5"]
    pub PID5: MTB_PID5_Type,
    #[doc = "< \\brief Offset: 0xFD8 (R/  32) Peripheral Identification 6"]
    pub PID6: MTB_PID6_Type,
    #[doc = "< \\brief Offset: 0xFDC (R/  32) Peripheral Identification 7"]
    pub PID7: MTB_PID7_Type,
    #[doc = "< \\brief Offset: 0xFE0 (R/  32) Peripheral Identification 0"]
    pub PID0: MTB_PID0_Type,
    #[doc = "< \\brief Offset: 0xFE4 (R/  32) Peripheral Identification 1"]
    pub PID1: MTB_PID1_Type,
    #[doc = "< \\brief Offset: 0xFE8 (R/  32) Peripheral Identification 2"]
    pub PID2: MTB_PID2_Type,
    #[doc = "< \\brief Offset: 0xFEC (R/  32) Peripheral Identification 3"]
    pub PID3: MTB_PID3_Type,
    #[doc = "< \\brief Offset: 0xFF0 (R/  32) Component Identification 0"]
    pub CID0: MTB_CID0_Type,
    #[doc = "< \\brief Offset: 0xFF4 (R/  32) Component Identification 1"]
    pub CID1: MTB_CID1_Type,
    #[doc = "< \\brief Offset: 0xFF8 (R/  32) Component Identification 2"]
    pub CID2: MTB_CID2_Type,
    #[doc = "< \\brief Offset: 0xFFC (R/  32) Component Identification 3"]
    pub CID3: MTB_CID3_Type,
}
#[test]
fn bindgen_test_layout_Mtb() {
    const UNINIT: ::core::mem::MaybeUninit<Mtb> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Mtb>(),
        4096usize,
        concat!("Size of: ", stringify!(Mtb))
    );
    assert_eq!(
        ::core::mem::align_of::<Mtb>(),
        4usize,
        concat!("Alignment of ", stringify!(Mtb))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).POSITION) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(POSITION)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MASTER) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(MASTER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FLOW) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(FLOW))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BASE) as usize - ptr as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(BASE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ITCTRL) as usize - ptr as usize },
        3840usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(ITCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        3844usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CLAIMSET) as usize - ptr as usize },
        4000usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(CLAIMSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CLAIMCLR) as usize - ptr as usize },
        4004usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(CLAIMCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        4008usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LOCKACCESS) as usize - ptr as usize },
        4016usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(LOCKACCESS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LOCKSTATUS) as usize - ptr as usize },
        4020usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(LOCKSTATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AUTHSTATUS) as usize - ptr as usize },
        4024usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(AUTHSTATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DEVARCH) as usize - ptr as usize },
        4028usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(DEVARCH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        4032usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DEVID) as usize - ptr as usize },
        4040usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(DEVID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DEVTYPE) as usize - ptr as usize },
        4044usize,
        concat!(
            "Offset of field: ",
            stringify!(Mtb),
            "::",
            stringify!(DEVTYPE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID4) as usize - ptr as usize },
        4048usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID4))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID5) as usize - ptr as usize },
        4052usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID5))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID6) as usize - ptr as usize },
        4056usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID6))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID7) as usize - ptr as usize },
        4060usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID7))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID0) as usize - ptr as usize },
        4064usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID0))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID1) as usize - ptr as usize },
        4068usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID2) as usize - ptr as usize },
        4072usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PID3) as usize - ptr as usize },
        4076usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(PID3))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CID0) as usize - ptr as usize },
        4080usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(CID0))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CID1) as usize - ptr as usize },
        4084usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(CID1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CID2) as usize - ptr as usize },
        4088usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(CID2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CID3) as usize - ptr as usize },
        4092usize,
        concat!("Offset of field: ", stringify!(Mtb), "::", stringify!(CID3))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_CTRLA_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(NVMCTRL_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_CTRLA_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn CMD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn CMDEX(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_CMDEX(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CMD: u16, CMDEX: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let CMD: u16 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let CMDEX: u16 = unsafe { ::core::mem::transmute(CMDEX) };
            CMDEX as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<NVMCTRL_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_CTRLA_Type>(),
        2usize,
        concat!("Size of: ", stringify!(NVMCTRL_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_CTRLA_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(NVMCTRL_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(NVMCTRL_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn RWS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_RWS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn MANW(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MANW(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLEEPPRM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SLEEPPRM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FWUP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FWUP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn READMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_READMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CACHEDIS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CACHEDIS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RWS: u32,
        MANW: u32,
        SLEEPPRM: u32,
        FWUP: u32,
        READMODE: u32,
        CACHEDIS: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 4u8, {
            let RWS: u32 = unsafe { ::core::mem::transmute(RWS) };
            RWS as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MANW: u32 = unsafe { ::core::mem::transmute(MANW) };
            MANW as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let SLEEPPRM: u32 = unsafe { ::core::mem::transmute(SLEEPPRM) };
            SLEEPPRM as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let FWUP: u32 = unsafe { ::core::mem::transmute(FWUP) };
            FWUP as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let READMODE: u32 = unsafe { ::core::mem::transmute(READMODE) };
            READMODE as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let CACHEDIS: u32 = unsafe { ::core::mem::transmute(CACHEDIS) };
            CACHEDIS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<NVMCTRL_CTRLB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_CTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(NVMCTRL_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_CTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVMCTRL_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_PARAM_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_PARAM_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_PARAM_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_PARAM_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_PARAM_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(NVMCTRL_PARAM_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_PARAM_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_PARAM_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_PARAM_Type__bindgen_ty_1 {
    #[inline]
    pub fn NVMP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_NVMP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn PSZ(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_PSZ(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RWWEEP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_RWWEEP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(NVMP: u32, PSZ: u32, RWWEEP: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let NVMP: u32 = unsafe { ::core::mem::transmute(NVMP) };
            NVMP as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let PSZ: u32 = unsafe { ::core::mem::transmute(PSZ) };
            PSZ as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let RWWEEP: u32 = unsafe { ::core::mem::transmute(RWWEEP) };
            RWWEEP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_PARAM_Type() {
    const UNINIT: ::core::mem::MaybeUninit<NVMCTRL_PARAM_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_PARAM_Type>(),
        4usize,
        concat!("Size of: ", stringify!(NVMCTRL_PARAM_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_PARAM_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVMCTRL_PARAM_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_PARAM_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_PARAM_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(NVMCTRL_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn READY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_READY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(READY: u8, ERROR: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let READY: u8 = unsafe { ::core::mem::transmute(READY) };
            READY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<NVMCTRL_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(NVMCTRL_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(NVMCTRL_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(NVMCTRL_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn READY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_READY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(READY: u8, ERROR: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let READY: u8 = unsafe { ::core::mem::transmute(READY) };
            READY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<NVMCTRL_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(NVMCTRL_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(NVMCTRL_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(NVMCTRL_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn READY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_READY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(READY: u8, ERROR: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let READY: u8 = unsafe { ::core::mem::transmute(READY) };
            READY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<NVMCTRL_INTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(NVMCTRL_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(NVMCTRL_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(NVMCTRL_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(NVMCTRL_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl NVMCTRL_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn PRM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PRM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LOAD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LOAD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PROGE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PROGE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LOCKE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LOCKE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NVME(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NVME(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SB(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SB(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PRM: u16,
        LOAD: u16,
        PROGE: u16,
        LOCKE: u16,
        NVME: u16,
        SB: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PRM: u16 = unsafe { ::core::mem::transmute(PRM) };
            PRM as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LOAD: u16 = unsafe { ::core::mem::transmute(LOAD) };
            LOAD as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PROGE: u16 = unsafe { ::core::mem::transmute(PROGE) };
            PROGE as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let LOCKE: u16 = unsafe { ::core::mem::transmute(LOCKE) };
            LOCKE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NVME: u16 = unsafe { ::core::mem::transmute(NVME) };
            NVME as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SB: u16 = unsafe { ::core::mem::transmute(SB) };
            SB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<NVMCTRL_STATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_STATUS_Type>(),
        2usize,
        concat!("Size of: ", stringify!(NVMCTRL_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_STATUS_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(NVMCTRL_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(NVMCTRL_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(NVMCTRL_ADDR_Type__bindgen_ty_1))
    );
}
impl NVMCTRL_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 22u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_ADDR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<NVMCTRL_ADDR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(NVMCTRL_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(NVMCTRL_ADDR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union NVMCTRL_LOCK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: NVMCTRL_LOCK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct NVMCTRL_LOCK_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_NVMCTRL_LOCK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_LOCK_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(NVMCTRL_LOCK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_LOCK_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(NVMCTRL_LOCK_Type__bindgen_ty_1))
    );
}
impl NVMCTRL_LOCK_Type__bindgen_ty_1 {
    #[inline]
    pub fn LOCK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_LOCK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LOCK: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let LOCK: u16 = unsafe { ::core::mem::transmute(LOCK) };
            LOCK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_NVMCTRL_LOCK_Type() {
    const UNINIT: ::core::mem::MaybeUninit<NVMCTRL_LOCK_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<NVMCTRL_LOCK_Type>(),
        2usize,
        concat!("Size of: ", stringify!(NVMCTRL_LOCK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<NVMCTRL_LOCK_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(NVMCTRL_LOCK_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_LOCK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NVMCTRL_LOCK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Nvmctrl {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) Control A"]
    pub CTRLA: NVMCTRL_CTRLA_Type,
    pub Reserved1: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Control B"]
    pub CTRLB: NVMCTRL_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) NVM Parameter"]
    pub PARAM: NVMCTRL_PARAM_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: NVMCTRL_INTENCLR_Type,
    pub Reserved2: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x10 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: NVMCTRL_INTENSET_Type,
    pub Reserved3: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x14 (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: NVMCTRL_INTFLAG_Type,
    pub Reserved4: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x18 (R/W 16) Status"]
    pub STATUS: NVMCTRL_STATUS_Type,
    pub Reserved5: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x1C (R/W 32) Address"]
    pub ADDR: NVMCTRL_ADDR_Type,
    #[doc = "< \\brief Offset: 0x20 (R/W 16) Lock Section"]
    pub LOCK: NVMCTRL_LOCK_Type,
}
#[test]
fn bindgen_test_layout_Nvmctrl() {
    const UNINIT: ::core::mem::MaybeUninit<Nvmctrl> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Nvmctrl>(),
        36usize,
        concat!("Size of: ", stringify!(Nvmctrl))
    );
    assert_eq!(
        ::core::mem::align_of::<Nvmctrl>(),
        4usize,
        concat!("Alignment of ", stringify!(Nvmctrl))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PARAM) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(PARAM)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ADDR) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(ADDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LOCK) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Nvmctrl),
            "::",
            stringify!(LOCK)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn XOSCRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XOSCFAIL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCFAIL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC16MRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC16MRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLOOB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLOOB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRCS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRCS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLTO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLTO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLDRTO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLDRTO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        XOSCRDY: u32,
        XOSCFAIL: u32,
        OSC16MRDY: u32,
        DFLLRDY: u32,
        DFLLOOB: u32,
        DFLLLCKF: u32,
        DFLLLCKC: u32,
        DFLLRCS: u32,
        DPLLLCKR: u32,
        DPLLLCKF: u32,
        DPLLLTO: u32,
        DPLLLDRTO: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XOSCRDY: u32 = unsafe { ::core::mem::transmute(XOSCRDY) };
            XOSCRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let XOSCFAIL: u32 = unsafe { ::core::mem::transmute(XOSCFAIL) };
            XOSCFAIL as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OSC16MRDY: u32 = unsafe { ::core::mem::transmute(OSC16MRDY) };
            OSC16MRDY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DFLLRDY: u32 = unsafe { ::core::mem::transmute(DFLLRDY) };
            DFLLRDY as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DFLLOOB: u32 = unsafe { ::core::mem::transmute(DFLLOOB) };
            DFLLOOB as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DFLLLCKF: u32 = unsafe { ::core::mem::transmute(DFLLLCKF) };
            DFLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DFLLLCKC: u32 = unsafe { ::core::mem::transmute(DFLLLCKC) };
            DFLLLCKC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let DFLLRCS: u32 = unsafe { ::core::mem::transmute(DFLLRCS) };
            DFLLRCS as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let DPLLLCKR: u32 = unsafe { ::core::mem::transmute(DPLLLCKR) };
            DPLLLCKR as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let DPLLLCKF: u32 = unsafe { ::core::mem::transmute(DPLLLCKF) };
            DPLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let DPLLLTO: u32 = unsafe { ::core::mem::transmute(DPLLLTO) };
            DPLLLTO as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let DPLLLDRTO: u32 = unsafe { ::core::mem::transmute(DPLLLDRTO) };
            DPLLLDRTO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_INTENCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_INTENCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSCCTRL_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn XOSCRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XOSCFAIL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCFAIL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC16MRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC16MRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLOOB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLOOB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRCS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRCS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLTO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLTO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLDRTO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLDRTO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        XOSCRDY: u32,
        XOSCFAIL: u32,
        OSC16MRDY: u32,
        DFLLRDY: u32,
        DFLLOOB: u32,
        DFLLLCKF: u32,
        DFLLLCKC: u32,
        DFLLRCS: u32,
        DPLLLCKR: u32,
        DPLLLCKF: u32,
        DPLLLTO: u32,
        DPLLLDRTO: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XOSCRDY: u32 = unsafe { ::core::mem::transmute(XOSCRDY) };
            XOSCRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let XOSCFAIL: u32 = unsafe { ::core::mem::transmute(XOSCFAIL) };
            XOSCFAIL as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OSC16MRDY: u32 = unsafe { ::core::mem::transmute(OSC16MRDY) };
            OSC16MRDY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DFLLRDY: u32 = unsafe { ::core::mem::transmute(DFLLRDY) };
            DFLLRDY as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DFLLOOB: u32 = unsafe { ::core::mem::transmute(DFLLOOB) };
            DFLLOOB as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DFLLLCKF: u32 = unsafe { ::core::mem::transmute(DFLLLCKF) };
            DFLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DFLLLCKC: u32 = unsafe { ::core::mem::transmute(DFLLLCKC) };
            DFLLLCKC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let DFLLRCS: u32 = unsafe { ::core::mem::transmute(DFLLRCS) };
            DFLLRCS as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let DPLLLCKR: u32 = unsafe { ::core::mem::transmute(DPLLLCKR) };
            DPLLLCKR as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let DPLLLCKF: u32 = unsafe { ::core::mem::transmute(DPLLLCKF) };
            DPLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let DPLLLTO: u32 = unsafe { ::core::mem::transmute(DPLLLTO) };
            DPLLLTO as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let DPLLLDRTO: u32 = unsafe { ::core::mem::transmute(DPLLLDRTO) };
            DPLLLDRTO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_INTENSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_INTENSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSCCTRL_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn XOSCRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XOSCFAIL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCFAIL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC16MRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC16MRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLOOB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLOOB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRCS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRCS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLTO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLTO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLDRTO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLDRTO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        XOSCRDY: u32,
        XOSCFAIL: u32,
        OSC16MRDY: u32,
        DFLLRDY: u32,
        DFLLOOB: u32,
        DFLLLCKF: u32,
        DFLLLCKC: u32,
        DFLLRCS: u32,
        DPLLLCKR: u32,
        DPLLLCKF: u32,
        DPLLLTO: u32,
        DPLLLDRTO: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XOSCRDY: u32 = unsafe { ::core::mem::transmute(XOSCRDY) };
            XOSCRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let XOSCFAIL: u32 = unsafe { ::core::mem::transmute(XOSCFAIL) };
            XOSCFAIL as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OSC16MRDY: u32 = unsafe { ::core::mem::transmute(OSC16MRDY) };
            OSC16MRDY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DFLLRDY: u32 = unsafe { ::core::mem::transmute(DFLLRDY) };
            DFLLRDY as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DFLLOOB: u32 = unsafe { ::core::mem::transmute(DFLLOOB) };
            DFLLOOB as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DFLLLCKF: u32 = unsafe { ::core::mem::transmute(DFLLLCKF) };
            DFLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DFLLLCKC: u32 = unsafe { ::core::mem::transmute(DFLLLCKC) };
            DFLLLCKC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let DFLLRCS: u32 = unsafe { ::core::mem::transmute(DFLLRCS) };
            DFLLRCS as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let DPLLLCKR: u32 = unsafe { ::core::mem::transmute(DPLLLCKR) };
            DPLLLCKR as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let DPLLLCKF: u32 = unsafe { ::core::mem::transmute(DPLLLCKF) };
            DPLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let DPLLLTO: u32 = unsafe { ::core::mem::transmute(DPLLLTO) };
            DPLLLTO as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let DPLLLDRTO: u32 = unsafe { ::core::mem::transmute(DPLLLDRTO) };
            DPLLLDRTO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_INTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_INTFLAG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_INTFLAG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSCCTRL_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_STATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_STATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn XOSCRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XOSCFAIL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCFAIL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XOSCCKSW(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSCCKSW(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC16MRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC16MRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLOOB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLOOB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLLCKC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLLCKC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFLLRCS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFLLRCS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLCKF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLCKF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLTO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLTO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLLDRTO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DPLLLDRTO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        XOSCRDY: u32,
        XOSCFAIL: u32,
        XOSCCKSW: u32,
        OSC16MRDY: u32,
        DFLLRDY: u32,
        DFLLOOB: u32,
        DFLLLCKF: u32,
        DFLLLCKC: u32,
        DFLLRCS: u32,
        DPLLLCKR: u32,
        DPLLLCKF: u32,
        DPLLTO: u32,
        DPLLLDRTO: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XOSCRDY: u32 = unsafe { ::core::mem::transmute(XOSCRDY) };
            XOSCRDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let XOSCFAIL: u32 = unsafe { ::core::mem::transmute(XOSCFAIL) };
            XOSCFAIL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let XOSCCKSW: u32 = unsafe { ::core::mem::transmute(XOSCCKSW) };
            XOSCCKSW as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OSC16MRDY: u32 = unsafe { ::core::mem::transmute(OSC16MRDY) };
            OSC16MRDY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DFLLRDY: u32 = unsafe { ::core::mem::transmute(DFLLRDY) };
            DFLLRDY as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DFLLOOB: u32 = unsafe { ::core::mem::transmute(DFLLOOB) };
            DFLLOOB as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DFLLLCKF: u32 = unsafe { ::core::mem::transmute(DFLLLCKF) };
            DFLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DFLLLCKC: u32 = unsafe { ::core::mem::transmute(DFLLLCKC) };
            DFLLLCKC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let DFLLRCS: u32 = unsafe { ::core::mem::transmute(DFLLRCS) };
            DFLLRCS as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let DPLLLCKR: u32 = unsafe { ::core::mem::transmute(DPLLLCKR) };
            DPLLLCKR as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let DPLLLCKF: u32 = unsafe { ::core::mem::transmute(DPLLLCKF) };
            DPLLLCKF as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let DPLLTO: u32 = unsafe { ::core::mem::transmute(DPLLTO) };
            DPLLTO as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let DPLLLDRTO: u32 = unsafe { ::core::mem::transmute(DPLLLDRTO) };
            DPLLLDRTO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_STATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_STATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_STATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSCCTRL_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_XOSCCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_XOSCCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_XOSCCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_XOSCCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_XOSCCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(OSCCTRL_XOSCCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_XOSCCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_XOSCCTRL_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_XOSCCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XTALEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_XTALEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CFDEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CFDEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWBEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWBEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GAIN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_GAIN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn AMPGC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AMPGC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STARTUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_STARTUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u16,
        XTALEN: u16,
        CFDEN: u16,
        SWBEN: u16,
        RUNSTDBY: u16,
        ONDEMAND: u16,
        GAIN: u16,
        AMPGC: u16,
        STARTUP: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let XTALEN: u16 = unsafe { ::core::mem::transmute(XTALEN) };
            XTALEN as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CFDEN: u16 = unsafe { ::core::mem::transmute(CFDEN) };
            CFDEN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SWBEN: u16 = unsafe { ::core::mem::transmute(SWBEN) };
            SWBEN as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u16 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u16 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let GAIN: u16 = unsafe { ::core::mem::transmute(GAIN) };
            GAIN as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AMPGC: u16 = unsafe { ::core::mem::transmute(AMPGC) };
            AMPGC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let STARTUP: u16 = unsafe { ::core::mem::transmute(STARTUP) };
            STARTUP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_XOSCCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_XOSCCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_XOSCCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(OSCCTRL_XOSCCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_XOSCCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(OSCCTRL_XOSCCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_XOSCCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_XOSCCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_CFDPRESC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_CFDPRESC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_CFDPRESC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_CFDPRESC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_CFDPRESC_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(OSCCTRL_CFDPRESC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_CFDPRESC_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_CFDPRESC_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_CFDPRESC_Type__bindgen_ty_1 {
    #[inline]
    pub fn CFDPRESC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_CFDPRESC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CFDPRESC: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let CFDPRESC: u8 = unsafe { ::core::mem::transmute(CFDPRESC) };
            CFDPRESC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_CFDPRESC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_CFDPRESC_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_CFDPRESC_Type>(),
        1usize,
        concat!("Size of: ", stringify!(OSCCTRL_CFDPRESC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_CFDPRESC_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(OSCCTRL_CFDPRESC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_CFDPRESC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_CFDPRESC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(OSCCTRL_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_EVCTRL_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn CFDEO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CFDEO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CFDEO: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CFDEO: u8 = unsafe { ::core::mem::transmute(CFDEO) };
            CFDEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_EVCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_EVCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(OSCCTRL_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_EVCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(OSCCTRL_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_OSC16MCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_OSC16MCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_OSC16MCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_OSC16MCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_OSC16MCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(OSCCTRL_OSC16MCTRL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_OSC16MCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_OSC16MCTRL_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_OSC16MCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FSEL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_FSEL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u8,
        FSEL: u8,
        RUNSTDBY: u8,
        ONDEMAND: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let FSEL: u8 = unsafe { ::core::mem::transmute(FSEL) };
            FSEL as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u8 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u8 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_OSC16MCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_OSC16MCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_OSC16MCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(OSCCTRL_OSC16MCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_OSC16MCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(OSCCTRL_OSC16MCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_OSC16MCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_OSC16MCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_DFLLCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_DFLLCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_DFLLCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_DFLLCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DFLLCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(OSCCTRL_DFLLCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DFLLCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_DFLLCTRL_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_DFLLCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_STABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LLAW(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LLAW(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn USBCRM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_USBCRM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCDIS(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CCDIS(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QLDIS(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_QLDIS(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BPLCKC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BPLCKC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAITLOCK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WAITLOCK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u16,
        MODE: u16,
        STABLE: u16,
        LLAW: u16,
        USBCRM: u16,
        RUNSTDBY: u16,
        ONDEMAND: u16,
        CCDIS: u16,
        QLDIS: u16,
        BPLCKC: u16,
        WAITLOCK: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MODE: u16 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let STABLE: u16 = unsafe { ::core::mem::transmute(STABLE) };
            STABLE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let LLAW: u16 = unsafe { ::core::mem::transmute(LLAW) };
            LLAW as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let USBCRM: u16 = unsafe { ::core::mem::transmute(USBCRM) };
            USBCRM as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u16 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u16 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CCDIS: u16 = unsafe { ::core::mem::transmute(CCDIS) };
            CCDIS as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let QLDIS: u16 = unsafe { ::core::mem::transmute(QLDIS) };
            QLDIS as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let BPLCKC: u16 = unsafe { ::core::mem::transmute(BPLCKC) };
            BPLCKC as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let WAITLOCK: u16 = unsafe { ::core::mem::transmute(WAITLOCK) };
            WAITLOCK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_DFLLCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_DFLLCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DFLLCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(OSCCTRL_DFLLCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DFLLCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(OSCCTRL_DFLLCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DFLLCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DFLLCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_DFLLVAL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_DFLLVAL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_DFLLVAL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_DFLLVAL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DFLLVAL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_DFLLVAL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DFLLVAL_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_DFLLVAL_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_DFLLVAL_Type__bindgen_ty_1 {
    #[inline]
    pub fn FINE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_FINE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn COARSE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_COARSE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn DIFF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_DIFF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FINE: u32,
        COARSE: u32,
        DIFF: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let FINE: u32 = unsafe { ::core::mem::transmute(FINE) };
            FINE as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let COARSE: u32 = unsafe { ::core::mem::transmute(COARSE) };
            COARSE as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let DIFF: u32 = unsafe { ::core::mem::transmute(DIFF) };
            DIFF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_DFLLVAL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_DFLLVAL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DFLLVAL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_DFLLVAL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DFLLVAL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSCCTRL_DFLLVAL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DFLLVAL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DFLLVAL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_DFLLMUL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_DFLLMUL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_DFLLMUL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_DFLLMUL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DFLLMUL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_DFLLMUL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DFLLMUL_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_DFLLMUL_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_DFLLMUL_Type__bindgen_ty_1 {
    #[inline]
    pub fn MUL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_MUL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn FSTEP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_FSTEP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn CSTEP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_CSTEP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MUL: u32, FSTEP: u32, CSTEP: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let MUL: u32 = unsafe { ::core::mem::transmute(MUL) };
            MUL as u64
        });
        __bindgen_bitfield_unit.set(16usize, 10u8, {
            let FSTEP: u32 = unsafe { ::core::mem::transmute(FSTEP) };
            FSTEP as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let CSTEP: u32 = unsafe { ::core::mem::transmute(CSTEP) };
            CSTEP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_DFLLMUL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_DFLLMUL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DFLLMUL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_DFLLMUL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DFLLMUL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSCCTRL_DFLLMUL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DFLLMUL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DFLLMUL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_DFLLSYNC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_DFLLSYNC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_DFLLSYNC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_DFLLSYNC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DFLLSYNC_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(OSCCTRL_DFLLSYNC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DFLLSYNC_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_DFLLSYNC_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_DFLLSYNC_Type__bindgen_ty_1 {
    #[inline]
    pub fn READREQ(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_READREQ(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(READREQ: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let READREQ: u8 = unsafe { ::core::mem::transmute(READREQ) };
            READREQ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_DFLLSYNC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_DFLLSYNC_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DFLLSYNC_Type>(),
        1usize,
        concat!("Size of: ", stringify!(OSCCTRL_DFLLSYNC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DFLLSYNC_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(OSCCTRL_DFLLSYNC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DFLLSYNC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DFLLSYNC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_DPLLCTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_DPLLCTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_DPLLCTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_DPLLCTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DPLLCTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(OSCCTRL_DPLLCTRLA_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DPLLCTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_DPLLCTRLA_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_DPLLCTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u8,
        RUNSTDBY: u8,
        ONDEMAND: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u8 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u8 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_DPLLCTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_DPLLCTRLA_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DPLLCTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(OSCCTRL_DPLLCTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DPLLCTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(OSCCTRL_DPLLCTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DPLLCTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DPLLCTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_DPLLRATIO_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_DPLLRATIO_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_DPLLRATIO_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_DPLLRATIO_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DPLLRATIO_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(OSCCTRL_DPLLRATIO_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DPLLRATIO_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_DPLLRATIO_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_DPLLRATIO_Type__bindgen_ty_1 {
    #[inline]
    pub fn LDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_LDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn LDRFRAC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LDRFRAC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LDR: u32, LDRFRAC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let LDR: u32 = unsafe { ::core::mem::transmute(LDR) };
            LDR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let LDRFRAC: u32 = unsafe { ::core::mem::transmute(LDRFRAC) };
            LDRFRAC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_DPLLRATIO_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_DPLLRATIO_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DPLLRATIO_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_DPLLRATIO_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DPLLRATIO_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSCCTRL_DPLLRATIO_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DPLLRATIO_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DPLLRATIO_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_DPLLCTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_DPLLCTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_DPLLCTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_DPLLCTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DPLLCTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(OSCCTRL_DPLLCTRLB_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DPLLCTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_DPLLCTRLB_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_DPLLCTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn FILTER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_FILTER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LPEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LPEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn REFCLK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_REFCLK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LTIME(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_LTIME(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn LBYPASS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LBYPASS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_DIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FILTER: u32,
        LPEN: u32,
        WUF: u32,
        REFCLK: u32,
        LTIME: u32,
        LBYPASS: u32,
        DIV: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let FILTER: u32 = unsafe { ::core::mem::transmute(FILTER) };
            FILTER as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let LPEN: u32 = unsafe { ::core::mem::transmute(LPEN) };
            LPEN as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WUF: u32 = unsafe { ::core::mem::transmute(WUF) };
            WUF as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let REFCLK: u32 = unsafe { ::core::mem::transmute(REFCLK) };
            REFCLK as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let LTIME: u32 = unsafe { ::core::mem::transmute(LTIME) };
            LTIME as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let LBYPASS: u32 = unsafe { ::core::mem::transmute(LBYPASS) };
            LBYPASS as u64
        });
        __bindgen_bitfield_unit.set(16usize, 11u8, {
            let DIV: u32 = unsafe { ::core::mem::transmute(DIV) };
            DIV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_DPLLCTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_DPLLCTRLB_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DPLLCTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSCCTRL_DPLLCTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DPLLCTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSCCTRL_DPLLCTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DPLLCTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DPLLCTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_DPLLPRESC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_DPLLPRESC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_DPLLPRESC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_DPLLPRESC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DPLLPRESC_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(OSCCTRL_DPLLPRESC_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DPLLPRESC_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_DPLLPRESC_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_DPLLPRESC_Type__bindgen_ty_1 {
    #[inline]
    pub fn PRESC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_PRESC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PRESC: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let PRESC: u8 = unsafe { ::core::mem::transmute(PRESC) };
            PRESC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_DPLLPRESC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_DPLLPRESC_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DPLLPRESC_Type>(),
        1usize,
        concat!("Size of: ", stringify!(OSCCTRL_DPLLPRESC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DPLLPRESC_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(OSCCTRL_DPLLPRESC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DPLLPRESC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DPLLPRESC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_DPLLSYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_DPLLSYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_DPLLSYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_DPLLSYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DPLLSYNCBUSY_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(OSCCTRL_DPLLSYNCBUSY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DPLLSYNCBUSY_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_DPLLSYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_DPLLSYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLRATIO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DPLLRATIO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DPLLPRESC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DPLLPRESC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u8,
        DPLLRATIO: u8,
        DPLLPRESC: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DPLLRATIO: u8 = unsafe { ::core::mem::transmute(DPLLRATIO) };
            DPLLRATIO as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DPLLPRESC: u8 = unsafe { ::core::mem::transmute(DPLLPRESC) };
            DPLLPRESC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_DPLLSYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_DPLLSYNCBUSY_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DPLLSYNCBUSY_Type>(),
        1usize,
        concat!("Size of: ", stringify!(OSCCTRL_DPLLSYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DPLLSYNCBUSY_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(OSCCTRL_DPLLSYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DPLLSYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DPLLSYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSCCTRL_DPLLSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSCCTRL_DPLLSTATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSCCTRL_DPLLSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_OSCCTRL_DPLLSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DPLLSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(OSCCTRL_DPLLSTATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DPLLSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OSCCTRL_DPLLSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl OSCCTRL_DPLLSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn LOCK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LOCK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CLKRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LOCK: u8, CLKRDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LOCK: u8 = unsafe { ::core::mem::transmute(LOCK) };
            LOCK as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CLKRDY: u8 = unsafe { ::core::mem::transmute(CLKRDY) };
            CLKRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSCCTRL_DPLLSTATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSCCTRL_DPLLSTATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSCCTRL_DPLLSTATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(OSCCTRL_DPLLSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSCCTRL_DPLLSTATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(OSCCTRL_DPLLSTATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DPLLSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSCCTRL_DPLLSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Oscctrl {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Interrupt Enable Clear"]
    pub INTENCLR: OSCCTRL_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Interrupt Enable Set"]
    pub INTENSET: OSCCTRL_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) Interrupt Flag Status and Clear"]
    pub INTFLAG: OSCCTRL_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0C (R/  32) Power and Clocks Status"]
    pub STATUS: OSCCTRL_STATUS_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 16) External Multipurpose Crystal Oscillator (XOSC) Control"]
    pub XOSCCTRL: OSCCTRL_XOSCCTRL_Type,
    #[doc = "< \\brief Offset: 0x12 (R/W  8) Cloc Failure Detector Prescaler"]
    pub CFDPRESC: OSCCTRL_CFDPRESC_Type,
    #[doc = "< \\brief Offset: 0x13 (R/W  8) Event Control"]
    pub EVCTRL: OSCCTRL_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W  8) 16MHz Internal Oscillator (OSC16M) Control"]
    pub OSC16MCTRL: OSCCTRL_OSC16MCTRL_Type,
    pub Reserved1: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x18 (R/W 16) DFLL48M Control"]
    pub DFLLCTRL: OSCCTRL_DFLLCTRL_Type,
    pub Reserved2: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x1C (R/W 32) DFLL48M Value"]
    pub DFLLVAL: OSCCTRL_DFLLVAL_Type,
    #[doc = "< \\brief Offset: 0x20 (R/W 32) DFLL48M Multiplier"]
    pub DFLLMUL: OSCCTRL_DFLLMUL_Type,
    #[doc = "< \\brief Offset: 0x24 (R/W  8) DFLL48M Synchronization"]
    pub DFLLSYNC: OSCCTRL_DFLLSYNC_Type,
    pub Reserved3: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x28 (R/W  8) DPLL Control"]
    pub DPLLCTRLA: OSCCTRL_DPLLCTRLA_Type,
    pub Reserved4: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x2C (R/W 32) DPLL Ratio Control"]
    pub DPLLRATIO: OSCCTRL_DPLLRATIO_Type,
    #[doc = "< \\brief Offset: 0x30 (R/W 32) Digital Core Configuration"]
    pub DPLLCTRLB: OSCCTRL_DPLLCTRLB_Type,
    #[doc = "< \\brief Offset: 0x34 (R/W  8) DPLL Prescaler"]
    pub DPLLPRESC: OSCCTRL_DPLLPRESC_Type,
    pub Reserved5: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x38 (R/   8) DPLL Synchronization Busy"]
    pub DPLLSYNCBUSY: OSCCTRL_DPLLSYNCBUSY_Type,
    pub Reserved6: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x3C (R/   8) DPLL Status"]
    pub DPLLSTATUS: OSCCTRL_DPLLSTATUS_Type,
}
#[test]
fn bindgen_test_layout_Oscctrl() {
    const UNINIT: ::core::mem::MaybeUninit<Oscctrl> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Oscctrl>(),
        64usize,
        concat!("Size of: ", stringify!(Oscctrl))
    );
    assert_eq!(
        ::core::mem::align_of::<Oscctrl>(),
        4usize,
        concat!("Alignment of ", stringify!(Oscctrl))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XOSCCTRL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(XOSCCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFDPRESC) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(CFDPRESC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OSC16MCTRL) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(OSC16MCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DFLLCTRL) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(DFLLCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DFLLVAL) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(DFLLVAL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DFLLMUL) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(DFLLMUL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DFLLSYNC) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(DFLLSYNC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DPLLCTRLA) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(DPLLCTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DPLLRATIO) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(DPLLRATIO)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DPLLCTRLB) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(DPLLCTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DPLLPRESC) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(DPLLPRESC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        53usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DPLLSYNCBUSY) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(DPLLSYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DPLLSTATUS) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Oscctrl),
            "::",
            stringify!(DPLLSTATUS)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSC32KCTRL_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSC32KCTRL_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSC32KCTRL_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(OSC32KCTRL_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSC32KCTRL_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl OSC32KCTRL_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn XOSC32KRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSC32KRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKFAIL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CLKFAIL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(XOSC32KRDY: u32, CLKFAIL: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XOSC32KRDY: u32 = unsafe { ::core::mem::transmute(XOSC32KRDY) };
            XOSC32KRDY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CLKFAIL: u32 = unsafe { ::core::mem::transmute(CLKFAIL) };
            CLKFAIL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSC32KCTRL_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_INTENCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSC32KCTRL_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_INTENCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSC32KCTRL_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSC32KCTRL_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSC32KCTRL_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSC32KCTRL_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(OSC32KCTRL_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSC32KCTRL_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl OSC32KCTRL_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn XOSC32KRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSC32KRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKFAIL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CLKFAIL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(XOSC32KRDY: u32, CLKFAIL: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XOSC32KRDY: u32 = unsafe { ::core::mem::transmute(XOSC32KRDY) };
            XOSC32KRDY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CLKFAIL: u32 = unsafe { ::core::mem::transmute(CLKFAIL) };
            CLKFAIL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSC32KCTRL_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_INTENSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSC32KCTRL_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_INTENSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSC32KCTRL_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSC32KCTRL_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSC32KCTRL_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSC32KCTRL_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(OSC32KCTRL_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSC32KCTRL_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl OSC32KCTRL_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn XOSC32KRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSC32KRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKFAIL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CLKFAIL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(XOSC32KRDY: u32, CLKFAIL: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XOSC32KRDY: u32 = unsafe { ::core::mem::transmute(XOSC32KRDY) };
            XOSC32KRDY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CLKFAIL: u32 = unsafe { ::core::mem::transmute(CLKFAIL) };
            CLKFAIL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSC32KCTRL_INTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_INTFLAG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSC32KCTRL_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_INTFLAG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSC32KCTRL_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSC32KCTRL_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSC32KCTRL_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSC32KCTRL_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_STATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(OSC32KCTRL_STATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_STATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSC32KCTRL_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl OSC32KCTRL_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn XOSC32KRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XOSC32KRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKFAIL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CLKFAIL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKSW(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CLKSW(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        XOSC32KRDY: u32,
        CLKFAIL: u32,
        CLKSW: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XOSC32KRDY: u32 = unsafe { ::core::mem::transmute(XOSC32KRDY) };
            XOSC32KRDY as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CLKFAIL: u32 = unsafe { ::core::mem::transmute(CLKFAIL) };
            CLKFAIL as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CLKSW: u32 = unsafe { ::core::mem::transmute(CLKSW) };
            CLKSW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSC32KCTRL_STATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_STATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSC32KCTRL_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_STATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSC32KCTRL_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSC32KCTRL_RTCCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSC32KCTRL_RTCCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSC32KCTRL_RTCCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_RTCCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_RTCCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(OSC32KCTRL_RTCCTRL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_RTCCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OSC32KCTRL_RTCCTRL_Type__bindgen_ty_1)
        )
    );
}
impl OSC32KCTRL_RTCCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn RTCSEL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_RTCSEL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(RTCSEL: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let RTCSEL: u8 = unsafe { ::core::mem::transmute(RTCSEL) };
            RTCSEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_RTCCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSC32KCTRL_RTCCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_RTCCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(OSC32KCTRL_RTCCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_RTCCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(OSC32KCTRL_RTCCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_RTCCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_RTCCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSC32KCTRL_SLCDCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSC32KCTRL_SLCDCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSC32KCTRL_SLCDCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_SLCDCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_SLCDCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(OSC32KCTRL_SLCDCTRL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_SLCDCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OSC32KCTRL_SLCDCTRL_Type__bindgen_ty_1)
        )
    );
}
impl OSC32KCTRL_SLCDCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SLCDSEL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SLCDSEL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SLCDSEL: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SLCDSEL: u8 = unsafe { ::core::mem::transmute(SLCDSEL) };
            SLCDSEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_SLCDCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSC32KCTRL_SLCDCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_SLCDCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(OSC32KCTRL_SLCDCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_SLCDCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(OSC32KCTRL_SLCDCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_SLCDCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_SLCDCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSC32KCTRL_XOSC32K_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSC32KCTRL_XOSC32K_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct OSC32KCTRL_XOSC32K_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_XOSC32K_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_XOSC32K_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(OSC32KCTRL_XOSC32K_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_XOSC32K_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(OSC32KCTRL_XOSC32K_Type__bindgen_ty_1)
        )
    );
}
impl OSC32KCTRL_XOSC32K_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XTALEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_XTALEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EN32K(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EN32K(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EN1K(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EN1K(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STARTUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_STARTUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn WRTLOCK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WRTLOCK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u16,
        XTALEN: u16,
        EN32K: u16,
        EN1K: u16,
        RUNSTDBY: u16,
        ONDEMAND: u16,
        STARTUP: u16,
        WRTLOCK: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let XTALEN: u16 = unsafe { ::core::mem::transmute(XTALEN) };
            XTALEN as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EN32K: u16 = unsafe { ::core::mem::transmute(EN32K) };
            EN32K as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EN1K: u16 = unsafe { ::core::mem::transmute(EN1K) };
            EN1K as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u16 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u16 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let STARTUP: u16 = unsafe { ::core::mem::transmute(STARTUP) };
            STARTUP as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let WRTLOCK: u16 = unsafe { ::core::mem::transmute(WRTLOCK) };
            WRTLOCK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_XOSC32K_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSC32KCTRL_XOSC32K_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_XOSC32K_Type>(),
        2usize,
        concat!("Size of: ", stringify!(OSC32KCTRL_XOSC32K_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_XOSC32K_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(OSC32KCTRL_XOSC32K_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_XOSC32K_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_XOSC32K_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSC32KCTRL_CFDCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSC32KCTRL_CFDCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSC32KCTRL_CFDCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_CFDCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_CFDCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(OSC32KCTRL_CFDCTRL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_CFDCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OSC32KCTRL_CFDCTRL_Type__bindgen_ty_1)
        )
    );
}
impl OSC32KCTRL_CFDCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn CFDEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CFDEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWBACK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWBACK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CFDPRESC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CFDPRESC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CFDEN: u8,
        SWBACK: u8,
        CFDPRESC: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CFDEN: u8 = unsafe { ::core::mem::transmute(CFDEN) };
            CFDEN as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SWBACK: u8 = unsafe { ::core::mem::transmute(SWBACK) };
            SWBACK as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CFDPRESC: u8 = unsafe { ::core::mem::transmute(CFDPRESC) };
            CFDPRESC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_CFDCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSC32KCTRL_CFDCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_CFDCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(OSC32KCTRL_CFDCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_CFDCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(OSC32KCTRL_CFDCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_CFDCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_CFDCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSC32KCTRL_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSC32KCTRL_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct OSC32KCTRL_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(OSC32KCTRL_EVCTRL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(OSC32KCTRL_EVCTRL_Type__bindgen_ty_1)
        )
    );
}
impl OSC32KCTRL_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn CFDEO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CFDEO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CFDEO: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CFDEO: u8 = unsafe { ::core::mem::transmute(CFDEO) };
            CFDEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSC32KCTRL_EVCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_EVCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(OSC32KCTRL_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_EVCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(OSC32KCTRL_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union OSC32KCTRL_OSCULP32K_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: OSC32KCTRL_OSCULP32K_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct OSC32KCTRL_OSCULP32K_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_OSCULP32K_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_OSCULP32K_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(OSC32KCTRL_OSCULP32K_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_OSCULP32K_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(OSC32KCTRL_OSCULP32K_Type__bindgen_ty_1)
        )
    );
}
impl OSC32KCTRL_OSCULP32K_Type__bindgen_ty_1 {
    #[inline]
    pub fn EN32K(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EN32K(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EN1K(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EN1K(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CALIB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_CALIB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn WRTLOCK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WRTLOCK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EN32K: u32,
        EN1K: u32,
        CALIB: u32,
        WRTLOCK: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EN32K: u32 = unsafe { ::core::mem::transmute(EN32K) };
            EN32K as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EN1K: u32 = unsafe { ::core::mem::transmute(EN1K) };
            EN1K as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let CALIB: u32 = unsafe { ::core::mem::transmute(CALIB) };
            CALIB as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let WRTLOCK: u32 = unsafe { ::core::mem::transmute(WRTLOCK) };
            WRTLOCK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_OSC32KCTRL_OSCULP32K_Type() {
    const UNINIT: ::core::mem::MaybeUninit<OSC32KCTRL_OSCULP32K_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<OSC32KCTRL_OSCULP32K_Type>(),
        4usize,
        concat!("Size of: ", stringify!(OSC32KCTRL_OSCULP32K_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<OSC32KCTRL_OSCULP32K_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(OSC32KCTRL_OSCULP32K_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_OSCULP32K_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(OSC32KCTRL_OSCULP32K_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Osc32kctrl {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Interrupt Enable Clear"]
    pub INTENCLR: OSC32KCTRL_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Interrupt Enable Set"]
    pub INTENSET: OSC32KCTRL_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) Interrupt Flag Status and Clear"]
    pub INTFLAG: OSC32KCTRL_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0C (R/  32) Power and Clocks Status"]
    pub STATUS: OSC32KCTRL_STATUS_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W  8) RTC Clock Selection"]
    pub RTCCTRL: OSC32KCTRL_RTCCTRL_Type,
    #[doc = "< \\brief Offset: 0x11 (R/W  8) SLCD Clock Selection"]
    pub SLCDCTRL: OSC32KCTRL_SLCDCTRL_Type,
    pub Reserved1: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x14 (R/W 16) 32kHz External Crystal Oscillator (XOSC32K) Control"]
    pub XOSC32K: OSC32KCTRL_XOSC32K_Type,
    #[doc = "< \\brief Offset: 0x16 (R/W  8) Clock Failure Detector Control"]
    pub CFDCTRL: OSC32KCTRL_CFDCTRL_Type,
    #[doc = "< \\brief Offset: 0x17 (R/W  8) Event Control"]
    pub EVCTRL: OSC32KCTRL_EVCTRL_Type,
    pub Reserved2: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x1C (R/W 32) 32kHz Ultra Low Power Internal Oscillator (OSCULP32K) Control"]
    pub OSCULP32K: OSC32KCTRL_OSCULP32K_Type,
}
#[test]
fn bindgen_test_layout_Osc32kctrl() {
    const UNINIT: ::core::mem::MaybeUninit<Osc32kctrl> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Osc32kctrl>(),
        32usize,
        concat!("Size of: ", stringify!(Osc32kctrl))
    );
    assert_eq!(
        ::core::mem::align_of::<Osc32kctrl>(),
        4usize,
        concat!("Alignment of ", stringify!(Osc32kctrl))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Osc32kctrl),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Osc32kctrl),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Osc32kctrl),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Osc32kctrl),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RTCCTRL) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Osc32kctrl),
            "::",
            stringify!(RTCCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SLCDCTRL) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(Osc32kctrl),
            "::",
            stringify!(SLCDCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(Osc32kctrl),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XOSC32K) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Osc32kctrl),
            "::",
            stringify!(XOSC32K)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CFDCTRL) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(Osc32kctrl),
            "::",
            stringify!(CFDCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(Osc32kctrl),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Osc32kctrl),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OSCULP32K) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Osc32kctrl),
            "::",
            stringify!(OSCULP32K)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_WRCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_WRCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PAC_WRCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PAC_WRCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_WRCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_WRCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_WRCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_WRCTRL_Type__bindgen_ty_1))
    );
}
impl PAC_WRCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn PERID(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_PERID(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn KEY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_KEY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PERID: u32, KEY: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let PERID: u32 = unsafe { ::core::mem::transmute(PERID) };
            PERID as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let KEY: u32 = unsafe { ::core::mem::transmute(KEY) };
            KEY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_WRCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PAC_WRCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PAC_WRCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_WRCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_WRCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_WRCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_WRCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_WRCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PAC_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_PAC_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PAC_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PAC_EVCTRL_Type__bindgen_ty_1))
    );
}
impl PAC_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn ERREO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERREO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ERREO: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ERREO: u8 = unsafe { ::core::mem::transmute(ERREO) };
            ERREO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PAC_EVCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PAC_EVCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PAC_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_EVCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PAC_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PAC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_PAC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PAC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PAC_INTENCLR_Type__bindgen_ty_1))
    );
}
impl PAC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ERR: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ERR: u8 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PAC_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PAC_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PAC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PAC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PAC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_PAC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PAC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PAC_INTENSET_Type__bindgen_ty_1))
    );
}
impl PAC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn ERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ERR: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ERR: u8 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PAC_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PAC_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PAC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PAC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_INTFLAGAHB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_INTFLAGAHB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PAC_INTFLAGAHB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PAC_INTFLAGAHB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_INTFLAGAHB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_INTFLAGAHB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_INTFLAGAHB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(PAC_INTFLAGAHB_Type__bindgen_ty_1)
        )
    );
}
impl PAC_INTFLAGAHB_Type__bindgen_ty_1 {
    #[inline]
    pub fn FLASH_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FLASH_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HSRAMCM0P_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HSRAMCM0P_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HSRAMDSU_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HSRAMDSU_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HPB1_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HPB1_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HPB0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HPB0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HPB2_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HPB2_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HSRAMDMAC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HSRAMDMAC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FLASH_: u32,
        HSRAMCM0P_: u32,
        HSRAMDSU_: u32,
        HPB1_: u32,
        HPB0_: u32,
        HPB2_: u32,
        HSRAMDMAC_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FLASH_: u32 = unsafe { ::core::mem::transmute(FLASH_) };
            FLASH_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HSRAMCM0P_: u32 = unsafe { ::core::mem::transmute(HSRAMCM0P_) };
            HSRAMCM0P_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HSRAMDSU_: u32 = unsafe { ::core::mem::transmute(HSRAMDSU_) };
            HSRAMDSU_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let HPB1_: u32 = unsafe { ::core::mem::transmute(HPB1_) };
            HPB1_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HPB0_: u32 = unsafe { ::core::mem::transmute(HPB0_) };
            HPB0_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let HPB2_: u32 = unsafe { ::core::mem::transmute(HPB2_) };
            HPB2_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let HSRAMDMAC_: u32 = unsafe { ::core::mem::transmute(HSRAMDMAC_) };
            HSRAMDMAC_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_INTFLAGAHB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PAC_INTFLAGAHB_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PAC_INTFLAGAHB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_INTFLAGAHB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_INTFLAGAHB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_INTFLAGAHB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_INTFLAGAHB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_INTFLAGAHB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_INTFLAGA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_INTFLAGA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PAC_INTFLAGA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PAC_INTFLAGA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_INTFLAGA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_INTFLAGA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_INTFLAGA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_INTFLAGA_Type__bindgen_ty_1))
    );
}
impl PAC_INTFLAGA_Type__bindgen_ty_1 {
    #[inline]
    pub fn PAC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PAC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PM_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PM_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCLK_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCLK_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RSTC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RSTC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSCCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSCCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC32KCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC32KCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SUPC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SUPC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GCLK_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GCLK_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WDT_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WDT_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RTC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RTC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EIC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EIC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FREQM_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FREQM_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PAC_: u32,
        PM_: u32,
        MCLK_: u32,
        RSTC_: u32,
        OSCCTRL_: u32,
        OSC32KCTRL_: u32,
        SUPC_: u32,
        GCLK_: u32,
        WDT_: u32,
        RTC_: u32,
        EIC_: u32,
        FREQM_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PAC_: u32 = unsafe { ::core::mem::transmute(PAC_) };
            PAC_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PM_: u32 = unsafe { ::core::mem::transmute(PM_) };
            PM_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MCLK_: u32 = unsafe { ::core::mem::transmute(MCLK_) };
            MCLK_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RSTC_: u32 = unsafe { ::core::mem::transmute(RSTC_) };
            RSTC_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OSCCTRL_: u32 = unsafe { ::core::mem::transmute(OSCCTRL_) };
            OSCCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let OSC32KCTRL_: u32 = unsafe { ::core::mem::transmute(OSC32KCTRL_) };
            OSC32KCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SUPC_: u32 = unsafe { ::core::mem::transmute(SUPC_) };
            SUPC_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let GCLK_: u32 = unsafe { ::core::mem::transmute(GCLK_) };
            GCLK_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let WDT_: u32 = unsafe { ::core::mem::transmute(WDT_) };
            WDT_ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let RTC_: u32 = unsafe { ::core::mem::transmute(RTC_) };
            RTC_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EIC_: u32 = unsafe { ::core::mem::transmute(EIC_) };
            EIC_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let FREQM_: u32 = unsafe { ::core::mem::transmute(FREQM_) };
            FREQM_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_INTFLAGA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PAC_INTFLAGA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PAC_INTFLAGA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_INTFLAGA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_INTFLAGA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_INTFLAGA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_INTFLAGA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_INTFLAGA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_INTFLAGB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_INTFLAGB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PAC_INTFLAGB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PAC_INTFLAGB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_INTFLAGB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_INTFLAGB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_INTFLAGB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_INTFLAGB_Type__bindgen_ty_1))
    );
}
impl PAC_INTFLAGB_Type__bindgen_ty_1 {
    #[inline]
    pub fn USB_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USB_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DSU_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DSU_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NVMCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NVMCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PORT_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PORT_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DMAC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DMAC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MTB_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MTB_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        USB_: u32,
        DSU_: u32,
        NVMCTRL_: u32,
        PORT_: u32,
        DMAC_: u32,
        MTB_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let USB_: u32 = unsafe { ::core::mem::transmute(USB_) };
            USB_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DSU_: u32 = unsafe { ::core::mem::transmute(DSU_) };
            DSU_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let NVMCTRL_: u32 = unsafe { ::core::mem::transmute(NVMCTRL_) };
            NVMCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PORT_: u32 = unsafe { ::core::mem::transmute(PORT_) };
            PORT_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DMAC_: u32 = unsafe { ::core::mem::transmute(DMAC_) };
            DMAC_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MTB_: u32 = unsafe { ::core::mem::transmute(MTB_) };
            MTB_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_INTFLAGB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PAC_INTFLAGB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PAC_INTFLAGB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_INTFLAGB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_INTFLAGB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_INTFLAGB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_INTFLAGB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_INTFLAGB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_INTFLAGC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_INTFLAGC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PAC_INTFLAGC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PAC_INTFLAGC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_INTFLAGC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_INTFLAGC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_INTFLAGC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_INTFLAGC_Type__bindgen_ty_1))
    );
}
impl PAC_INTFLAGC_Type__bindgen_ty_1 {
    #[inline]
    pub fn EVSYS_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVSYS_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM1_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM1_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM2_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM2_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM3_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM3_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM4_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM4_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM5_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM5_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCC0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCC0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC1_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC1_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC2_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC2_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC3_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC3_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ADC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PTC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PTC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLCD_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLCD_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AES_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AES_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRNG_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TRNG_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EVSYS_: u32,
        SERCOM0_: u32,
        SERCOM1_: u32,
        SERCOM2_: u32,
        SERCOM3_: u32,
        SERCOM4_: u32,
        SERCOM5_: u32,
        TCC0_: u32,
        TC0_: u32,
        TC1_: u32,
        TC2_: u32,
        TC3_: u32,
        ADC_: u32,
        AC_: u32,
        PTC_: u32,
        SLCD_: u32,
        AES_: u32,
        TRNG_: u32,
        CCL_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EVSYS_: u32 = unsafe { ::core::mem::transmute(EVSYS_) };
            EVSYS_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SERCOM0_: u32 = unsafe { ::core::mem::transmute(SERCOM0_) };
            SERCOM0_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SERCOM1_: u32 = unsafe { ::core::mem::transmute(SERCOM1_) };
            SERCOM1_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SERCOM2_: u32 = unsafe { ::core::mem::transmute(SERCOM2_) };
            SERCOM2_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SERCOM3_: u32 = unsafe { ::core::mem::transmute(SERCOM3_) };
            SERCOM3_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SERCOM4_: u32 = unsafe { ::core::mem::transmute(SERCOM4_) };
            SERCOM4_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SERCOM5_: u32 = unsafe { ::core::mem::transmute(SERCOM5_) };
            SERCOM5_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let TCC0_: u32 = unsafe { ::core::mem::transmute(TCC0_) };
            TCC0_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let TC0_: u32 = unsafe { ::core::mem::transmute(TC0_) };
            TC0_ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TC1_: u32 = unsafe { ::core::mem::transmute(TC1_) };
            TC1_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let TC2_: u32 = unsafe { ::core::mem::transmute(TC2_) };
            TC2_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let TC3_: u32 = unsafe { ::core::mem::transmute(TC3_) };
            TC3_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ADC_: u32 = unsafe { ::core::mem::transmute(ADC_) };
            ADC_ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let AC_: u32 = unsafe { ::core::mem::transmute(AC_) };
            AC_ as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let PTC_: u32 = unsafe { ::core::mem::transmute(PTC_) };
            PTC_ as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let SLCD_: u32 = unsafe { ::core::mem::transmute(SLCD_) };
            SLCD_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let AES_: u32 = unsafe { ::core::mem::transmute(AES_) };
            AES_ as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let TRNG_: u32 = unsafe { ::core::mem::transmute(TRNG_) };
            TRNG_ as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let CCL_: u32 = unsafe { ::core::mem::transmute(CCL_) };
            CCL_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_INTFLAGC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PAC_INTFLAGC_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PAC_INTFLAGC_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_INTFLAGC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_INTFLAGC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_INTFLAGC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_INTFLAGC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_INTFLAGC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_STATUSA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_STATUSA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PAC_STATUSA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PAC_STATUSA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_STATUSA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_STATUSA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_STATUSA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_STATUSA_Type__bindgen_ty_1))
    );
}
impl PAC_STATUSA_Type__bindgen_ty_1 {
    #[inline]
    pub fn PAC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PAC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PM_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PM_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCLK_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCLK_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RSTC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RSTC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSCCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSCCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OSC32KCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OSC32KCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SUPC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SUPC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GCLK_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GCLK_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WDT_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WDT_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RTC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RTC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EIC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EIC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FREQM_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FREQM_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PAC_: u32,
        PM_: u32,
        MCLK_: u32,
        RSTC_: u32,
        OSCCTRL_: u32,
        OSC32KCTRL_: u32,
        SUPC_: u32,
        GCLK_: u32,
        WDT_: u32,
        RTC_: u32,
        EIC_: u32,
        FREQM_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PAC_: u32 = unsafe { ::core::mem::transmute(PAC_) };
            PAC_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PM_: u32 = unsafe { ::core::mem::transmute(PM_) };
            PM_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MCLK_: u32 = unsafe { ::core::mem::transmute(MCLK_) };
            MCLK_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RSTC_: u32 = unsafe { ::core::mem::transmute(RSTC_) };
            RSTC_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OSCCTRL_: u32 = unsafe { ::core::mem::transmute(OSCCTRL_) };
            OSCCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let OSC32KCTRL_: u32 = unsafe { ::core::mem::transmute(OSC32KCTRL_) };
            OSC32KCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SUPC_: u32 = unsafe { ::core::mem::transmute(SUPC_) };
            SUPC_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let GCLK_: u32 = unsafe { ::core::mem::transmute(GCLK_) };
            GCLK_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let WDT_: u32 = unsafe { ::core::mem::transmute(WDT_) };
            WDT_ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let RTC_: u32 = unsafe { ::core::mem::transmute(RTC_) };
            RTC_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EIC_: u32 = unsafe { ::core::mem::transmute(EIC_) };
            EIC_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let FREQM_: u32 = unsafe { ::core::mem::transmute(FREQM_) };
            FREQM_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_STATUSA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PAC_STATUSA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PAC_STATUSA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_STATUSA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_STATUSA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_STATUSA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_STATUSA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_STATUSA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_STATUSB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_STATUSB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PAC_STATUSB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PAC_STATUSB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_STATUSB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_STATUSB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_STATUSB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_STATUSB_Type__bindgen_ty_1))
    );
}
impl PAC_STATUSB_Type__bindgen_ty_1 {
    #[inline]
    pub fn USB_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_USB_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DSU_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DSU_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NVMCTRL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NVMCTRL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PORT_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PORT_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DMAC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DMAC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MTB_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MTB_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        USB_: u32,
        DSU_: u32,
        NVMCTRL_: u32,
        PORT_: u32,
        DMAC_: u32,
        MTB_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let USB_: u32 = unsafe { ::core::mem::transmute(USB_) };
            USB_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DSU_: u32 = unsafe { ::core::mem::transmute(DSU_) };
            DSU_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let NVMCTRL_: u32 = unsafe { ::core::mem::transmute(NVMCTRL_) };
            NVMCTRL_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PORT_: u32 = unsafe { ::core::mem::transmute(PORT_) };
            PORT_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DMAC_: u32 = unsafe { ::core::mem::transmute(DMAC_) };
            DMAC_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MTB_: u32 = unsafe { ::core::mem::transmute(MTB_) };
            MTB_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_STATUSB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PAC_STATUSB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PAC_STATUSB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_STATUSB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_STATUSB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_STATUSB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_STATUSB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_STATUSB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PAC_STATUSC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PAC_STATUSC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PAC_STATUSC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PAC_STATUSC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PAC_STATUSC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_STATUSC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_STATUSC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_STATUSC_Type__bindgen_ty_1))
    );
}
impl PAC_STATUSC_Type__bindgen_ty_1 {
    #[inline]
    pub fn EVSYS_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EVSYS_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM1_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM1_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM2_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM2_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM3_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM3_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM4_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM4_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SERCOM5_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SERCOM5_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCC0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCC0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC0_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC0_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC1_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC1_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC2_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC2_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TC3_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TC3_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ADC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PTC_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PTC_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLCD_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLCD_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AES_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AES_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRNG_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TRNG_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCL_(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCL_(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EVSYS_: u32,
        SERCOM0_: u32,
        SERCOM1_: u32,
        SERCOM2_: u32,
        SERCOM3_: u32,
        SERCOM4_: u32,
        SERCOM5_: u32,
        TCC0_: u32,
        TC0_: u32,
        TC1_: u32,
        TC2_: u32,
        TC3_: u32,
        ADC_: u32,
        AC_: u32,
        PTC_: u32,
        SLCD_: u32,
        AES_: u32,
        TRNG_: u32,
        CCL_: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EVSYS_: u32 = unsafe { ::core::mem::transmute(EVSYS_) };
            EVSYS_ as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SERCOM0_: u32 = unsafe { ::core::mem::transmute(SERCOM0_) };
            SERCOM0_ as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SERCOM1_: u32 = unsafe { ::core::mem::transmute(SERCOM1_) };
            SERCOM1_ as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SERCOM2_: u32 = unsafe { ::core::mem::transmute(SERCOM2_) };
            SERCOM2_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SERCOM3_: u32 = unsafe { ::core::mem::transmute(SERCOM3_) };
            SERCOM3_ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SERCOM4_: u32 = unsafe { ::core::mem::transmute(SERCOM4_) };
            SERCOM4_ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SERCOM5_: u32 = unsafe { ::core::mem::transmute(SERCOM5_) };
            SERCOM5_ as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let TCC0_: u32 = unsafe { ::core::mem::transmute(TCC0_) };
            TCC0_ as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let TC0_: u32 = unsafe { ::core::mem::transmute(TC0_) };
            TC0_ as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TC1_: u32 = unsafe { ::core::mem::transmute(TC1_) };
            TC1_ as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let TC2_: u32 = unsafe { ::core::mem::transmute(TC2_) };
            TC2_ as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let TC3_: u32 = unsafe { ::core::mem::transmute(TC3_) };
            TC3_ as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let ADC_: u32 = unsafe { ::core::mem::transmute(ADC_) };
            ADC_ as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let AC_: u32 = unsafe { ::core::mem::transmute(AC_) };
            AC_ as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let PTC_: u32 = unsafe { ::core::mem::transmute(PTC_) };
            PTC_ as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let SLCD_: u32 = unsafe { ::core::mem::transmute(SLCD_) };
            SLCD_ as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let AES_: u32 = unsafe { ::core::mem::transmute(AES_) };
            AES_ as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let TRNG_: u32 = unsafe { ::core::mem::transmute(TRNG_) };
            TRNG_ as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let CCL_: u32 = unsafe { ::core::mem::transmute(CCL_) };
            CCL_ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PAC_STATUSC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PAC_STATUSC_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PAC_STATUSC_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PAC_STATUSC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PAC_STATUSC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PAC_STATUSC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_STATUSC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PAC_STATUSC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Pac {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Write control"]
    pub WRCTRL: PAC_WRCTRL_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Event control"]
    pub EVCTRL: PAC_EVCTRL_Type,
    pub Reserved1: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x08 (R/W  8) Interrupt enable clear"]
    pub INTENCLR: PAC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x09 (R/W  8) Interrupt enable set"]
    pub INTENSET: PAC_INTENSET_Type,
    pub Reserved2: [RoReg8; 6usize],
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Bridge interrupt flag status"]
    pub INTFLAGAHB: PAC_INTFLAGAHB_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) Peripheral interrupt flag status - Bridge A"]
    pub INTFLAGA: PAC_INTFLAGA_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W 32) Peripheral interrupt flag status - Bridge B"]
    pub INTFLAGB: PAC_INTFLAGB_Type,
    #[doc = "< \\brief Offset: 0x1C (R/W 32) Peripheral interrupt flag status - Bridge C"]
    pub INTFLAGC: PAC_INTFLAGC_Type,
    pub Reserved3: [RoReg8; 20usize],
    #[doc = "< \\brief Offset: 0x34 (R/  32) Peripheral write protection status - Bridge A"]
    pub STATUSA: PAC_STATUSA_Type,
    #[doc = "< \\brief Offset: 0x38 (R/  32) Peripheral write protection status - Bridge B"]
    pub STATUSB: PAC_STATUSB_Type,
    #[doc = "< \\brief Offset: 0x3C (R/  32) Peripheral write protection status - Bridge C"]
    pub STATUSC: PAC_STATUSC_Type,
}
#[test]
fn bindgen_test_layout_Pac() {
    const UNINIT: ::core::mem::MaybeUninit<Pac> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Pac>(),
        64usize,
        concat!("Size of: ", stringify!(Pac))
    );
    assert_eq!(
        ::core::mem::align_of::<Pac>(),
        4usize,
        concat!("Alignment of ", stringify!(Pac))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WRCTRL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(WRCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAGAHB) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(INTFLAGAHB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAGA) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(INTFLAGA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAGB) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(INTFLAGB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAGC) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(INTFLAGC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUSA) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(STATUSA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUSB) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(STATUSB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUSC) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Pac),
            "::",
            stringify!(STATUSC)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_PM_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_CTRLA_Type__bindgen_ty_1))
    );
}
impl PM_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn IORET(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_IORET(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(IORET: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let IORET: u8 = unsafe { ::core::mem::transmute(IORET) };
            IORET as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PM_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PM_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_SLEEPCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_SLEEPCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_SLEEPCFG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_PM_SLEEPCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_SLEEPCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_SLEEPCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_SLEEPCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_SLEEPCFG_Type__bindgen_ty_1))
    );
}
impl PM_SLEEPCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn SLEEPMODE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SLEEPMODE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SLEEPMODE: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SLEEPMODE: u8 = unsafe { ::core::mem::transmute(SLEEPMODE) };
            SLEEPMODE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_SLEEPCFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PM_SLEEPCFG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PM_SLEEPCFG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_SLEEPCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_SLEEPCFG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_SLEEPCFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_SLEEPCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_SLEEPCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_PLCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_PLCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_PLCFG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_PM_PLCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_PLCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_PLCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_PLCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_PLCFG_Type__bindgen_ty_1))
    );
}
impl PM_PLCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PLSEL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_PLSEL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PLDIS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PLDIS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PLSEL: u8, PLDIS: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let PLSEL: u8 = unsafe { ::core::mem::transmute(PLSEL) };
            PLSEL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PLDIS: u8 = unsafe { ::core::mem::transmute(PLDIS) };
            PLDIS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_PLCFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PM_PLCFG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PM_PLCFG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_PLCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_PLCFG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_PLCFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_PLCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_PLCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_PM_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_INTENCLR_Type__bindgen_ty_1))
    );
}
impl PM_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn PLRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PLRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PLRDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PLRDY: u8 = unsafe { ::core::mem::transmute(PLRDY) };
            PLRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PM_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PM_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_PM_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_INTENSET_Type__bindgen_ty_1))
    );
}
impl PM_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn PLRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PLRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PLRDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PLRDY: u8 = unsafe { ::core::mem::transmute(PLRDY) };
            PLRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PM_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PM_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PM_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_PM_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PM_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_INTFLAG_Type__bindgen_ty_1))
    );
}
impl PM_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PLRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PLRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PLRDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PLRDY: u8 = unsafe { ::core::mem::transmute(PLRDY) };
            PLRDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PM_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PM_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PM_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PM_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PM_STDBYCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PM_STDBYCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct PM_STDBYCFG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_PM_STDBYCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PM_STDBYCFG_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(PM_STDBYCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_STDBYCFG_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(PM_STDBYCFG_Type__bindgen_ty_1))
    );
}
impl PM_STDBYCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn VREGSMOD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_VREGSMOD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn BBIASHS(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_BBIASHS(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(VREGSMOD: u16, BBIASHS: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let VREGSMOD: u16 = unsafe { ::core::mem::transmute(VREGSMOD) };
            VREGSMOD as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let BBIASHS: u16 = unsafe { ::core::mem::transmute(BBIASHS) };
            BBIASHS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PM_STDBYCFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PM_STDBYCFG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PM_STDBYCFG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(PM_STDBYCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PM_STDBYCFG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(PM_STDBYCFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_STDBYCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PM_STDBYCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Pm {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control A"]
    pub CTRLA: PM_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x01 (R/W  8) Sleep Configuration"]
    pub SLEEPCFG: PM_SLEEPCFG_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W  8) Performance Level Configuration"]
    pub PLCFG: PM_PLCFG_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: PM_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: PM_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: PM_INTFLAG_Type,
    pub Reserved2: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x08 (R/W 16) Standby Configuration"]
    pub STDBYCFG: PM_STDBYCFG_Type,
}
#[test]
fn bindgen_test_layout_Pm() {
    const UNINIT: ::core::mem::MaybeUninit<Pm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Pm>(),
        10usize,
        concat!("Size of: ", stringify!(Pm))
    );
    assert_eq!(
        ::core::mem::align_of::<Pm>(),
        2usize,
        concat!("Alignment of ", stringify!(Pm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pm), "::", stringify!(CTRLA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SLEEPCFG) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(SLEEPCFG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PLCFG) as usize - ptr as usize },
        2usize,
        concat!("Offset of field: ", stringify!(Pm), "::", stringify!(PLCFG))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STDBYCFG) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pm),
            "::",
            stringify!(STDBYCFG)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_DIR_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_PORT_DIR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_DIR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_DIR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_DIR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_DIR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_DIR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_DIR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_DIRCLR_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_PORT_DIRCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_DIRCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_DIRCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_DIRCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_DIRCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_DIRCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_DIRCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_DIRSET_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_PORT_DIRSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_DIRSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_DIRSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_DIRSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_DIRSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_DIRSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_DIRSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_DIRTGL_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_PORT_DIRTGL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_DIRTGL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_DIRTGL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_DIRTGL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_DIRTGL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_DIRTGL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_DIRTGL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_OUT_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_PORT_OUT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_OUT_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_OUT_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_OUT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_OUT_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_OUT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_OUT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_OUTCLR_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_PORT_OUTCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_OUTCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_OUTCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_OUTCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_OUTCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_OUTCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_OUTCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_OUTSET_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_PORT_OUTSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_OUTSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_OUTSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_OUTSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_OUTSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_OUTSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_OUTSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_OUTTGL_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_PORT_OUTTGL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_OUTTGL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_OUTTGL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_OUTTGL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_OUTTGL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_OUTTGL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_OUTTGL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_IN_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[test]
fn bindgen_test_layout_PORT_IN_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_IN_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_IN_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_IN_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_IN_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_IN_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_IN_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_CTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_CTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_CTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PORT_CTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_CTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_CTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_CTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_CTRL_Type__bindgen_ty_1))
    );
}
impl PORT_CTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn SAMPLING(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SAMPLING(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SAMPLING: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SAMPLING: u32 = unsafe { ::core::mem::transmute(SAMPLING) };
            SAMPLING as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_CTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_CTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_CTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_CTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_CTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_CTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_CTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_CTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_WRCONFIG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_WRCONFIG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_WRCONFIG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PORT_WRCONFIG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_WRCONFIG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_WRCONFIG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_WRCONFIG_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(PORT_WRCONFIG_Type__bindgen_ty_1)
        )
    );
}
impl PORT_WRCONFIG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PINMASK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_PINMASK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn PMUXEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PMUXEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PULLEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PULLEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DRVSTR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DRVSTR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PMUX(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_PMUX(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn WRPMUX(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WRPMUX(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WRPINCFG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WRPINCFG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HWSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HWSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PINMASK: u32,
        PMUXEN: u32,
        INEN: u32,
        PULLEN: u32,
        DRVSTR: u32,
        PMUX: u32,
        WRPMUX: u32,
        WRPINCFG: u32,
        HWSEL: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let PINMASK: u32 = unsafe { ::core::mem::transmute(PINMASK) };
            PINMASK as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let PMUXEN: u32 = unsafe { ::core::mem::transmute(PMUXEN) };
            PMUXEN as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let INEN: u32 = unsafe { ::core::mem::transmute(INEN) };
            INEN as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let PULLEN: u32 = unsafe { ::core::mem::transmute(PULLEN) };
            PULLEN as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let DRVSTR: u32 = unsafe { ::core::mem::transmute(DRVSTR) };
            DRVSTR as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let PMUX: u32 = unsafe { ::core::mem::transmute(PMUX) };
            PMUX as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let WRPMUX: u32 = unsafe { ::core::mem::transmute(WRPMUX) };
            WRPMUX as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let WRPINCFG: u32 = unsafe { ::core::mem::transmute(WRPINCFG) };
            WRPINCFG as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let HWSEL: u32 = unsafe { ::core::mem::transmute(HWSEL) };
            HWSEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_WRCONFIG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_WRCONFIG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_WRCONFIG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_WRCONFIG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_WRCONFIG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_WRCONFIG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_WRCONFIG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_WRCONFIG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct PORT_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_PORT_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_EVCTRL_Type__bindgen_ty_1))
    );
}
impl PORT_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn PID0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_PID0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn EVACT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_EVACT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PORTEI0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PORTEI0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PID1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_PID1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn EVACT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_EVACT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PORTEI1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PORTEI1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PID2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_PID2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn EVACT2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_EVACT2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PORTEI2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PORTEI2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PID3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_PID3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn EVACT3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_EVACT3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PORTEI3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PORTEI3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PID0: u32,
        EVACT0: u32,
        PORTEI0: u32,
        PID1: u32,
        EVACT1: u32,
        PORTEI1: u32,
        PID2: u32,
        EVACT2: u32,
        PORTEI2: u32,
        PID3: u32,
        EVACT3: u32,
        PORTEI3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let PID0: u32 = unsafe { ::core::mem::transmute(PID0) };
            PID0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let EVACT0: u32 = unsafe { ::core::mem::transmute(EVACT0) };
            EVACT0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PORTEI0: u32 = unsafe { ::core::mem::transmute(PORTEI0) };
            PORTEI0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let PID1: u32 = unsafe { ::core::mem::transmute(PID1) };
            PID1 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let EVACT1: u32 = unsafe { ::core::mem::transmute(EVACT1) };
            EVACT1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PORTEI1: u32 = unsafe { ::core::mem::transmute(PORTEI1) };
            PORTEI1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let PID2: u32 = unsafe { ::core::mem::transmute(PID2) };
            PID2 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let EVACT2: u32 = unsafe { ::core::mem::transmute(EVACT2) };
            EVACT2 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let PORTEI2: u32 = unsafe { ::core::mem::transmute(PORTEI2) };
            PORTEI2 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let PID3: u32 = unsafe { ::core::mem::transmute(PID3) };
            PID3 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 2u8, {
            let EVACT3: u32 = unsafe { ::core::mem::transmute(EVACT3) };
            EVACT3 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let PORTEI3: u32 = unsafe { ::core::mem::transmute(PORTEI3) };
            PORTEI3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_EVCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_EVCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(PORT_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_EVCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(PORT_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_PMUX_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_PMUX_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PORT_PMUX_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_PORT_PMUX_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_PMUX_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PORT_PMUX_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_PMUX_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PORT_PMUX_Type__bindgen_ty_1))
    );
}
impl PORT_PMUX_Type__bindgen_ty_1 {
    #[inline]
    pub fn PMUXE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_PMUXE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn PMUXO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_PMUXO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PMUXE: u8, PMUXO: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let PMUXE: u8 = unsafe { ::core::mem::transmute(PMUXE) };
            PMUXE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let PMUXO: u8 = unsafe { ::core::mem::transmute(PMUXO) };
            PMUXO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_PMUX_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_PMUX_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_PMUX_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PORT_PMUX_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_PMUX_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PORT_PMUX_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_PMUX_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_PMUX_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PORT_PINCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: PORT_PINCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PORT_PINCFG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_PORT_PINCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PORT_PINCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(PORT_PINCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_PINCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PORT_PINCFG_Type__bindgen_ty_1))
    );
}
impl PORT_PINCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PMUXEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PMUXEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_INEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PULLEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PULLEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DRVSTR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRVSTR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PMUXEN: u8,
        INEN: u8,
        PULLEN: u8,
        DRVSTR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PMUXEN: u8 = unsafe { ::core::mem::transmute(PMUXEN) };
            PMUXEN as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let INEN: u8 = unsafe { ::core::mem::transmute(INEN) };
            INEN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PULLEN: u8 = unsafe { ::core::mem::transmute(PULLEN) };
            PULLEN as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let DRVSTR: u8 = unsafe { ::core::mem::transmute(DRVSTR) };
            DRVSTR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PORT_PINCFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<PORT_PINCFG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PORT_PINCFG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(PORT_PINCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<PORT_PINCFG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(PORT_PINCFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_PINCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PORT_PINCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PortGroup {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Data Direction"]
    pub DIR: PORT_DIR_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Data Direction Clear"]
    pub DIRCLR: PORT_DIRCLR_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) Data Direction Set"]
    pub DIRSET: PORT_DIRSET_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W 32) Data Direction Toggle"]
    pub DIRTGL: PORT_DIRTGL_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Data Output Value"]
    pub OUT: PORT_OUT_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) Data Output Value Clear"]
    pub OUTCLR: PORT_OUTCLR_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W 32) Data Output Value Set"]
    pub OUTSET: PORT_OUTSET_Type,
    #[doc = "< \\brief Offset: 0x1C (R/W 32) Data Output Value Toggle"]
    pub OUTTGL: PORT_OUTTGL_Type,
    #[doc = "< \\brief Offset: 0x20 (R/  32) Data Input Value"]
    pub IN: PORT_IN_Type,
    #[doc = "< \\brief Offset: 0x24 (R/W 32) Control"]
    pub CTRL: PORT_CTRL_Type,
    #[doc = "< \\brief Offset: 0x28 ( /W 32) Write Configuration"]
    pub WRCONFIG: PORT_WRCONFIG_Type,
    #[doc = "< \\brief Offset: 0x2C (R/W 32) Event Input Control"]
    pub EVCTRL: PORT_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x30 (R/W  8) Peripheral Multiplexing n"]
    pub PMUX: [PORT_PMUX_Type; 16usize],
    #[doc = "< \\brief Offset: 0x40 (R/W  8) Pin Configuration n"]
    pub PINCFG: [PORT_PINCFG_Type; 32usize],
    pub Reserved1: [RoReg8; 32usize],
}
#[test]
fn bindgen_test_layout_PortGroup() {
    const UNINIT: ::core::mem::MaybeUninit<PortGroup> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<PortGroup>(),
        128usize,
        concat!("Size of: ", stringify!(PortGroup))
    );
    assert_eq!(
        ::core::mem::align_of::<PortGroup>(),
        4usize,
        concat!("Alignment of ", stringify!(PortGroup))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DIR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(DIR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DIRCLR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(DIRCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DIRSET) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(DIRSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DIRTGL) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(DIRTGL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OUT) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(OUT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OUTCLR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(OUTCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OUTSET) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(OUTSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OUTTGL) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(OUTTGL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IN) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(IN)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRL) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(CTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WRCONFIG) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(WRCONFIG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PMUX) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(PMUX)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PINCFG) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(PINCFG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(PortGroup),
            "::",
            stringify!(Reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Port {
    #[doc = "< \\brief Offset: 0x00 PortGroup groups [GROUPS]"]
    pub Group: [PortGroup; 3usize],
}
#[test]
fn bindgen_test_layout_Port() {
    const UNINIT: ::core::mem::MaybeUninit<Port> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Port>(),
        384usize,
        concat!("Size of: ", stringify!(Port))
    );
    assert_eq!(
        ::core::mem::align_of::<Port>(),
        4usize,
        concat!("Alignment of ", stringify!(Port))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Group) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Port),
            "::",
            stringify!(Group)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RSTC_RCAUSE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RSTC_RCAUSE_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RSTC_RCAUSE_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_RSTC_RCAUSE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RSTC_RCAUSE_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(RSTC_RCAUSE_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RSTC_RCAUSE_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(RSTC_RCAUSE_Type__bindgen_ty_1))
    );
}
impl RSTC_RCAUSE_Type__bindgen_ty_1 {
    #[inline]
    pub fn POR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_POR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BODCORE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BODCORE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BODVDD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BODVDD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EXT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EXT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WDT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WDT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SYST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BACKUP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BACKUP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        POR: u8,
        BODCORE: u8,
        BODVDD: u8,
        EXT: u8,
        WDT: u8,
        SYST: u8,
        BACKUP: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let POR: u8 = unsafe { ::core::mem::transmute(POR) };
            POR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BODCORE: u8 = unsafe { ::core::mem::transmute(BODCORE) };
            BODCORE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BODVDD: u8 = unsafe { ::core::mem::transmute(BODVDD) };
            BODVDD as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EXT: u8 = unsafe { ::core::mem::transmute(EXT) };
            EXT as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let WDT: u8 = unsafe { ::core::mem::transmute(WDT) };
            WDT as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SYST: u8 = unsafe { ::core::mem::transmute(SYST) };
            SYST as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BACKUP: u8 = unsafe { ::core::mem::transmute(BACKUP) };
            BACKUP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RSTC_RCAUSE_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RSTC_RCAUSE_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RSTC_RCAUSE_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RSTC_RCAUSE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RSTC_RCAUSE_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RSTC_RCAUSE_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RSTC_RCAUSE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RSTC_RCAUSE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RSTC_BKUPEXIT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RSTC_BKUPEXIT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RSTC_BKUPEXIT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_RSTC_BKUPEXIT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RSTC_BKUPEXIT_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(RSTC_BKUPEXIT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RSTC_BKUPEXIT_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RSTC_BKUPEXIT_Type__bindgen_ty_1)
        )
    );
}
impl RSTC_BKUPEXIT_Type__bindgen_ty_1 {
    #[inline]
    pub fn EXTWAKE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EXTWAKE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RTC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RTC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BBPS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BBPS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EXTWAKE: u8, RTC: u8, BBPS: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EXTWAKE: u8 = unsafe { ::core::mem::transmute(EXTWAKE) };
            EXTWAKE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RTC: u8 = unsafe { ::core::mem::transmute(RTC) };
            RTC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BBPS: u8 = unsafe { ::core::mem::transmute(BBPS) };
            BBPS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RSTC_BKUPEXIT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RSTC_BKUPEXIT_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RSTC_BKUPEXIT_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RSTC_BKUPEXIT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RSTC_BKUPEXIT_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RSTC_BKUPEXIT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RSTC_BKUPEXIT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RSTC_BKUPEXIT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Rstc {
    #[doc = "< \\brief Offset: 0x00 (R/   8) Reset Cause"]
    pub RCAUSE: RSTC_RCAUSE_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x02 (R/   8) Backup Exit Source"]
    pub BKUPEXIT: RSTC_BKUPEXIT_Type,
}
#[test]
fn bindgen_test_layout_Rstc() {
    const UNINIT: ::core::mem::MaybeUninit<Rstc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Rstc>(),
        3usize,
        concat!("Size of: ", stringify!(Rstc))
    );
    assert_eq!(
        ::core::mem::align_of::<Rstc>(),
        1usize,
        concat!("Alignment of ", stringify!(Rstc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RCAUSE) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rstc),
            "::",
            stringify!(RCAUSE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Rstc),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKUPEXIT) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Rstc),
            "::",
            stringify!(BKUPEXIT)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_CTRLA_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE0_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_CTRLA_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn MATCHCLR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MATCHCLR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCALER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_PRESCALER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn BKTRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BKTRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GPTRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GPTRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COUNTSYNC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COUNTSYNC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u16,
        ENABLE: u16,
        MODE: u16,
        MATCHCLR: u16,
        PRESCALER: u16,
        BKTRST: u16,
        GPTRST: u16,
        COUNTSYNC: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u16 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let MODE: u16 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MATCHCLR: u16 = unsafe { ::core::mem::transmute(MATCHCLR) };
            MATCHCLR as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let PRESCALER: u16 = unsafe { ::core::mem::transmute(PRESCALER) };
            PRESCALER as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let BKTRST: u16 = unsafe { ::core::mem::transmute(BKTRST) };
            BKTRST as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let GPTRST: u16 = unsafe { ::core::mem::transmute(GPTRST) };
            GPTRST as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let COUNTSYNC: u16 = unsafe { ::core::mem::transmute(COUNTSYNC) };
            COUNTSYNC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE0_CTRLA_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_CTRLA_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE0_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_CTRLA_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_CTRLA_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_CTRLA_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCALER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_PRESCALER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn BKTRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BKTRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GPTRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GPTRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COUNTSYNC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COUNTSYNC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u16,
        ENABLE: u16,
        MODE: u16,
        PRESCALER: u16,
        BKTRST: u16,
        GPTRST: u16,
        COUNTSYNC: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u16 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let MODE: u16 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let PRESCALER: u16 = unsafe { ::core::mem::transmute(PRESCALER) };
            PRESCALER as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let BKTRST: u16 = unsafe { ::core::mem::transmute(BKTRST) };
            BKTRST as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let GPTRST: u16 = unsafe { ::core::mem::transmute(GPTRST) };
            GPTRST as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let COUNTSYNC: u16 = unsafe { ::core::mem::transmute(COUNTSYNC) };
            COUNTSYNC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE1_CTRLA_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_CTRLA_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_CTRLA_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_CTRLA_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE2_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_CTRLA_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKREP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CLKREP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MATCHCLR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MATCHCLR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCALER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_PRESCALER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn BKTRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BKTRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GPTRST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GPTRST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLOCKSYNC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CLOCKSYNC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u16,
        ENABLE: u16,
        MODE: u16,
        CLKREP: u16,
        MATCHCLR: u16,
        PRESCALER: u16,
        BKTRST: u16,
        GPTRST: u16,
        CLOCKSYNC: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u16 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u16 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let MODE: u16 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let CLKREP: u16 = unsafe { ::core::mem::transmute(CLKREP) };
            CLKREP as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MATCHCLR: u16 = unsafe { ::core::mem::transmute(MATCHCLR) };
            MATCHCLR as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let PRESCALER: u16 = unsafe { ::core::mem::transmute(PRESCALER) };
            PRESCALER as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let BKTRST: u16 = unsafe { ::core::mem::transmute(BKTRST) };
            BKTRST as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let GPTRST: u16 = unsafe { ::core::mem::transmute(GPTRST) };
            GPTRST as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let CLOCKSYNC: u16 = unsafe { ::core::mem::transmute(CLOCKSYNC) };
            CLOCKSYNC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE2_CTRLA_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_CTRLA_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE2_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_CTRLA_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE0_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn GP0EN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GP0EN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBMAJ(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DEBMAJ(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBASYNC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DEBASYNC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RTCOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RTCOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DMAEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DMAEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_DEBF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ACTF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_ACTF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        GP0EN: u16,
        DEBMAJ: u16,
        DEBASYNC: u16,
        RTCOUT: u16,
        DMAEN: u16,
        DEBF: u16,
        ACTF: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let GP0EN: u16 = unsafe { ::core::mem::transmute(GP0EN) };
            GP0EN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DEBMAJ: u16 = unsafe { ::core::mem::transmute(DEBMAJ) };
            DEBMAJ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DEBASYNC: u16 = unsafe { ::core::mem::transmute(DEBASYNC) };
            DEBASYNC as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RTCOUT: u16 = unsafe { ::core::mem::transmute(RTCOUT) };
            RTCOUT as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DMAEN: u16 = unsafe { ::core::mem::transmute(DMAEN) };
            DMAEN as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let DEBF: u16 = unsafe { ::core::mem::transmute(DEBF) };
            DEBF as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let ACTF: u16 = unsafe { ::core::mem::transmute(ACTF) };
            ACTF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE0_CTRLB_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_CTRLB_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE0_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_CTRLB_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn GP0EN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GP0EN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBMAJ(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DEBMAJ(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBASYNC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DEBASYNC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RTCOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RTCOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DMAEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DMAEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_DEBF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ACTF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_ACTF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        GP0EN: u16,
        DEBMAJ: u16,
        DEBASYNC: u16,
        RTCOUT: u16,
        DMAEN: u16,
        DEBF: u16,
        ACTF: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let GP0EN: u16 = unsafe { ::core::mem::transmute(GP0EN) };
            GP0EN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DEBMAJ: u16 = unsafe { ::core::mem::transmute(DEBMAJ) };
            DEBMAJ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DEBASYNC: u16 = unsafe { ::core::mem::transmute(DEBASYNC) };
            DEBASYNC as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RTCOUT: u16 = unsafe { ::core::mem::transmute(RTCOUT) };
            RTCOUT as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DMAEN: u16 = unsafe { ::core::mem::transmute(DMAEN) };
            DMAEN as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let DEBF: u16 = unsafe { ::core::mem::transmute(DEBF) };
            DEBF as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let ACTF: u16 = unsafe { ::core::mem::transmute(ACTF) };
            ACTF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE1_CTRLB_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_CTRLB_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_CTRLB_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE2_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn GP0EN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GP0EN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBMAJ(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DEBMAJ(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBASYNC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DEBASYNC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RTCOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RTCOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DMAEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DMAEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_DEBF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ACTF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_ACTF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        GP0EN: u16,
        DEBMAJ: u16,
        DEBASYNC: u16,
        RTCOUT: u16,
        DMAEN: u16,
        DEBF: u16,
        ACTF: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let GP0EN: u16 = unsafe { ::core::mem::transmute(GP0EN) };
            GP0EN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DEBMAJ: u16 = unsafe { ::core::mem::transmute(DEBMAJ) };
            DEBMAJ as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DEBASYNC: u16 = unsafe { ::core::mem::transmute(DEBASYNC) };
            DEBASYNC as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RTCOUT: u16 = unsafe { ::core::mem::transmute(RTCOUT) };
            RTCOUT as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DMAEN: u16 = unsafe { ::core::mem::transmute(DMAEN) };
            DMAEN as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let DEBF: u16 = unsafe { ::core::mem::transmute(DEBF) };
            DEBF as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let ACTF: u16 = unsafe { ::core::mem::transmute(ACTF) };
            ACTF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE2_CTRLB_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_CTRLB_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE2_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_CTRLB_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE0_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_EVCTRL_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn PEREO0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMPEO0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMPEO0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPEREO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPEREO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVFEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVFEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPEVEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPEVEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PEREO0: u32,
        PEREO1: u32,
        PEREO2: u32,
        PEREO3: u32,
        PEREO4: u32,
        PEREO5: u32,
        PEREO6: u32,
        PEREO7: u32,
        CMPEO0: u32,
        TAMPEREO: u32,
        OVFEO: u32,
        TAMPEVEI: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PEREO0: u32 = unsafe { ::core::mem::transmute(PEREO0) };
            PEREO0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PEREO1: u32 = unsafe { ::core::mem::transmute(PEREO1) };
            PEREO1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PEREO2: u32 = unsafe { ::core::mem::transmute(PEREO2) };
            PEREO2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PEREO3: u32 = unsafe { ::core::mem::transmute(PEREO3) };
            PEREO3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PEREO4: u32 = unsafe { ::core::mem::transmute(PEREO4) };
            PEREO4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PEREO5: u32 = unsafe { ::core::mem::transmute(PEREO5) };
            PEREO5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PEREO6: u32 = unsafe { ::core::mem::transmute(PEREO6) };
            PEREO6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PEREO7: u32 = unsafe { ::core::mem::transmute(PEREO7) };
            PEREO7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMPEO0: u32 = unsafe { ::core::mem::transmute(CMPEO0) };
            CMPEO0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TAMPEREO: u32 = unsafe { ::core::mem::transmute(TAMPEREO) };
            TAMPEREO as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVFEO: u32 = unsafe { ::core::mem::transmute(OVFEO) };
            OVFEO as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let TAMPEVEI: u32 = unsafe { ::core::mem::transmute(TAMPEVEI) };
            TAMPEVEI as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_EVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_EVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_EVCTRL_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE0_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn PEREO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn CMPEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMPEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PEREO: u32, CMPEO: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PEREO: u32 = unsafe { ::core::mem::transmute(PEREO) };
            PEREO as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMPEO: u32 = unsafe { ::core::mem::transmute(CMPEO) };
            CMPEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE0_EVCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_EVCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_EVCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE1_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE1_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_EVCTRL_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn PEREO0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMPEO0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMPEO0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMPEO1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMPEO1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPEREO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPEREO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVFEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVFEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPEVEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPEVEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PEREO0: u32,
        PEREO1: u32,
        PEREO2: u32,
        PEREO3: u32,
        PEREO4: u32,
        PEREO5: u32,
        PEREO6: u32,
        PEREO7: u32,
        CMPEO0: u32,
        CMPEO1: u32,
        TAMPEREO: u32,
        OVFEO: u32,
        TAMPEVEI: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PEREO0: u32 = unsafe { ::core::mem::transmute(PEREO0) };
            PEREO0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PEREO1: u32 = unsafe { ::core::mem::transmute(PEREO1) };
            PEREO1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PEREO2: u32 = unsafe { ::core::mem::transmute(PEREO2) };
            PEREO2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PEREO3: u32 = unsafe { ::core::mem::transmute(PEREO3) };
            PEREO3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PEREO4: u32 = unsafe { ::core::mem::transmute(PEREO4) };
            PEREO4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PEREO5: u32 = unsafe { ::core::mem::transmute(PEREO5) };
            PEREO5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PEREO6: u32 = unsafe { ::core::mem::transmute(PEREO6) };
            PEREO6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PEREO7: u32 = unsafe { ::core::mem::transmute(PEREO7) };
            PEREO7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMPEO0: u32 = unsafe { ::core::mem::transmute(CMPEO0) };
            CMPEO0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CMPEO1: u32 = unsafe { ::core::mem::transmute(CMPEO1) };
            CMPEO1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TAMPEREO: u32 = unsafe { ::core::mem::transmute(TAMPEREO) };
            TAMPEREO as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVFEO: u32 = unsafe { ::core::mem::transmute(OVFEO) };
            OVFEO as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let TAMPEVEI: u32 = unsafe { ::core::mem::transmute(TAMPEVEI) };
            TAMPEVEI as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_EVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE1_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_EVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_EVCTRL_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE1_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn PEREO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn CMPEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CMPEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PEREO: u32, CMPEO: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PEREO: u32 = unsafe { ::core::mem::transmute(PEREO) };
            PEREO as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let CMPEO: u32 = unsafe { ::core::mem::transmute(CMPEO) };
            CMPEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE1_EVCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_EVCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE1_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_EVCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE2_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_EVCTRL_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn PEREO0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PEREO7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ALARMEO0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ALARMEO0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPEREO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPEREO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVFEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVFEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPEVEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPEVEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PEREO0: u32,
        PEREO1: u32,
        PEREO2: u32,
        PEREO3: u32,
        PEREO4: u32,
        PEREO5: u32,
        PEREO6: u32,
        PEREO7: u32,
        ALARMEO0: u32,
        TAMPEREO: u32,
        OVFEO: u32,
        TAMPEVEI: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PEREO0: u32 = unsafe { ::core::mem::transmute(PEREO0) };
            PEREO0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PEREO1: u32 = unsafe { ::core::mem::transmute(PEREO1) };
            PEREO1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PEREO2: u32 = unsafe { ::core::mem::transmute(PEREO2) };
            PEREO2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PEREO3: u32 = unsafe { ::core::mem::transmute(PEREO3) };
            PEREO3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PEREO4: u32 = unsafe { ::core::mem::transmute(PEREO4) };
            PEREO4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PEREO5: u32 = unsafe { ::core::mem::transmute(PEREO5) };
            PEREO5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PEREO6: u32 = unsafe { ::core::mem::transmute(PEREO6) };
            PEREO6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PEREO7: u32 = unsafe { ::core::mem::transmute(PEREO7) };
            PEREO7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ALARMEO0: u32 = unsafe { ::core::mem::transmute(ALARMEO0) };
            ALARMEO0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TAMPEREO: u32 = unsafe { ::core::mem::transmute(TAMPEREO) };
            TAMPEREO as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVFEO: u32 = unsafe { ::core::mem::transmute(OVFEO) };
            OVFEO as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let TAMPEVEI: u32 = unsafe { ::core::mem::transmute(TAMPEVEI) };
            TAMPEVEI as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_EVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_EVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_EVCTRL_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE2_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn PEREO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PEREO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ALARMEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ALARMEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PEREO: u32, ALARMEO: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PEREO: u32 = unsafe { ::core::mem::transmute(PEREO) };
            PEREO as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ALARMEO: u32 = unsafe { ::core::mem::transmute(ALARMEO) };
            ALARMEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE2_EVCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_EVCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_EVCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE0_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TAMPER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PER0: u16,
        PER1: u16,
        PER2: u16,
        PER3: u16,
        PER4: u16,
        PER5: u16,
        PER6: u16,
        PER7: u16,
        CMP0: u16,
        TAMPER: u16,
        OVF: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PER0: u16 = unsafe { ::core::mem::transmute(PER0) };
            PER0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PER1: u16 = unsafe { ::core::mem::transmute(PER1) };
            PER1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PER2: u16 = unsafe { ::core::mem::transmute(PER2) };
            PER2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PER3: u16 = unsafe { ::core::mem::transmute(PER3) };
            PER3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PER4: u16 = unsafe { ::core::mem::transmute(PER4) };
            PER4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PER5: u16 = unsafe { ::core::mem::transmute(PER5) };
            PER5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PER6: u16 = unsafe { ::core::mem::transmute(PER6) };
            PER6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PER7: u16 = unsafe { ::core::mem::transmute(PER7) };
            PER7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMP0: u16 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TAMPER: u16 = unsafe { ::core::mem::transmute(TAMPER) };
            TAMPER as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVF: u16 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTENCLR_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_INTENCLR_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTENCLR_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_INTENCLR_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE0_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn PER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u16, CMP: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PER: u16 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMP: u16 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE0_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTENCLR_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE0_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTENCLR_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE1_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMP1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TAMPER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PER0: u16,
        PER1: u16,
        PER2: u16,
        PER3: u16,
        PER4: u16,
        PER5: u16,
        PER6: u16,
        PER7: u16,
        CMP0: u16,
        CMP1: u16,
        TAMPER: u16,
        OVF: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PER0: u16 = unsafe { ::core::mem::transmute(PER0) };
            PER0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PER1: u16 = unsafe { ::core::mem::transmute(PER1) };
            PER1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PER2: u16 = unsafe { ::core::mem::transmute(PER2) };
            PER2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PER3: u16 = unsafe { ::core::mem::transmute(PER3) };
            PER3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PER4: u16 = unsafe { ::core::mem::transmute(PER4) };
            PER4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PER5: u16 = unsafe { ::core::mem::transmute(PER5) };
            PER5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PER6: u16 = unsafe { ::core::mem::transmute(PER6) };
            PER6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PER7: u16 = unsafe { ::core::mem::transmute(PER7) };
            PER7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMP0: u16 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CMP1: u16 = unsafe { ::core::mem::transmute(CMP1) };
            CMP1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TAMPER: u16 = unsafe { ::core::mem::transmute(TAMPER) };
            TAMPER as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVF: u16 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTENCLR_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_INTENCLR_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTENCLR_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_INTENCLR_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE1_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn PER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u16, CMP: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PER: u16 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let CMP: u16 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE1_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTENCLR_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTENCLR_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE2_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ALARM0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ALARM0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TAMPER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PER0: u16,
        PER1: u16,
        PER2: u16,
        PER3: u16,
        PER4: u16,
        PER5: u16,
        PER6: u16,
        PER7: u16,
        ALARM0: u16,
        TAMPER: u16,
        OVF: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PER0: u16 = unsafe { ::core::mem::transmute(PER0) };
            PER0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PER1: u16 = unsafe { ::core::mem::transmute(PER1) };
            PER1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PER2: u16 = unsafe { ::core::mem::transmute(PER2) };
            PER2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PER3: u16 = unsafe { ::core::mem::transmute(PER3) };
            PER3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PER4: u16 = unsafe { ::core::mem::transmute(PER4) };
            PER4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PER5: u16 = unsafe { ::core::mem::transmute(PER5) };
            PER5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PER6: u16 = unsafe { ::core::mem::transmute(PER6) };
            PER6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PER7: u16 = unsafe { ::core::mem::transmute(PER7) };
            PER7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ALARM0: u16 = unsafe { ::core::mem::transmute(ALARM0) };
            ALARM0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TAMPER: u16 = unsafe { ::core::mem::transmute(TAMPER) };
            TAMPER as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVF: u16 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTENCLR_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_INTENCLR_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTENCLR_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_INTENCLR_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE2_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn PER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ALARM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ALARM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u16, ALARM: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PER: u16 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ALARM: u16 = unsafe { ::core::mem::transmute(ALARM) };
            ALARM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE2_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTENCLR_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE2_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTENCLR_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE0_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TAMPER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PER0: u16,
        PER1: u16,
        PER2: u16,
        PER3: u16,
        PER4: u16,
        PER5: u16,
        PER6: u16,
        PER7: u16,
        CMP0: u16,
        TAMPER: u16,
        OVF: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PER0: u16 = unsafe { ::core::mem::transmute(PER0) };
            PER0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PER1: u16 = unsafe { ::core::mem::transmute(PER1) };
            PER1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PER2: u16 = unsafe { ::core::mem::transmute(PER2) };
            PER2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PER3: u16 = unsafe { ::core::mem::transmute(PER3) };
            PER3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PER4: u16 = unsafe { ::core::mem::transmute(PER4) };
            PER4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PER5: u16 = unsafe { ::core::mem::transmute(PER5) };
            PER5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PER6: u16 = unsafe { ::core::mem::transmute(PER6) };
            PER6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PER7: u16 = unsafe { ::core::mem::transmute(PER7) };
            PER7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMP0: u16 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TAMPER: u16 = unsafe { ::core::mem::transmute(TAMPER) };
            TAMPER as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVF: u16 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTENSET_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_INTENSET_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTENSET_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_INTENSET_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE0_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn PER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u16, CMP: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PER: u16 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMP: u16 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE0_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTENSET_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE0_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTENSET_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE1_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMP1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TAMPER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PER0: u16,
        PER1: u16,
        PER2: u16,
        PER3: u16,
        PER4: u16,
        PER5: u16,
        PER6: u16,
        PER7: u16,
        CMP0: u16,
        CMP1: u16,
        TAMPER: u16,
        OVF: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PER0: u16 = unsafe { ::core::mem::transmute(PER0) };
            PER0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PER1: u16 = unsafe { ::core::mem::transmute(PER1) };
            PER1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PER2: u16 = unsafe { ::core::mem::transmute(PER2) };
            PER2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PER3: u16 = unsafe { ::core::mem::transmute(PER3) };
            PER3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PER4: u16 = unsafe { ::core::mem::transmute(PER4) };
            PER4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PER5: u16 = unsafe { ::core::mem::transmute(PER5) };
            PER5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PER6: u16 = unsafe { ::core::mem::transmute(PER6) };
            PER6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PER7: u16 = unsafe { ::core::mem::transmute(PER7) };
            PER7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMP0: u16 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CMP1: u16 = unsafe { ::core::mem::transmute(CMP1) };
            CMP1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TAMPER: u16 = unsafe { ::core::mem::transmute(TAMPER) };
            TAMPER as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVF: u16 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTENSET_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_INTENSET_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTENSET_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_INTENSET_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE1_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn PER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u16, CMP: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PER: u16 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let CMP: u16 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE1_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTENSET_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTENSET_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE2_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ALARM0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ALARM0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TAMPER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PER0: u16,
        PER1: u16,
        PER2: u16,
        PER3: u16,
        PER4: u16,
        PER5: u16,
        PER6: u16,
        PER7: u16,
        ALARM0: u16,
        TAMPER: u16,
        OVF: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PER0: u16 = unsafe { ::core::mem::transmute(PER0) };
            PER0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PER1: u16 = unsafe { ::core::mem::transmute(PER1) };
            PER1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PER2: u16 = unsafe { ::core::mem::transmute(PER2) };
            PER2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PER3: u16 = unsafe { ::core::mem::transmute(PER3) };
            PER3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PER4: u16 = unsafe { ::core::mem::transmute(PER4) };
            PER4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PER5: u16 = unsafe { ::core::mem::transmute(PER5) };
            PER5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PER6: u16 = unsafe { ::core::mem::transmute(PER6) };
            PER6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PER7: u16 = unsafe { ::core::mem::transmute(PER7) };
            PER7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ALARM0: u16 = unsafe { ::core::mem::transmute(ALARM0) };
            ALARM0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TAMPER: u16 = unsafe { ::core::mem::transmute(TAMPER) };
            TAMPER as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVF: u16 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTENSET_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_INTENSET_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTENSET_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_INTENSET_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE2_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn PER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ALARM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ALARM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u16, ALARM: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PER: u16 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ALARM: u16 = unsafe { ::core::mem::transmute(ALARM) };
            ALARM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE2_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTENSET_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE2_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTENSET_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE0_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TAMPER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PER0: u16,
        PER1: u16,
        PER2: u16,
        PER3: u16,
        PER4: u16,
        PER5: u16,
        PER6: u16,
        PER7: u16,
        CMP0: u16,
        TAMPER: u16,
        OVF: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PER0: u16 = unsafe { ::core::mem::transmute(PER0) };
            PER0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PER1: u16 = unsafe { ::core::mem::transmute(PER1) };
            PER1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PER2: u16 = unsafe { ::core::mem::transmute(PER2) };
            PER2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PER3: u16 = unsafe { ::core::mem::transmute(PER3) };
            PER3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PER4: u16 = unsafe { ::core::mem::transmute(PER4) };
            PER4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PER5: u16 = unsafe { ::core::mem::transmute(PER5) };
            PER5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PER6: u16 = unsafe { ::core::mem::transmute(PER6) };
            PER6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PER7: u16 = unsafe { ::core::mem::transmute(PER7) };
            PER7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMP0: u16 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TAMPER: u16 = unsafe { ::core::mem::transmute(TAMPER) };
            TAMPER as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVF: u16 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTFLAG_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_INTFLAG_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTFLAG_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_INTFLAG_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE0_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn PER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u16, CMP: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PER: u16 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMP: u16 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE0_INTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_INTFLAG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE0_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_INTFLAG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE1_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CMP1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TAMPER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PER0: u16,
        PER1: u16,
        PER2: u16,
        PER3: u16,
        PER4: u16,
        PER5: u16,
        PER6: u16,
        PER7: u16,
        CMP0: u16,
        CMP1: u16,
        TAMPER: u16,
        OVF: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PER0: u16 = unsafe { ::core::mem::transmute(PER0) };
            PER0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PER1: u16 = unsafe { ::core::mem::transmute(PER1) };
            PER1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PER2: u16 = unsafe { ::core::mem::transmute(PER2) };
            PER2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PER3: u16 = unsafe { ::core::mem::transmute(PER3) };
            PER3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PER4: u16 = unsafe { ::core::mem::transmute(PER4) };
            PER4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PER5: u16 = unsafe { ::core::mem::transmute(PER5) };
            PER5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PER6: u16 = unsafe { ::core::mem::transmute(PER6) };
            PER6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PER7: u16 = unsafe { ::core::mem::transmute(PER7) };
            PER7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CMP0: u16 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CMP1: u16 = unsafe { ::core::mem::transmute(CMP1) };
            CMP1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TAMPER: u16 = unsafe { ::core::mem::transmute(TAMPER) };
            TAMPER as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVF: u16 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTFLAG_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_INTFLAG_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTFLAG_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_INTFLAG_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE1_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn PER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u16, CMP: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PER: u16 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let CMP: u16 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE1_INTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_INTFLAG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_INTFLAG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE2_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PER7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ALARM0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ALARM0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TAMPER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PER0: u16,
        PER1: u16,
        PER2: u16,
        PER3: u16,
        PER4: u16,
        PER5: u16,
        PER6: u16,
        PER7: u16,
        ALARM0: u16,
        TAMPER: u16,
        OVF: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PER0: u16 = unsafe { ::core::mem::transmute(PER0) };
            PER0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PER1: u16 = unsafe { ::core::mem::transmute(PER1) };
            PER1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PER2: u16 = unsafe { ::core::mem::transmute(PER2) };
            PER2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PER3: u16 = unsafe { ::core::mem::transmute(PER3) };
            PER3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PER4: u16 = unsafe { ::core::mem::transmute(PER4) };
            PER4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PER5: u16 = unsafe { ::core::mem::transmute(PER5) };
            PER5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PER6: u16 = unsafe { ::core::mem::transmute(PER6) };
            PER6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PER7: u16 = unsafe { ::core::mem::transmute(PER7) };
            PER7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ALARM0: u16 = unsafe { ::core::mem::transmute(ALARM0) };
            ALARM0 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TAMPER: u16 = unsafe { ::core::mem::transmute(TAMPER) };
            TAMPER as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let OVF: u16 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTFLAG_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_INTFLAG_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTFLAG_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_INTFLAG_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE2_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn PER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ALARM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ALARM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u16, ALARM: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PER: u16 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ALARM: u16 = unsafe { ::core::mem::transmute(ALARM) };
            ALARM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE2_INTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_INTFLAG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE2_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_INTFLAG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_RTC_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_DBGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_DBGCTRL_Type__bindgen_ty_1))
    );
}
impl RTC_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGRUN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGRUN: u8 = unsafe { ::core::mem::transmute(DBGRUN) };
            DBGRUN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_DBGCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_DBGCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE0_SYNCBUSY_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FREQCORR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FREQCORR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMP0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COMP0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COUNTSYNC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COUNTSYNC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GP0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GP0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GP1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GP1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        FREQCORR: u32,
        COUNT: u32,
        COMP0: u32,
        COUNTSYNC: u32,
        GP0: u32,
        GP1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FREQCORR: u32 = unsafe { ::core::mem::transmute(FREQCORR) };
            FREQCORR as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let COMP0: u32 = unsafe { ::core::mem::transmute(COMP0) };
            COMP0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let COUNTSYNC: u32 = unsafe { ::core::mem::transmute(COUNTSYNC) };
            COUNTSYNC as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let GP0: u32 = unsafe { ::core::mem::transmute(GP0) };
            GP0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let GP1: u32 = unsafe { ::core::mem::transmute(GP1) };
            GP1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_SYNCBUSY_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_SYNCBUSY_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_SYNCBUSY_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_SYNCBUSY_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE0_SYNCBUSY_Type__bindgen_ty_2 {
    #[inline]
    pub fn COMP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COMP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_GP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP: u32, GP: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let COMP: u32 = unsafe { ::core::mem::transmute(COMP) };
            COMP as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let GP: u32 = unsafe { ::core::mem::transmute(GP) };
            GP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE0_SYNCBUSY_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_SYNCBUSY_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE1_SYNCBUSY_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FREQCORR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FREQCORR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMP0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COMP0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COMP1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COMP1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COUNTSYNC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COUNTSYNC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GP0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GP0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GP1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GP1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        FREQCORR: u32,
        COUNT: u32,
        PER: u32,
        COMP0: u32,
        COMP1: u32,
        COUNTSYNC: u32,
        GP0: u32,
        GP1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FREQCORR: u32 = unsafe { ::core::mem::transmute(FREQCORR) };
            FREQCORR as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PER: u32 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let COMP0: u32 = unsafe { ::core::mem::transmute(COMP0) };
            COMP0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let COMP1: u32 = unsafe { ::core::mem::transmute(COMP1) };
            COMP1 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let COUNTSYNC: u32 = unsafe { ::core::mem::transmute(COUNTSYNC) };
            COUNTSYNC as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let GP0: u32 = unsafe { ::core::mem::transmute(GP0) };
            GP0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let GP1: u32 = unsafe { ::core::mem::transmute(GP1) };
            GP1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_SYNCBUSY_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_SYNCBUSY_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_SYNCBUSY_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_SYNCBUSY_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE1_SYNCBUSY_Type__bindgen_ty_2 {
    #[inline]
    pub fn COMP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_COMP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn GP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_GP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP: u32, GP: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let COMP: u32 = unsafe { ::core::mem::transmute(COMP) };
            COMP as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let GP: u32 = unsafe { ::core::mem::transmute(GP) };
            GP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE1_SYNCBUSY_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE1_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_SYNCBUSY_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_MODE2_SYNCBUSY_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FREQCORR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FREQCORR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLOCK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CLOCK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ALARM0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ALARM0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MASK0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MASK0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLOCKSYNC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CLOCKSYNC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GP0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GP0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GP1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GP1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        FREQCORR: u32,
        CLOCK: u32,
        ALARM0: u32,
        MASK0: u32,
        CLOCKSYNC: u32,
        GP0: u32,
        GP1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FREQCORR: u32 = unsafe { ::core::mem::transmute(FREQCORR) };
            FREQCORR as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CLOCK: u32 = unsafe { ::core::mem::transmute(CLOCK) };
            CLOCK as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ALARM0: u32 = unsafe { ::core::mem::transmute(ALARM0) };
            ALARM0 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let MASK0: u32 = unsafe { ::core::mem::transmute(MASK0) };
            MASK0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let CLOCKSYNC: u32 = unsafe { ::core::mem::transmute(CLOCKSYNC) };
            CLOCKSYNC as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let GP0: u32 = unsafe { ::core::mem::transmute(GP0) };
            GP0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let GP1: u32 = unsafe { ::core::mem::transmute(GP1) };
            GP1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_SYNCBUSY_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_SYNCBUSY_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_SYNCBUSY_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_SYNCBUSY_Type__bindgen_ty_2)
        )
    );
}
impl RTC_MODE2_SYNCBUSY_Type__bindgen_ty_2 {
    #[inline]
    pub fn ALARM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ALARM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MASK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MASK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_GP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ALARM: u32, MASK: u32, GP: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ALARM: u32 = unsafe { ::core::mem::transmute(ALARM) };
            ALARM as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let MASK: u32 = unsafe { ::core::mem::transmute(MASK) };
            MASK as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let GP: u32 = unsafe { ::core::mem::transmute(GP) };
            GP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE2_SYNCBUSY_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_SYNCBUSY_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_FREQCORR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_FREQCORR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_FREQCORR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_RTC_FREQCORR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_FREQCORR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_FREQCORR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_FREQCORR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_FREQCORR_Type__bindgen_ty_1))
    );
}
impl RTC_FREQCORR_Type__bindgen_ty_1 {
    #[inline]
    pub fn VALUE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_VALUE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn SIGN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SIGN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(VALUE: u8, SIGN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let VALUE: u8 = unsafe { ::core::mem::transmute(VALUE) };
            VALUE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let SIGN: u8 = unsafe { ::core::mem::transmute(SIGN) };
            SIGN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_FREQCORR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_FREQCORR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_FREQCORR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_FREQCORR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_FREQCORR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_FREQCORR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_FREQCORR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_FREQCORR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_COUNT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_COUNT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_COUNT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_COUNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_COUNT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_COUNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_COUNT_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_COUNT_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_COUNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_COUNT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE0_COUNT_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_COUNT_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_COUNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_COUNT_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_COUNT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_COUNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_COUNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_COUNT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_COUNT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_COUNT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_COUNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_COUNT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_COUNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_COUNT_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_COUNT_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_COUNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let COUNT: u16 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_COUNT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE1_COUNT_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_COUNT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_COUNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_COUNT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_COUNT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_COUNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_COUNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_CLOCK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_CLOCK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_CLOCK_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_CLOCK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_CLOCK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_CLOCK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_CLOCK_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_CLOCK_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_CLOCK_Type__bindgen_ty_1 {
    #[inline]
    pub fn SECOND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_SECOND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn MINUTE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_MINUTE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn HOUR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_HOUR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn DAY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DAY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn MONTH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MONTH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn YEAR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_YEAR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SECOND: u32,
        MINUTE: u32,
        HOUR: u32,
        DAY: u32,
        MONTH: u32,
        YEAR: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let SECOND: u32 = unsafe { ::core::mem::transmute(SECOND) };
            SECOND as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let MINUTE: u32 = unsafe { ::core::mem::transmute(MINUTE) };
            MINUTE as u64
        });
        __bindgen_bitfield_unit.set(12usize, 5u8, {
            let HOUR: u32 = unsafe { ::core::mem::transmute(HOUR) };
            HOUR as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let DAY: u32 = unsafe { ::core::mem::transmute(DAY) };
            DAY as u64
        });
        __bindgen_bitfield_unit.set(22usize, 4u8, {
            let MONTH: u32 = unsafe { ::core::mem::transmute(MONTH) };
            MONTH as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let YEAR: u32 = unsafe { ::core::mem::transmute(YEAR) };
            YEAR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_CLOCK_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE2_CLOCK_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_CLOCK_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_CLOCK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_CLOCK_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_CLOCK_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_CLOCK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_CLOCK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_PER_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_PER_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_PER_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_PER_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_PER_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_PER_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_PER_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_PER_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_PER_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let PER: u16 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_PER_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE1_PER_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_PER_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_PER_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_PER_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_PER_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_PER_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_PER_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_COMP_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_COMP_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_COMP_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_COMP_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_COMP_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_COMP_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_COMP_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_COMP_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_COMP_Type__bindgen_ty_1 {
    #[inline]
    pub fn COMP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_COMP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let COMP: u32 = unsafe { ::core::mem::transmute(COMP) };
            COMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_COMP_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE0_COMP_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_COMP_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_COMP_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_COMP_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_COMP_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_COMP_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_COMP_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_COMP_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_COMP_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_COMP_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_COMP_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_COMP_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_COMP_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_COMP_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_COMP_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_COMP_Type__bindgen_ty_1 {
    #[inline]
    pub fn COMP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_COMP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COMP: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let COMP: u16 = unsafe { ::core::mem::transmute(COMP) };
            COMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_COMP_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE1_COMP_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_COMP_Type>(),
        2usize,
        concat!("Size of: ", stringify!(RTC_MODE1_COMP_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_COMP_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_COMP_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_COMP_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_COMP_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_ALARM_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_ALARM_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_ALARM_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_ALARM_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_ALARM_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_ALARM_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_ALARM_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_ALARM_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_ALARM_Type__bindgen_ty_1 {
    #[inline]
    pub fn SECOND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_SECOND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn MINUTE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_MINUTE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn HOUR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_HOUR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn DAY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DAY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn MONTH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MONTH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn YEAR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_YEAR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SECOND: u32,
        MINUTE: u32,
        HOUR: u32,
        DAY: u32,
        MONTH: u32,
        YEAR: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let SECOND: u32 = unsafe { ::core::mem::transmute(SECOND) };
            SECOND as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let MINUTE: u32 = unsafe { ::core::mem::transmute(MINUTE) };
            MINUTE as u64
        });
        __bindgen_bitfield_unit.set(12usize, 5u8, {
            let HOUR: u32 = unsafe { ::core::mem::transmute(HOUR) };
            HOUR as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let DAY: u32 = unsafe { ::core::mem::transmute(DAY) };
            DAY as u64
        });
        __bindgen_bitfield_unit.set(22usize, 4u8, {
            let MONTH: u32 = unsafe { ::core::mem::transmute(MONTH) };
            MONTH as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let YEAR: u32 = unsafe { ::core::mem::transmute(YEAR) };
            YEAR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_ALARM_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE2_ALARM_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_ALARM_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_ALARM_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_ALARM_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_ALARM_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_ALARM_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_ALARM_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_MASK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_MASK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_MASK_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_MASK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_MASK_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE2_MASK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_MASK_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_MASK_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_MASK_Type__bindgen_ty_1 {
    #[inline]
    pub fn SEL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SEL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SEL: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SEL: u8 = unsafe { ::core::mem::transmute(SEL) };
            SEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_MASK_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE2_MASK_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_MASK_Type>(),
        1usize,
        concat!("Size of: ", stringify!(RTC_MODE2_MASK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_MASK_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_MASK_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_MASK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_MASK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_GP_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_GP_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_GP_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_GP_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_GP_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_GP_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_GP_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_GP_Type__bindgen_ty_1))
    );
}
impl RTC_GP_Type__bindgen_ty_1 {
    #[inline]
    pub fn GP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_GP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(GP: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let GP: u32 = unsafe { ::core::mem::transmute(GP) };
            GP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_GP_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_GP_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_GP_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_GP_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_GP_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_GP_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_GP_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_GP_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_TAMPCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_TAMPCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_TAMPCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_TAMPCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_TAMPCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_TAMPCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_TAMPCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TAMPCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TAMPCTRL_Type__bindgen_ty_1))
    );
}
impl RTC_TAMPCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn IN0ACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_IN0ACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn IN1ACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_IN1ACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn IN2ACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_IN2ACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn IN3ACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_IN3ACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn IN4ACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_IN4ACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMLVL0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMLVL0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMLVL1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMLVL1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMLVL2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMLVL2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMLVL3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMLVL3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMLVL4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMLVL4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBNC0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DEBNC0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBNC1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DEBNC1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBNC2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DEBNC2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBNC3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DEBNC3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBNC4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DEBNC4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IN0ACT: u32,
        IN1ACT: u32,
        IN2ACT: u32,
        IN3ACT: u32,
        IN4ACT: u32,
        TAMLVL0: u32,
        TAMLVL1: u32,
        TAMLVL2: u32,
        TAMLVL3: u32,
        TAMLVL4: u32,
        DEBNC0: u32,
        DEBNC1: u32,
        DEBNC2: u32,
        DEBNC3: u32,
        DEBNC4: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let IN0ACT: u32 = unsafe { ::core::mem::transmute(IN0ACT) };
            IN0ACT as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let IN1ACT: u32 = unsafe { ::core::mem::transmute(IN1ACT) };
            IN1ACT as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let IN2ACT: u32 = unsafe { ::core::mem::transmute(IN2ACT) };
            IN2ACT as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let IN3ACT: u32 = unsafe { ::core::mem::transmute(IN3ACT) };
            IN3ACT as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let IN4ACT: u32 = unsafe { ::core::mem::transmute(IN4ACT) };
            IN4ACT as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let TAMLVL0: u32 = unsafe { ::core::mem::transmute(TAMLVL0) };
            TAMLVL0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let TAMLVL1: u32 = unsafe { ::core::mem::transmute(TAMLVL1) };
            TAMLVL1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let TAMLVL2: u32 = unsafe { ::core::mem::transmute(TAMLVL2) };
            TAMLVL2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let TAMLVL3: u32 = unsafe { ::core::mem::transmute(TAMLVL3) };
            TAMLVL3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let TAMLVL4: u32 = unsafe { ::core::mem::transmute(TAMLVL4) };
            TAMLVL4 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let DEBNC0: u32 = unsafe { ::core::mem::transmute(DEBNC0) };
            DEBNC0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let DEBNC1: u32 = unsafe { ::core::mem::transmute(DEBNC1) };
            DEBNC1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let DEBNC2: u32 = unsafe { ::core::mem::transmute(DEBNC2) };
            DEBNC2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let DEBNC3: u32 = unsafe { ::core::mem::transmute(DEBNC3) };
            DEBNC3 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let DEBNC4: u32 = unsafe { ::core::mem::transmute(DEBNC4) };
            DEBNC4 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_TAMPCTRL_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_TAMPCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_TAMPCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_TAMPCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TAMPCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TAMPCTRL_Type__bindgen_ty_2))
    );
}
impl RTC_TAMPCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn TAMLVL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_TAMLVL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn DEBNC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DEBNC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(TAMLVL: u32, DEBNC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let TAMLVL: u32 = unsafe { ::core::mem::transmute(TAMLVL) };
            TAMLVL as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let DEBNC: u32 = unsafe { ::core::mem::transmute(DEBNC) };
            DEBNC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_TAMPCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_TAMPCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_TAMPCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_TAMPCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TAMPCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TAMPCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TAMPCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TAMPCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TAMPCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE0_TIMESTAMP_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE0_TIMESTAMP_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE0_TIMESTAMP_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE0_TIMESTAMP_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_TIMESTAMP_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE0_TIMESTAMP_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_TIMESTAMP_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE0_TIMESTAMP_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE0_TIMESTAMP_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE0_TIMESTAMP_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE0_TIMESTAMP_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE0_TIMESTAMP_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE0_TIMESTAMP_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE0_TIMESTAMP_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE0_TIMESTAMP_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_TIMESTAMP_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE0_TIMESTAMP_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE1_TIMESTAMP_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE1_TIMESTAMP_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE1_TIMESTAMP_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE1_TIMESTAMP_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_TIMESTAMP_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE1_TIMESTAMP_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_TIMESTAMP_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE1_TIMESTAMP_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE1_TIMESTAMP_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE1_TIMESTAMP_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE1_TIMESTAMP_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE1_TIMESTAMP_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE1_TIMESTAMP_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE1_TIMESTAMP_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE1_TIMESTAMP_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_TIMESTAMP_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE1_TIMESTAMP_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_MODE2_TIMESTAMP_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_MODE2_TIMESTAMP_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_MODE2_TIMESTAMP_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_MODE2_TIMESTAMP_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_TIMESTAMP_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(RTC_MODE2_TIMESTAMP_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_TIMESTAMP_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(RTC_MODE2_TIMESTAMP_Type__bindgen_ty_1)
        )
    );
}
impl RTC_MODE2_TIMESTAMP_Type__bindgen_ty_1 {
    #[inline]
    pub fn SECOND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_SECOND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn MINUTE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_MINUTE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn HOUR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_HOUR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn DAY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DAY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn MONTH(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MONTH(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn YEAR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_YEAR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SECOND: u32,
        MINUTE: u32,
        HOUR: u32,
        DAY: u32,
        MONTH: u32,
        YEAR: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let SECOND: u32 = unsafe { ::core::mem::transmute(SECOND) };
            SECOND as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let MINUTE: u32 = unsafe { ::core::mem::transmute(MINUTE) };
            MINUTE as u64
        });
        __bindgen_bitfield_unit.set(12usize, 5u8, {
            let HOUR: u32 = unsafe { ::core::mem::transmute(HOUR) };
            HOUR as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let DAY: u32 = unsafe { ::core::mem::transmute(DAY) };
            DAY as u64
        });
        __bindgen_bitfield_unit.set(22usize, 4u8, {
            let MONTH: u32 = unsafe { ::core::mem::transmute(MONTH) };
            MONTH as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let YEAR: u32 = unsafe { ::core::mem::transmute(YEAR) };
            YEAR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_MODE2_TIMESTAMP_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_MODE2_TIMESTAMP_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_MODE2_TIMESTAMP_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_MODE2_TIMESTAMP_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_MODE2_TIMESTAMP_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_MODE2_TIMESTAMP_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_TIMESTAMP_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_MODE2_TIMESTAMP_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_TAMPID_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_TAMPID_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: RTC_TAMPID_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_TAMPID_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_TAMPID_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_TAMPID_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_TAMPID_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TAMPID_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TAMPID_Type__bindgen_ty_1))
    );
}
impl RTC_TAMPID_Type__bindgen_ty_1 {
    #[inline]
    pub fn TAMPID0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPID0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPID1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPID1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPID2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPID2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPID3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPID3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPID4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPID4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TAMPEVT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPEVT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TAMPID0: u32,
        TAMPID1: u32,
        TAMPID2: u32,
        TAMPID3: u32,
        TAMPID4: u32,
        TAMPEVT: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TAMPID0: u32 = unsafe { ::core::mem::transmute(TAMPID0) };
            TAMPID0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TAMPID1: u32 = unsafe { ::core::mem::transmute(TAMPID1) };
            TAMPID1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let TAMPID2: u32 = unsafe { ::core::mem::transmute(TAMPID2) };
            TAMPID2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let TAMPID3: u32 = unsafe { ::core::mem::transmute(TAMPID3) };
            TAMPID3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let TAMPID4: u32 = unsafe { ::core::mem::transmute(TAMPID4) };
            TAMPID4 as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let TAMPEVT: u32 = unsafe { ::core::mem::transmute(TAMPEVT) };
            TAMPEVT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_TAMPID_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_TAMPID_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RTC_TAMPID_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_TAMPID_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TAMPID_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TAMPID_Type__bindgen_ty_2))
    );
}
impl RTC_TAMPID_Type__bindgen_ty_2 {
    #[inline]
    pub fn TAMPID(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_TAMPID(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(TAMPID: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let TAMPID: u32 = unsafe { ::core::mem::transmute(TAMPID) };
            TAMPID as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_TAMPID_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_TAMPID_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_TAMPID_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_TAMPID_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_TAMPID_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_TAMPID_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TAMPID_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TAMPID_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_TAMPID_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RTC_BKUP_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: RTC_BKUP_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct RTC_BKUP_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_RTC_BKUP_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RTC_BKUP_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_BKUP_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_BKUP_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_BKUP_Type__bindgen_ty_1))
    );
}
impl RTC_BKUP_Type__bindgen_ty_1 {
    #[inline]
    pub fn BKUP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_BKUP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BKUP: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let BKUP: u32 = unsafe { ::core::mem::transmute(BKUP) };
            BKUP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RTC_BKUP_Type() {
    const UNINIT: ::core::mem::MaybeUninit<RTC_BKUP_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RTC_BKUP_Type>(),
        4usize,
        concat!("Size of: ", stringify!(RTC_BKUP_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<RTC_BKUP_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(RTC_BKUP_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_BKUP_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RTC_BKUP_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RtcMode2Alarm {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) MODE2_ALARM Alarm n Value"]
    pub ALARM: RTC_MODE2_ALARM_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) MODE2_ALARM Alarm n Mask"]
    pub MASK: RTC_MODE2_MASK_Type,
    pub Reserved1: [RoReg8; 3usize],
}
#[test]
fn bindgen_test_layout_RtcMode2Alarm() {
    const UNINIT: ::core::mem::MaybeUninit<RtcMode2Alarm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RtcMode2Alarm>(),
        8usize,
        concat!("Size of: ", stringify!(RtcMode2Alarm))
    );
    assert_eq!(
        ::core::mem::align_of::<RtcMode2Alarm>(),
        4usize,
        concat!("Alignment of ", stringify!(RtcMode2Alarm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ALARM) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2Alarm),
            "::",
            stringify!(ALARM)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MASK) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2Alarm),
            "::",
            stringify!(MASK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2Alarm),
            "::",
            stringify!(Reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RtcMode0 {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) MODE0 Control A"]
    pub CTRLA: RTC_MODE0_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) MODE0 Control B"]
    pub CTRLB: RTC_MODE0_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) MODE0 Event Control"]
    pub EVCTRL: RTC_MODE0_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 16) MODE0 Interrupt Enable Clear"]
    pub INTENCLR: RTC_MODE0_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x0A (R/W 16) MODE0 Interrupt Enable Set"]
    pub INTENSET: RTC_MODE0_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W 16) MODE0 Interrupt Flag Status and Clear"]
    pub INTFLAG: RTC_MODE0_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0E (R/W  8) Debug Control"]
    pub DBGCTRL: RTC_DBGCTRL_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x10 (R/  32) MODE0 Synchronization Busy Status"]
    pub SYNCBUSY: RTC_MODE0_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W  8) Frequency Correction"]
    pub FREQCORR: RTC_FREQCORR_Type,
    pub Reserved2: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x18 (R/W 32) MODE0 Counter Value"]
    pub COUNT: RTC_MODE0_COUNT_Type,
    pub Reserved3: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x20 (R/W 32) MODE0 Compare n Value"]
    pub COMP: [RTC_MODE0_COMP_Type; 1usize],
    pub Reserved4: [RoReg8; 28usize],
    #[doc = "< \\brief Offset: 0x40 (R/W 32) General Purpose"]
    pub GP: [RTC_GP_Type; 2usize],
    pub Reserved5: [RoReg8; 24usize],
    #[doc = "< \\brief Offset: 0x60 (R/W 32) Tamper Control"]
    pub TAMPCTRL: RTC_TAMPCTRL_Type,
    #[doc = "< \\brief Offset: 0x64 (R/  32) MODE0 Timestamp"]
    pub TIMESTAMP: RTC_MODE0_TIMESTAMP_Type,
    #[doc = "< \\brief Offset: 0x68 (R/W 32) Tamper ID"]
    pub TAMPID: RTC_TAMPID_Type,
    pub Reserved6: [RoReg8; 20usize],
    #[doc = "< \\brief Offset: 0x80 (R/W 32) Backup"]
    pub BKUP: [RTC_BKUP_Type; 8usize],
}
#[test]
fn bindgen_test_layout_RtcMode0() {
    const UNINIT: ::core::mem::MaybeUninit<RtcMode0> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RtcMode0>(),
        160usize,
        concat!("Size of: ", stringify!(RtcMode0))
    );
    assert_eq!(
        ::core::mem::align_of::<RtcMode0>(),
        4usize,
        concat!("Alignment of ", stringify!(RtcMode0))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FREQCORR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(FREQCORR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COUNT) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(COUNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COMP) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(COMP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GP) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(GP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TAMPCTRL) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(TAMPCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TIMESTAMP) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(TIMESTAMP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TAMPID) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(TAMPID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKUP) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode0),
            "::",
            stringify!(BKUP)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RtcMode1 {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) MODE1 Control A"]
    pub CTRLA: RTC_MODE1_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) MODE1 Control B"]
    pub CTRLB: RTC_MODE1_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) MODE1 Event Control"]
    pub EVCTRL: RTC_MODE1_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 16) MODE1 Interrupt Enable Clear"]
    pub INTENCLR: RTC_MODE1_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x0A (R/W 16) MODE1 Interrupt Enable Set"]
    pub INTENSET: RTC_MODE1_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W 16) MODE1 Interrupt Flag Status and Clear"]
    pub INTFLAG: RTC_MODE1_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0E (R/W  8) Debug Control"]
    pub DBGCTRL: RTC_DBGCTRL_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x10 (R/  32) MODE1 Synchronization Busy Status"]
    pub SYNCBUSY: RTC_MODE1_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W  8) Frequency Correction"]
    pub FREQCORR: RTC_FREQCORR_Type,
    pub Reserved2: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x18 (R/W 16) MODE1 Counter Value"]
    pub COUNT: RTC_MODE1_COUNT_Type,
    pub Reserved3: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x1C (R/W 16) MODE1 Counter Period"]
    pub PER: RTC_MODE1_PER_Type,
    pub Reserved4: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x20 (R/W 16) MODE1 Compare n Value"]
    pub COMP: [RTC_MODE1_COMP_Type; 2usize],
    pub Reserved5: [RoReg8; 28usize],
    #[doc = "< \\brief Offset: 0x40 (R/W 32) General Purpose"]
    pub GP: [RTC_GP_Type; 2usize],
    pub Reserved6: [RoReg8; 24usize],
    #[doc = "< \\brief Offset: 0x60 (R/W 32) Tamper Control"]
    pub TAMPCTRL: RTC_TAMPCTRL_Type,
    #[doc = "< \\brief Offset: 0x64 (R/  32) MODE1 Timestamp"]
    pub TIMESTAMP: RTC_MODE1_TIMESTAMP_Type,
    #[doc = "< \\brief Offset: 0x68 (R/W 32) Tamper ID"]
    pub TAMPID: RTC_TAMPID_Type,
    pub Reserved7: [RoReg8; 20usize],
    #[doc = "< \\brief Offset: 0x80 (R/W 32) Backup"]
    pub BKUP: [RTC_BKUP_Type; 8usize],
}
#[test]
fn bindgen_test_layout_RtcMode1() {
    const UNINIT: ::core::mem::MaybeUninit<RtcMode1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RtcMode1>(),
        160usize,
        concat!("Size of: ", stringify!(RtcMode1))
    );
    assert_eq!(
        ::core::mem::align_of::<RtcMode1>(),
        4usize,
        concat!("Alignment of ", stringify!(RtcMode1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FREQCORR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(FREQCORR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COUNT) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(COUNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PER) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(PER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COMP) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(COMP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GP) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(GP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TAMPCTRL) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(TAMPCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TIMESTAMP) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(TIMESTAMP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TAMPID) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(TAMPID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved7) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(Reserved7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKUP) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode1),
            "::",
            stringify!(BKUP)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RtcMode2 {
    #[doc = "< \\brief Offset: 0x00 (R/W 16) MODE2 Control A"]
    pub CTRLA: RTC_MODE2_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x02 (R/W 16) MODE2 Control B"]
    pub CTRLB: RTC_MODE2_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) MODE2 Event Control"]
    pub EVCTRL: RTC_MODE2_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 16) MODE2 Interrupt Enable Clear"]
    pub INTENCLR: RTC_MODE2_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x0A (R/W 16) MODE2 Interrupt Enable Set"]
    pub INTENSET: RTC_MODE2_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W 16) MODE2 Interrupt Flag Status and Clear"]
    pub INTFLAG: RTC_MODE2_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0E (R/W  8) Debug Control"]
    pub DBGCTRL: RTC_DBGCTRL_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x10 (R/  32) MODE2 Synchronization Busy Status"]
    pub SYNCBUSY: RTC_MODE2_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W  8) Frequency Correction"]
    pub FREQCORR: RTC_FREQCORR_Type,
    pub Reserved2: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x18 (R/W 32) MODE2 Clock Value"]
    pub CLOCK: RTC_MODE2_CLOCK_Type,
    pub Reserved3: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x20 RtcMode2Alarm groups [ALARM_NUM]"]
    pub Mode2Alarm: [RtcMode2Alarm; 1usize],
    pub Reserved4: [RoReg8; 24usize],
    #[doc = "< \\brief Offset: 0x40 (R/W 32) General Purpose"]
    pub GP: [RTC_GP_Type; 2usize],
    pub Reserved5: [RoReg8; 24usize],
    #[doc = "< \\brief Offset: 0x60 (R/W 32) Tamper Control"]
    pub TAMPCTRL: RTC_TAMPCTRL_Type,
    #[doc = "< \\brief Offset: 0x64 (R/  32) MODE2 Timestamp"]
    pub TIMESTAMP: RTC_MODE2_TIMESTAMP_Type,
    #[doc = "< \\brief Offset: 0x68 (R/W 32) Tamper ID"]
    pub TAMPID: RTC_TAMPID_Type,
    pub Reserved6: [RoReg8; 20usize],
    #[doc = "< \\brief Offset: 0x80 (R/W 32) Backup"]
    pub BKUP: [RTC_BKUP_Type; 8usize],
}
#[test]
fn bindgen_test_layout_RtcMode2() {
    const UNINIT: ::core::mem::MaybeUninit<RtcMode2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<RtcMode2>(),
        160usize,
        concat!("Size of: ", stringify!(RtcMode2))
    );
    assert_eq!(
        ::core::mem::align_of::<RtcMode2>(),
        4usize,
        concat!("Alignment of ", stringify!(RtcMode2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FREQCORR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(FREQCORR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CLOCK) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(CLOCK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode2Alarm) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(Mode2Alarm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GP) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(GP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TAMPCTRL) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(TAMPCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TIMESTAMP) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(TIMESTAMP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TAMPID) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(TAMPID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKUP) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(RtcMode2),
            "::",
            stringify!(BKUP)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Rtc {
    #[doc = "< \\brief Offset: 0x00 32-bit Counter with Single 32-bit Compare"]
    pub MODE0: RtcMode0,
    #[doc = "< \\brief Offset: 0x00 16-bit Counter with Two 16-bit Compares"]
    pub MODE1: RtcMode1,
    #[doc = "< \\brief Offset: 0x00 Clock/Calendar with Alarm"]
    pub MODE2: RtcMode2,
}
#[test]
fn bindgen_test_layout_Rtc() {
    const UNINIT: ::core::mem::MaybeUninit<Rtc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Rtc>(),
        160usize,
        concat!("Size of: ", stringify!(Rtc))
    );
    assert_eq!(
        ::core::mem::align_of::<Rtc>(),
        4usize,
        concat!("Alignment of ", stringify!(Rtc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MODE0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rtc),
            "::",
            stringify!(MODE0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MODE1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rtc),
            "::",
            stringify!(MODE1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MODE2) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rtc),
            "::",
            stringify!(MODE2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_CTRLA_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PINOUT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PINOUT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SDAHOLD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SDAHOLD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn MEXTTOEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MEXTTOEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SEXTTOEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SEXTTOEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPEED(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SPEED(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SCLSM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SCLSM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INACTOUT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_INACTOUT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LOWTOUTEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LOWTOUTEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        MODE: u32,
        RUNSTDBY: u32,
        PINOUT: u32,
        SDAHOLD: u32,
        MEXTTOEN: u32,
        SEXTTOEN: u32,
        SPEED: u32,
        SCLSM: u32,
        INACTOUT: u32,
        LOWTOUTEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let MODE: u32 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let PINOUT: u32 = unsafe { ::core::mem::transmute(PINOUT) };
            PINOUT as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let SDAHOLD: u32 = unsafe { ::core::mem::transmute(SDAHOLD) };
            SDAHOLD as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let MEXTTOEN: u32 = unsafe { ::core::mem::transmute(MEXTTOEN) };
            MEXTTOEN as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let SEXTTOEN: u32 = unsafe { ::core::mem::transmute(SEXTTOEN) };
            SEXTTOEN as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let SPEED: u32 = unsafe { ::core::mem::transmute(SPEED) };
            SPEED as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let SCLSM: u32 = unsafe { ::core::mem::transmute(SCLSM) };
            SCLSM as u64
        });
        __bindgen_bitfield_unit.set(28usize, 2u8, {
            let INACTOUT: u32 = unsafe { ::core::mem::transmute(INACTOUT) };
            INACTOUT as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let LOWTOUTEN: u32 = unsafe { ::core::mem::transmute(LOWTOUTEN) };
            LOWTOUTEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CM_CTRLA_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_CTRLA_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PINOUT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PINOUT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SDAHOLD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SDAHOLD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SEXTTOEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SEXTTOEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPEED(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SPEED(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SCLSM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SCLSM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LOWTOUTEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LOWTOUTEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        MODE: u32,
        RUNSTDBY: u32,
        PINOUT: u32,
        SDAHOLD: u32,
        SEXTTOEN: u32,
        SPEED: u32,
        SCLSM: u32,
        LOWTOUTEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let MODE: u32 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let PINOUT: u32 = unsafe { ::core::mem::transmute(PINOUT) };
            PINOUT as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let SDAHOLD: u32 = unsafe { ::core::mem::transmute(SDAHOLD) };
            SDAHOLD as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let SEXTTOEN: u32 = unsafe { ::core::mem::transmute(SEXTTOEN) };
            SEXTTOEN as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let SPEED: u32 = unsafe { ::core::mem::transmute(SPEED) };
            SPEED as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let SCLSM: u32 = unsafe { ::core::mem::transmute(SCLSM) };
            SCLSM as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let LOWTOUTEN: u32 = unsafe { ::core::mem::transmute(LOWTOUTEN) };
            LOWTOUTEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CS_CTRLA_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IBON(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IBON(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DOPO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_DOPO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DIPO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_DIPO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FORM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FORM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CPHA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPHA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPOL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPOL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DORD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DORD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        MODE: u32,
        RUNSTDBY: u32,
        IBON: u32,
        DOPO: u32,
        DIPO: u32,
        FORM: u32,
        CPHA: u32,
        CPOL: u32,
        DORD: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let MODE: u32 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IBON: u32 = unsafe { ::core::mem::transmute(IBON) };
            IBON as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let DOPO: u32 = unsafe { ::core::mem::transmute(DOPO) };
            DOPO as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let DIPO: u32 = unsafe { ::core::mem::transmute(DIPO) };
            DIPO as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let FORM: u32 = unsafe { ::core::mem::transmute(FORM) };
            FORM as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let CPHA: u32 = unsafe { ::core::mem::transmute(CPHA) };
            CPHA as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let CPOL: u32 = unsafe { ::core::mem::transmute(CPOL) };
            CPOL as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let DORD: u32 = unsafe { ::core::mem::transmute(DORD) };
            DORD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_SPI_CTRLA_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_CTRLA_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_CTRLA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IBON(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IBON(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXINV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TXINV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXINV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RXINV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SAMPR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SAMPR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn TXPO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TXPO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RXPO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RXPO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SAMPA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SAMPA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FORM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FORM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPOL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPOL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DORD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DORD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        MODE: u32,
        RUNSTDBY: u32,
        IBON: u32,
        TXINV: u32,
        RXINV: u32,
        SAMPR: u32,
        TXPO: u32,
        RXPO: u32,
        SAMPA: u32,
        FORM: u32,
        CMODE: u32,
        CPOL: u32,
        DORD: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let MODE: u32 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let IBON: u32 = unsafe { ::core::mem::transmute(IBON) };
            IBON as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TXINV: u32 = unsafe { ::core::mem::transmute(TXINV) };
            TXINV as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let RXINV: u32 = unsafe { ::core::mem::transmute(RXINV) };
            RXINV as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let SAMPR: u32 = unsafe { ::core::mem::transmute(SAMPR) };
            SAMPR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let TXPO: u32 = unsafe { ::core::mem::transmute(TXPO) };
            TXPO as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let RXPO: u32 = unsafe { ::core::mem::transmute(RXPO) };
            RXPO as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let SAMPA: u32 = unsafe { ::core::mem::transmute(SAMPA) };
            SAMPA as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let FORM: u32 = unsafe { ::core::mem::transmute(FORM) };
            FORM as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let CMODE: u32 = unsafe { ::core::mem::transmute(CMODE) };
            CMODE as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let CPOL: u32 = unsafe { ::core::mem::transmute(CPOL) };
            CPOL as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let DORD: u32 = unsafe { ::core::mem::transmute(DORD) };
            DORD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_CTRLA_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_USART_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_CTRLB_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn SMEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SMEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QCEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QCEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ACKACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ACKACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SMEN: u32,
        QCEN: u32,
        CMD: u32,
        ACKACT: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SMEN: u32 = unsafe { ::core::mem::transmute(SMEN) };
            SMEN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let QCEN: u32 = unsafe { ::core::mem::transmute(QCEN) };
            QCEN as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let CMD: u32 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ACKACT: u32 = unsafe { ::core::mem::transmute(ACKACT) };
            ACKACT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CM_CTRLB_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_CTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_CTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_CTRLB_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn SMEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SMEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GCMD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GCMD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AACKEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AACKEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_AMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ACKACT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ACKACT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SMEN: u32,
        GCMD: u32,
        AACKEN: u32,
        AMODE: u32,
        CMD: u32,
        ACKACT: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let SMEN: u32 = unsafe { ::core::mem::transmute(SMEN) };
            SMEN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let GCMD: u32 = unsafe { ::core::mem::transmute(GCMD) };
            GCMD as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let AACKEN: u32 = unsafe { ::core::mem::transmute(AACKEN) };
            AACKEN as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let AMODE: u32 = unsafe { ::core::mem::transmute(AMODE) };
            AMODE as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let CMD: u32 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let ACKACT: u32 = unsafe { ::core::mem::transmute(ACKACT) };
            ACKACT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CS_CTRLB_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_CTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_CTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn CHSIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_CHSIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn PLOADEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PLOADEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SSDE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SSDE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MSSEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MSSEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_AMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RXEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RXEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CHSIZE: u32,
        PLOADEN: u32,
        SSDE: u32,
        MSSEN: u32,
        AMODE: u32,
        RXEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let CHSIZE: u32 = unsafe { ::core::mem::transmute(CHSIZE) };
            CHSIZE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PLOADEN: u32 = unsafe { ::core::mem::transmute(PLOADEN) };
            PLOADEN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SSDE: u32 = unsafe { ::core::mem::transmute(SSDE) };
            SSDE as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let MSSEN: u32 = unsafe { ::core::mem::transmute(MSSEN) };
            MSSEN as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let AMODE: u32 = unsafe { ::core::mem::transmute(AMODE) };
            AMODE as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let RXEN: u32 = unsafe { ::core::mem::transmute(RXEN) };
            RXEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_SPI_CTRLB_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_CTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_CTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_CTRLB_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_CTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn CHSIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_CHSIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn SBMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SBMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COLDEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COLDEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SFDE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SFDE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PMODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PMODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TXEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RXEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CHSIZE: u32,
        SBMODE: u32,
        COLDEN: u32,
        SFDE: u32,
        ENC: u32,
        PMODE: u32,
        TXEN: u32,
        RXEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let CHSIZE: u32 = unsafe { ::core::mem::transmute(CHSIZE) };
            CHSIZE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SBMODE: u32 = unsafe { ::core::mem::transmute(SBMODE) };
            SBMODE as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let COLDEN: u32 = unsafe { ::core::mem::transmute(COLDEN) };
            COLDEN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SFDE: u32 = unsafe { ::core::mem::transmute(SFDE) };
            SFDE as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let ENC: u32 = unsafe { ::core::mem::transmute(ENC) };
            ENC as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PMODE: u32 = unsafe { ::core::mem::transmute(PMODE) };
            PMODE as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let TXEN: u32 = unsafe { ::core::mem::transmute(TXEN) };
            TXEN as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let RXEN: u32 = unsafe { ::core::mem::transmute(RXEN) };
            RXEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_CTRLB_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_CTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_USART_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_CTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_CTRLC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_CTRLC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_CTRLC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_CTRLC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_CTRLC_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_CTRLC_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_CTRLC_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_CTRLC_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_CTRLC_Type__bindgen_ty_1 {
    #[inline]
    pub fn GTIME(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_GTIME(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn INACK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INACK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DSNACK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DSNACK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MAXITER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_MAXITER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        GTIME: u32,
        INACK: u32,
        DSNACK: u32,
        MAXITER: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let GTIME: u32 = unsafe { ::core::mem::transmute(GTIME) };
            GTIME as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let INACK: u32 = unsafe { ::core::mem::transmute(INACK) };
            INACK as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let DSNACK: u32 = unsafe { ::core::mem::transmute(DSNACK) };
            DSNACK as u64
        });
        __bindgen_bitfield_unit.set(20usize, 3u8, {
            let MAXITER: u32 = unsafe { ::core::mem::transmute(MAXITER) };
            MAXITER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_CTRLC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_CTRLC_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_CTRLC_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_USART_CTRLC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_CTRLC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_CTRLC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_CTRLC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_CTRLC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_BAUD_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_BAUD_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_BAUD_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_BAUD_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_BAUD_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_BAUD_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_BAUD_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_BAUD_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_BAUD_Type__bindgen_ty_1 {
    #[inline]
    pub fn BAUD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn BAUDLOW(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BAUDLOW(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn HSBAUD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_HSBAUD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn HSBAUDLOW(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_HSBAUDLOW(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BAUD: u32,
        BAUDLOW: u32,
        HSBAUD: u32,
        HSBAUDLOW: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BAUD: u32 = unsafe { ::core::mem::transmute(BAUD) };
            BAUD as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let BAUDLOW: u32 = unsafe { ::core::mem::transmute(BAUDLOW) };
            BAUDLOW as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let HSBAUD: u32 = unsafe { ::core::mem::transmute(HSBAUD) };
            HSBAUD as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let HSBAUDLOW: u32 = unsafe { ::core::mem::transmute(HSBAUDLOW) };
            HSBAUDLOW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_BAUD_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CM_BAUD_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_BAUD_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_BAUD_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_BAUD_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_BAUD_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_BAUD_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_BAUD_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_BAUD_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_BAUD_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_BAUD_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_BAUD_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_BAUD_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_BAUD_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_BAUD_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_BAUD_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_BAUD_Type__bindgen_ty_1 {
    #[inline]
    pub fn BAUD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_BAUD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BAUD: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BAUD: u8 = unsafe { ::core::mem::transmute(BAUD) };
            BAUD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_BAUD_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_SPI_BAUD_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_BAUD_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_BAUD_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_BAUD_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_BAUD_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_BAUD_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_BAUD_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_BAUD_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_BAUD_Type__bindgen_ty_1,
    #[doc = "< Structure used for FRAC"]
    pub FRAC: SERCOM_USART_BAUD_Type__bindgen_ty_2,
    #[doc = "< Structure used for FRACFP"]
    pub FRACFP: SERCOM_USART_BAUD_Type__bindgen_ty_3,
    #[doc = "< Structure used for USARTFP"]
    pub USARTFP: SERCOM_USART_BAUD_Type__bindgen_ty_4,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_BAUD_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_BAUD_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_BAUD_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_BAUD_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_BAUD_Type__bindgen_ty_1 {
    #[inline]
    pub fn BAUD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_BAUD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BAUD: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let BAUD: u16 = unsafe { ::core::mem::transmute(BAUD) };
            BAUD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_BAUD_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_BAUD_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_BAUD_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_BAUD_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_2)
        )
    );
}
impl SERCOM_USART_BAUD_Type__bindgen_ty_2 {
    #[inline]
    pub fn BAUD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_BAUD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn FP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_FP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BAUD: u16, FP: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 13u8, {
            let BAUD: u16 = unsafe { ::core::mem::transmute(BAUD) };
            BAUD as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let FP: u16 = unsafe { ::core::mem::transmute(FP) };
            FP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_BAUD_Type__bindgen_ty_3 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_BAUD_Type__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_BAUD_Type__bindgen_ty_3>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_BAUD_Type__bindgen_ty_3>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_3)
        )
    );
}
impl SERCOM_USART_BAUD_Type__bindgen_ty_3 {
    #[inline]
    pub fn BAUD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 13u8) as u16) }
    }
    #[inline]
    pub fn set_BAUD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 13u8, val as u64)
        }
    }
    #[inline]
    pub fn FP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_FP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BAUD: u16, FP: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 13u8, {
            let BAUD: u16 = unsafe { ::core::mem::transmute(BAUD) };
            BAUD as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let FP: u16 = unsafe { ::core::mem::transmute(FP) };
            FP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_BAUD_Type__bindgen_ty_4 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_BAUD_Type__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_BAUD_Type__bindgen_ty_4>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_BAUD_Type__bindgen_ty_4>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_BAUD_Type__bindgen_ty_4)
        )
    );
}
impl SERCOM_USART_BAUD_Type__bindgen_ty_4 {
    #[inline]
    pub fn BAUD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_BAUD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BAUD: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let BAUD: u16 = unsafe { ::core::mem::transmute(BAUD) };
            BAUD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_BAUD_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_BAUD_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_BAUD_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SERCOM_USART_BAUD_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_BAUD_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_BAUD_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_BAUD_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FRAC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_BAUD_Type),
            "::",
            stringify!(FRAC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FRACFP) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_BAUD_Type),
            "::",
            stringify!(FRACFP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).USARTFP) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_BAUD_Type),
            "::",
            stringify!(USARTFP)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_BAUD_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_RXPL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_RXPL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_RXPL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_RXPL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_RXPL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_RXPL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_RXPL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_RXPL_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_RXPL_Type__bindgen_ty_1 {
    #[inline]
    pub fn RXPL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_RXPL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(RXPL: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let RXPL: u8 = unsafe { ::core::mem::transmute(RXPL) };
            RXPL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_RXPL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_RXPL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_RXPL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_USART_RXPL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_RXPL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_RXPL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_RXPL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_RXPL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn MB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MB: u8, SB: u8, ERROR: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MB: u8 = unsafe { ::core::mem::transmute(MB) };
            MB as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SB: u8 = unsafe { ::core::mem::transmute(SB) };
            SB as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CM_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PREC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AMATCH(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AMATCH(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PREC: u8,
        AMATCH: u8,
        DRDY: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PREC: u8 = unsafe { ::core::mem::transmute(PREC) };
            PREC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AMATCH: u8 = unsafe { ::core::mem::transmute(AMATCH) };
            AMATCH as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DRDY: u8 = unsafe { ::core::mem::transmute(DRDY) };
            DRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CS_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_SPI_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DRE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SSL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SSL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DRE: u8,
        TXC: u8,
        RXC: u8,
        SSL: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DRE: u8 = unsafe { ::core::mem::transmute(DRE) };
            DRE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TXC: u8 = unsafe { ::core::mem::transmute(TXC) };
            TXC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXC: u8 = unsafe { ::core::mem::transmute(RXC) };
            RXC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SSL: u8 = unsafe { ::core::mem::transmute(SSL) };
            SSL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_SPI_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DRE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTSIC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CTSIC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXBRK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXBRK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DRE: u8,
        TXC: u8,
        RXC: u8,
        RXS: u8,
        CTSIC: u8,
        RXBRK: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DRE: u8 = unsafe { ::core::mem::transmute(DRE) };
            DRE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TXC: u8 = unsafe { ::core::mem::transmute(TXC) };
            TXC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXC: u8 = unsafe { ::core::mem::transmute(RXC) };
            RXC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RXS: u8 = unsafe { ::core::mem::transmute(RXS) };
            RXS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CTSIC: u8 = unsafe { ::core::mem::transmute(CTSIC) };
            CTSIC as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RXBRK: u8 = unsafe { ::core::mem::transmute(RXBRK) };
            RXBRK as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_USART_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn MB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MB: u8, SB: u8, ERROR: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MB: u8 = unsafe { ::core::mem::transmute(MB) };
            MB as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SB: u8 = unsafe { ::core::mem::transmute(SB) };
            SB as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CM_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PREC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AMATCH(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AMATCH(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PREC: u8,
        AMATCH: u8,
        DRDY: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PREC: u8 = unsafe { ::core::mem::transmute(PREC) };
            PREC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AMATCH: u8 = unsafe { ::core::mem::transmute(AMATCH) };
            AMATCH as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DRDY: u8 = unsafe { ::core::mem::transmute(DRDY) };
            DRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CS_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_SPI_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DRE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SSL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SSL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DRE: u8,
        TXC: u8,
        RXC: u8,
        SSL: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DRE: u8 = unsafe { ::core::mem::transmute(DRE) };
            DRE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TXC: u8 = unsafe { ::core::mem::transmute(TXC) };
            TXC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXC: u8 = unsafe { ::core::mem::transmute(RXC) };
            RXC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SSL: u8 = unsafe { ::core::mem::transmute(SSL) };
            SSL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_SPI_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DRE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTSIC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CTSIC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXBRK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXBRK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DRE: u8,
        TXC: u8,
        RXC: u8,
        RXS: u8,
        CTSIC: u8,
        RXBRK: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DRE: u8 = unsafe { ::core::mem::transmute(DRE) };
            DRE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TXC: u8 = unsafe { ::core::mem::transmute(TXC) };
            TXC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXC: u8 = unsafe { ::core::mem::transmute(RXC) };
            RXC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RXS: u8 = unsafe { ::core::mem::transmute(RXS) };
            RXS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CTSIC: u8 = unsafe { ::core::mem::transmute(CTSIC) };
            CTSIC as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RXBRK: u8 = unsafe { ::core::mem::transmute(RXBRK) };
            RXBRK as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_USART_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn MB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MB: u8, SB: u8, ERROR: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MB: u8 = unsafe { ::core::mem::transmute(MB) };
            MB as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SB: u8 = unsafe { ::core::mem::transmute(SB) };
            SB as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CM_INTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PREC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PREC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AMATCH(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AMATCH(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DRDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PREC: u8,
        AMATCH: u8,
        DRDY: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PREC: u8 = unsafe { ::core::mem::transmute(PREC) };
            PREC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AMATCH: u8 = unsafe { ::core::mem::transmute(AMATCH) };
            AMATCH as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DRDY: u8 = unsafe { ::core::mem::transmute(DRDY) };
            DRDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CS_INTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_SPI_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn DRE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SSL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SSL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DRE: u8,
        TXC: u8,
        RXC: u8,
        SSL: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DRE: u8 = unsafe { ::core::mem::transmute(DRE) };
            DRE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TXC: u8 = unsafe { ::core::mem::transmute(TXC) };
            TXC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXC: u8 = unsafe { ::core::mem::transmute(RXC) };
            RXC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SSL: u8 = unsafe { ::core::mem::transmute(SSL) };
            SSL as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_SPI_INTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn DRE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DRE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTSIC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CTSIC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXBRK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXBRK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERROR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERROR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DRE: u8,
        TXC: u8,
        RXC: u8,
        RXS: u8,
        CTSIC: u8,
        RXBRK: u8,
        ERROR: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DRE: u8 = unsafe { ::core::mem::transmute(DRE) };
            DRE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TXC: u8 = unsafe { ::core::mem::transmute(TXC) };
            TXC as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXC: u8 = unsafe { ::core::mem::transmute(RXC) };
            RXC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RXS: u8 = unsafe { ::core::mem::transmute(RXS) };
            RXS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CTSIC: u8 = unsafe { ::core::mem::transmute(CTSIC) };
            CTSIC as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RXBRK: u8 = unsafe { ::core::mem::transmute(RXBRK) };
            RXBRK as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ERROR: u8 = unsafe { ::core::mem::transmute(ERROR) };
            ERROR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_INTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_USART_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_STATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn BUSERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BUSERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ARBLOST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ARBLOST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXNACK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXNACK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUSSTATE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_BUSSTATE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LOWTOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LOWTOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKHOLD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CLKHOLD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MEXTTOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MEXTTOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SEXTTOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SEXTTOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LENERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LENERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BUSERR: u16,
        ARBLOST: u16,
        RXNACK: u16,
        BUSSTATE: u16,
        LOWTOUT: u16,
        CLKHOLD: u16,
        MEXTTOUT: u16,
        SEXTTOUT: u16,
        LENERR: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BUSERR: u16 = unsafe { ::core::mem::transmute(BUSERR) };
            BUSERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ARBLOST: u16 = unsafe { ::core::mem::transmute(ARBLOST) };
            ARBLOST as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXNACK: u16 = unsafe { ::core::mem::transmute(RXNACK) };
            RXNACK as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let BUSSTATE: u16 = unsafe { ::core::mem::transmute(BUSSTATE) };
            BUSSTATE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let LOWTOUT: u16 = unsafe { ::core::mem::transmute(LOWTOUT) };
            LOWTOUT as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CLKHOLD: u16 = unsafe { ::core::mem::transmute(CLKHOLD) };
            CLKHOLD as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let MEXTTOUT: u16 = unsafe { ::core::mem::transmute(MEXTTOUT) };
            MEXTTOUT as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SEXTTOUT: u16 = unsafe { ::core::mem::transmute(SEXTTOUT) };
            SEXTTOUT as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let LENERR: u16 = unsafe { ::core::mem::transmute(LENERR) };
            LENERR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CM_STATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_STATUS_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_STATUS_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_STATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn BUSERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BUSERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COLL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COLL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXNACK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RXNACK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DIR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DIR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LOWTOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LOWTOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLKHOLD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CLKHOLD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SEXTTOUT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SEXTTOUT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HS(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_HS(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BUSERR: u16,
        COLL: u16,
        RXNACK: u16,
        DIR: u16,
        SR: u16,
        LOWTOUT: u16,
        CLKHOLD: u16,
        SEXTTOUT: u16,
        HS: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BUSERR: u16 = unsafe { ::core::mem::transmute(BUSERR) };
            BUSERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let COLL: u16 = unsafe { ::core::mem::transmute(COLL) };
            COLL as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RXNACK: u16 = unsafe { ::core::mem::transmute(RXNACK) };
            RXNACK as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DIR: u16 = unsafe { ::core::mem::transmute(DIR) };
            DIR as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SR: u16 = unsafe { ::core::mem::transmute(SR) };
            SR as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let LOWTOUT: u16 = unsafe { ::core::mem::transmute(LOWTOUT) };
            LOWTOUT as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CLKHOLD: u16 = unsafe { ::core::mem::transmute(CLKHOLD) };
            CLKHOLD as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let SEXTTOUT: u16 = unsafe { ::core::mem::transmute(SEXTTOUT) };
            SEXTTOUT as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let HS: u16 = unsafe { ::core::mem::transmute(HS) };
            HS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CS_STATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_STATUS_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_STATUS_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_SPI_STATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn BUFOVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BUFOVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BUFOVF: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BUFOVF: u16 = unsafe { ::core::mem::transmute(BUFOVF) };
            BUFOVF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_SPI_STATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_STATUS_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_STATUS_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_STATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_STATUS_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn PERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_FERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BUFOVF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BUFOVF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTS(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CTS(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ISF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ISF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COLL(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_COLL(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TXE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TXE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ITER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ITER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PERR: u16,
        FERR: u16,
        BUFOVF: u16,
        CTS: u16,
        ISF: u16,
        COLL: u16,
        TXE: u16,
        ITER: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PERR: u16 = unsafe { ::core::mem::transmute(PERR) };
            PERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FERR: u16 = unsafe { ::core::mem::transmute(FERR) };
            FERR as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let BUFOVF: u16 = unsafe { ::core::mem::transmute(BUFOVF) };
            BUFOVF as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CTS: u16 = unsafe { ::core::mem::transmute(CTS) };
            CTS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ISF: u16 = unsafe { ::core::mem::transmute(ISF) };
            ISF as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let COLL: u16 = unsafe { ::core::mem::transmute(COLL) };
            COLL as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let TXE: u16 = unsafe { ::core::mem::transmute(TXE) };
            TXE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ITER: u16 = unsafe { ::core::mem::transmute(ITER) };
            ITER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_STATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_STATUS_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SERCOM_USART_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_STATUS_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SYSOP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SYSOP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        SYSOP: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SYSOP: u32 = unsafe { ::core::mem::transmute(SYSOP) };
            SYSOP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CM_SYNCBUSY_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u32, ENABLE: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CS_SYNCBUSY_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTRLB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CTRLB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        CTRLB: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CTRLB: u32 = unsafe { ::core::mem::transmute(CTRLB) };
            CTRLB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_SPI_SYNCBUSY_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTRLB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CTRLB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        CTRLB: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CTRLB: u32 = unsafe { ::core::mem::transmute(CTRLB) };
            CTRLB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_SYNCBUSY_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_USART_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_RXERRCNT_Type {
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_RXERRCNT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_RXERRCNT_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_RXERRCNT_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_USART_RXERRCNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_RXERRCNT_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_RXERRCNT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_RXERRCNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_ADDR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn LENEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LENEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TENBITEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TENBITEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_LEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ADDR: u32,
        LENEN: u32,
        HS: u32,
        TENBITEN: u32,
        LEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 11u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let LENEN: u32 = unsafe { ::core::mem::transmute(LENEN) };
            LENEN as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let HS: u32 = unsafe { ::core::mem::transmute(HS) };
            HS as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let TENBITEN: u32 = unsafe { ::core::mem::transmute(TENBITEN) };
            TENBITEN as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let LEN: u32 = unsafe { ::core::mem::transmute(LEN) };
            LEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_ADDR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CM_ADDR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_ADDR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_ADDR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn GENCEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GENCEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn TENBITEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TENBITEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADDRMASK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_ADDRMASK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        GENCEN: u32,
        ADDR: u32,
        TENBITEN: u32,
        ADDRMASK: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let GENCEN: u32 = unsafe { ::core::mem::transmute(GENCEN) };
            GENCEN as u64
        });
        __bindgen_bitfield_unit.set(1usize, 10u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let TENBITEN: u32 = unsafe { ::core::mem::transmute(TENBITEN) };
            TENBITEN as u64
        });
        __bindgen_bitfield_unit.set(17usize, 10u8, {
            let ADDRMASK: u32 = unsafe { ::core::mem::transmute(ADDRMASK) };
            ADDRMASK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_ADDR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CS_ADDR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_ADDR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_ADDR_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn ADDRMASK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_ADDRMASK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ADDR: u32, ADDRMASK: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let ADDRMASK: u32 = unsafe { ::core::mem::transmute(ADDRMASK) };
            ADDRMASK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_ADDR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_SPI_ADDR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_ADDR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_DATA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_DATA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_DATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_DATA_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_DATA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let DATA: u8 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_DATA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CM_DATA_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_DATA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_DATA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_DATA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CS_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CS_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CS_DATA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_DATA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_DATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_DATA_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CS_DATA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CS_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let DATA: u8 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CS_DATA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CS_DATA_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CS_DATA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CS_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CS_DATA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CS_DATA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CS_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_DATA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_DATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_DATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_DATA_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_DATA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let DATA: u32 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_DATA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_SPI_DATA_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_DATA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_DATA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_DATA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_DATA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_DATA_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_DATA_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_DATA_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_DATA_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 9u8) as u16) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 9u8, {
            let DATA: u16 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_DATA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_DATA_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_DATA_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SERCOM_USART_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_DATA_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_DATA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_I2CM_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_I2CM_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGSTOP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGSTOP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGSTOP: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGSTOP: u8 = unsafe { ::core::mem::transmute(DBGSTOP) };
            DBGSTOP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_I2CM_DBGCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_I2CM_DBGCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_I2CM_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_I2CM_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_I2CM_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_I2CM_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_I2CM_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_SPI_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_SPI_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGSTOP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGSTOP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGSTOP: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGSTOP: u8 = unsafe { ::core::mem::transmute(DBGSTOP) };
            DBGSTOP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_SPI_DBGCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_SPI_DBGCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_SPI_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_SPI_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_SPI_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_SPI_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_SPI_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SERCOM_USART_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SERCOM_USART_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SERCOM_USART_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SERCOM_USART_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(SERCOM_USART_DBGCTRL_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SERCOM_USART_DBGCTRL_Type__bindgen_ty_1)
        )
    );
}
impl SERCOM_USART_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGSTOP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGSTOP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGSTOP: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGSTOP: u8 = unsafe { ::core::mem::transmute(DBGSTOP) };
            DBGSTOP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SERCOM_USART_DBGCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SERCOM_USART_DBGCTRL_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SERCOM_USART_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SERCOM_USART_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SERCOM_USART_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SERCOM_USART_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERCOM_USART_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SercomI2cm {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) I2CM Control A"]
    pub CTRLA: SERCOM_I2CM_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) I2CM Control B"]
    pub CTRLB: SERCOM_I2CM_CTRLB_Type,
    pub Reserved1: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x0C (R/W 32) I2CM Baud Rate"]
    pub BAUD: SERCOM_I2CM_BAUD_Type,
    pub Reserved2: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x14 (R/W  8) I2CM Interrupt Enable Clear"]
    pub INTENCLR: SERCOM_I2CM_INTENCLR_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x16 (R/W  8) I2CM Interrupt Enable Set"]
    pub INTENSET: SERCOM_I2CM_INTENSET_Type,
    pub Reserved4: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x18 (R/W  8) I2CM Interrupt Flag Status and Clear"]
    pub INTFLAG: SERCOM_I2CM_INTFLAG_Type,
    pub Reserved5: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x1A (R/W 16) I2CM Status"]
    pub STATUS: SERCOM_I2CM_STATUS_Type,
    #[doc = "< \\brief Offset: 0x1C (R/  32) I2CM Synchronization Busy"]
    pub SYNCBUSY: SERCOM_I2CM_SYNCBUSY_Type,
    pub Reserved6: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x24 (R/W 32) I2CM Address"]
    pub ADDR: SERCOM_I2CM_ADDR_Type,
    #[doc = "< \\brief Offset: 0x28 (R/W  8) I2CM Data"]
    pub DATA: SERCOM_I2CM_DATA_Type,
    pub Reserved7: [RoReg8; 7usize],
    #[doc = "< \\brief Offset: 0x30 (R/W  8) I2CM Debug Control"]
    pub DBGCTRL: SERCOM_I2CM_DBGCTRL_Type,
}
#[test]
fn bindgen_test_layout_SercomI2cm() {
    const UNINIT: ::core::mem::MaybeUninit<SercomI2cm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SercomI2cm>(),
        52usize,
        concat!("Size of: ", stringify!(SercomI2cm))
    );
    assert_eq!(
        ::core::mem::align_of::<SercomI2cm>(),
        4usize,
        concat!("Alignment of ", stringify!(SercomI2cm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BAUD) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(BAUD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ADDR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(ADDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DATA) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(DATA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved7) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(Reserved7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cm),
            "::",
            stringify!(DBGCTRL)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SercomI2cs {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) I2CS Control A"]
    pub CTRLA: SERCOM_I2CS_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) I2CS Control B"]
    pub CTRLB: SERCOM_I2CS_CTRLB_Type,
    pub Reserved1: [RoReg8; 12usize],
    #[doc = "< \\brief Offset: 0x14 (R/W  8) I2CS Interrupt Enable Clear"]
    pub INTENCLR: SERCOM_I2CS_INTENCLR_Type,
    pub Reserved2: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x16 (R/W  8) I2CS Interrupt Enable Set"]
    pub INTENSET: SERCOM_I2CS_INTENSET_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x18 (R/W  8) I2CS Interrupt Flag Status and Clear"]
    pub INTFLAG: SERCOM_I2CS_INTFLAG_Type,
    pub Reserved4: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x1A (R/W 16) I2CS Status"]
    pub STATUS: SERCOM_I2CS_STATUS_Type,
    #[doc = "< \\brief Offset: 0x1C (R/  32) I2CS Synchronization Busy"]
    pub SYNCBUSY: SERCOM_I2CS_SYNCBUSY_Type,
    pub Reserved5: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x24 (R/W 32) I2CS Address"]
    pub ADDR: SERCOM_I2CS_ADDR_Type,
    #[doc = "< \\brief Offset: 0x28 (R/W  8) I2CS Data"]
    pub DATA: SERCOM_I2CS_DATA_Type,
}
#[test]
fn bindgen_test_layout_SercomI2cs() {
    const UNINIT: ::core::mem::MaybeUninit<SercomI2cs> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SercomI2cs>(),
        44usize,
        concat!("Size of: ", stringify!(SercomI2cs))
    );
    assert_eq!(
        ::core::mem::align_of::<SercomI2cs>(),
        4usize,
        concat!("Alignment of ", stringify!(SercomI2cs))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ADDR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(ADDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DATA) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomI2cs),
            "::",
            stringify!(DATA)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SercomSpi {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) SPI Control A"]
    pub CTRLA: SERCOM_SPI_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) SPI Control B"]
    pub CTRLB: SERCOM_SPI_CTRLB_Type,
    pub Reserved1: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x0C (R/W  8) SPI Baud Rate"]
    pub BAUD: SERCOM_SPI_BAUD_Type,
    pub Reserved2: [RoReg8; 7usize],
    #[doc = "< \\brief Offset: 0x14 (R/W  8) SPI Interrupt Enable Clear"]
    pub INTENCLR: SERCOM_SPI_INTENCLR_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x16 (R/W  8) SPI Interrupt Enable Set"]
    pub INTENSET: SERCOM_SPI_INTENSET_Type,
    pub Reserved4: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x18 (R/W  8) SPI Interrupt Flag Status and Clear"]
    pub INTFLAG: SERCOM_SPI_INTFLAG_Type,
    pub Reserved5: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x1A (R/W 16) SPI Status"]
    pub STATUS: SERCOM_SPI_STATUS_Type,
    #[doc = "< \\brief Offset: 0x1C (R/  32) SPI Synchronization Busy"]
    pub SYNCBUSY: SERCOM_SPI_SYNCBUSY_Type,
    pub Reserved6: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x24 (R/W 32) SPI Address"]
    pub ADDR: SERCOM_SPI_ADDR_Type,
    #[doc = "< \\brief Offset: 0x28 (R/W 32) SPI Data"]
    pub DATA: SERCOM_SPI_DATA_Type,
    pub Reserved7: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x30 (R/W  8) SPI Debug Control"]
    pub DBGCTRL: SERCOM_SPI_DBGCTRL_Type,
}
#[test]
fn bindgen_test_layout_SercomSpi() {
    const UNINIT: ::core::mem::MaybeUninit<SercomSpi> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SercomSpi>(),
        52usize,
        concat!("Size of: ", stringify!(SercomSpi))
    );
    assert_eq!(
        ::core::mem::align_of::<SercomSpi>(),
        4usize,
        concat!("Alignment of ", stringify!(SercomSpi))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BAUD) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(BAUD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ADDR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(ADDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DATA) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(DATA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved7) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(Reserved7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomSpi),
            "::",
            stringify!(DBGCTRL)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SercomUsart {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) USART Control A"]
    pub CTRLA: SERCOM_USART_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) USART Control B"]
    pub CTRLB: SERCOM_USART_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) USART Control C"]
    pub CTRLC: SERCOM_USART_CTRLC_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W 16) USART Baud Rate"]
    pub BAUD: SERCOM_USART_BAUD_Type,
    #[doc = "< \\brief Offset: 0x0E (R/W  8) USART Receive Pulse Length"]
    pub RXPL: SERCOM_USART_RXPL_Type,
    pub Reserved1: [RoReg8; 5usize],
    #[doc = "< \\brief Offset: 0x14 (R/W  8) USART Interrupt Enable Clear"]
    pub INTENCLR: SERCOM_USART_INTENCLR_Type,
    pub Reserved2: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x16 (R/W  8) USART Interrupt Enable Set"]
    pub INTENSET: SERCOM_USART_INTENSET_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x18 (R/W  8) USART Interrupt Flag Status and Clear"]
    pub INTFLAG: SERCOM_USART_INTFLAG_Type,
    pub Reserved4: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x1A (R/W 16) USART Status"]
    pub STATUS: SERCOM_USART_STATUS_Type,
    #[doc = "< \\brief Offset: 0x1C (R/  32) USART Synchronization Busy"]
    pub SYNCBUSY: SERCOM_USART_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x20 (R/   8) USART Receive Error Count"]
    pub RXERRCNT: SERCOM_USART_RXERRCNT_Type,
    pub Reserved5: [RoReg8; 7usize],
    #[doc = "< \\brief Offset: 0x28 (R/W 16) USART Data"]
    pub DATA: SERCOM_USART_DATA_Type,
    pub Reserved6: [RoReg8; 6usize],
    #[doc = "< \\brief Offset: 0x30 (R/W  8) USART Debug Control"]
    pub DBGCTRL: SERCOM_USART_DBGCTRL_Type,
}
#[test]
fn bindgen_test_layout_SercomUsart() {
    const UNINIT: ::core::mem::MaybeUninit<SercomUsart> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SercomUsart>(),
        52usize,
        concat!("Size of: ", stringify!(SercomUsart))
    );
    assert_eq!(
        ::core::mem::align_of::<SercomUsart>(),
        4usize,
        concat!("Alignment of ", stringify!(SercomUsart))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLC) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(CTRLC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BAUD) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(BAUD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RXPL) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(RXPL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RXERRCNT) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(RXERRCNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DATA) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(DATA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SercomUsart),
            "::",
            stringify!(DBGCTRL)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Sercom {
    #[doc = "< \\brief Offset: 0x00 I2C Master Mode"]
    pub I2CM: SercomI2cm,
    #[doc = "< \\brief Offset: 0x00 I2C Slave Mode"]
    pub I2CS: SercomI2cs,
    #[doc = "< \\brief Offset: 0x00 SPI Mode"]
    pub SPI: SercomSpi,
    #[doc = "< \\brief Offset: 0x00 USART Mode"]
    pub USART: SercomUsart,
}
#[test]
fn bindgen_test_layout_Sercom() {
    const UNINIT: ::core::mem::MaybeUninit<Sercom> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Sercom>(),
        52usize,
        concat!("Size of: ", stringify!(Sercom))
    );
    assert_eq!(
        ::core::mem::align_of::<Sercom>(),
        4usize,
        concat!("Alignment of ", stringify!(Sercom))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2CM) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sercom),
            "::",
            stringify!(I2CM)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).I2CS) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sercom),
            "::",
            stringify!(I2CS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SPI) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sercom),
            "::",
            stringify!(SPI)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).USART) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sercom),
            "::",
            stringify!(USART)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_CTRLA_Type__bindgen_ty_1))
    );
}
impl SLCD_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DUTY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_DUTY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn WMOD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WMOD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PRESC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CKDIV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_CKDIV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn BIAS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_BIAS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn XVLCD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_XVLCD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PRF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DMFCS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_DMFCS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RRF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_RRF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        DUTY: u32,
        WMOD: u32,
        RUNSTDBY: u32,
        PRESC: u32,
        CKDIV: u32,
        BIAS: u32,
        XVLCD: u32,
        PRF: u32,
        DMFCS: u32,
        RRF: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let DUTY: u32 = unsafe { ::core::mem::transmute(DUTY) };
            DUTY as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let WMOD: u32 = unsafe { ::core::mem::transmute(WMOD) };
            WMOD as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let PRESC: u32 = unsafe { ::core::mem::transmute(PRESC) };
            PRESC as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let CKDIV: u32 = unsafe { ::core::mem::transmute(CKDIV) };
            CKDIV as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let BIAS: u32 = unsafe { ::core::mem::transmute(BIAS) };
            BIAS as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let XVLCD: u32 = unsafe { ::core::mem::transmute(XVLCD) };
            XVLCD as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let PRF: u32 = unsafe { ::core::mem::transmute(PRF) };
            PRF as u64
        });
        __bindgen_bitfield_unit.set(22usize, 2u8, {
            let DMFCS: u32 = unsafe { ::core::mem::transmute(DMFCS) };
            DMFCS as u64
        });
        __bindgen_bitfield_unit.set(24usize, 3u8, {
            let RRF: u32 = unsafe { ::core::mem::transmute(RRF) };
            RRF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(SLCD_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(SLCD_CTRLB_Type__bindgen_ty_1))
    );
}
impl SLCD_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn BBD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_BBD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn BBEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_BBEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LRD(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_LRD(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn LREN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LREN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BBD: u16,
        BBEN: u16,
        LRD: u16,
        LREN: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let BBD: u16 = unsafe { ::core::mem::transmute(BBD) };
            BBD as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BBEN: u16 = unsafe { ::core::mem::transmute(BBEN) };
            BBEN as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let LRD: u16 = unsafe { ::core::mem::transmute(LRD) };
            LRD as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let LREN: u16 = unsafe { ::core::mem::transmute(LREN) };
            LREN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_CTRLB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_CTRLB_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SLCD_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CTRLB_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SLCD_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_CTRLC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_CTRLC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_CTRLC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_CTRLC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_CTRLC_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(SLCD_CTRLC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CTRLC_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(SLCD_CTRLC_Type__bindgen_ty_1))
    );
}
impl SLCD_CTRLC_Type__bindgen_ty_1 {
    #[inline]
    pub fn CLEAR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CLEAR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LOCK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LOCK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ABMEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ABMEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ACMEN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_ACMEN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_CTST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn LPPM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_LPPM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CLEAR: u16,
        LOCK: u16,
        ABMEN: u16,
        ACMEN: u16,
        CTST: u16,
        LPPM: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CLEAR: u16 = unsafe { ::core::mem::transmute(CLEAR) };
            CLEAR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LOCK: u16 = unsafe { ::core::mem::transmute(LOCK) };
            LOCK as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ABMEN: u16 = unsafe { ::core::mem::transmute(ABMEN) };
            ABMEN as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ACMEN: u16 = unsafe { ::core::mem::transmute(ACMEN) };
            ACMEN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let CTST: u16 = unsafe { ::core::mem::transmute(CTST) };
            CTST as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let LPPM: u16 = unsafe { ::core::mem::transmute(LPPM) };
            LPPM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_CTRLC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_CTRLC_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_CTRLC_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SLCD_CTRLC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CTRLC_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SLCD_CTRLC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CTRLC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CTRLC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_CTRLD_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_CTRLD_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_CTRLD_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_CTRLD_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_CTRLD_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_CTRLD_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CTRLD_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_CTRLD_Type__bindgen_ty_1))
    );
}
impl SLCD_CTRLD_Type__bindgen_ty_1 {
    #[inline]
    pub fn BLANK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BLANK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BLINK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BLINK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CSREN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CSREN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FC0EN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC0EN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FC1EN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC1EN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FC2EN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC2EN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DISPEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DISPEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BLANK: u8,
        BLINK: u8,
        CSREN: u8,
        FC0EN: u8,
        FC1EN: u8,
        FC2EN: u8,
        DISPEN: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BLANK: u8 = unsafe { ::core::mem::transmute(BLANK) };
            BLANK as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BLINK: u8 = unsafe { ::core::mem::transmute(BLINK) };
            BLINK as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CSREN: u8 = unsafe { ::core::mem::transmute(CSREN) };
            CSREN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FC0EN: u8 = unsafe { ::core::mem::transmute(FC0EN) };
            FC0EN as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let FC1EN: u8 = unsafe { ::core::mem::transmute(FC1EN) };
            FC1EN as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let FC2EN: u8 = unsafe { ::core::mem::transmute(FC2EN) };
            FC2EN as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let DISPEN: u8 = unsafe { ::core::mem::transmute(DISPEN) };
            DISPEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_CTRLD_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_CTRLD_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_CTRLD_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_CTRLD_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CTRLD_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_CTRLD_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CTRLD_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CTRLD_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_EVCTRL_Type__bindgen_ty_1))
    );
}
impl SLCD_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn FC0OEO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC0OEO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FC1OEO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC1OEO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FC2OEO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC2OEO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FC0OEO: u8,
        FC1OEO: u8,
        FC2OEO: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FC0OEO: u8 = unsafe { ::core::mem::transmute(FC0OEO) };
            FC0OEO as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FC1OEO: u8 = unsafe { ::core::mem::transmute(FC1OEO) };
            FC1OEO as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FC2OEO: u8 = unsafe { ::core::mem::transmute(FC2OEO) };
            FC2OEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_EVCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_EVCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_EVCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SLCD_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl SLCD_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn FC0O(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC0O(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FC1O(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC1O(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FC2O(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC2O(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VLCDRT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_VLCDRT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VLCDST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_VLCDST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FC0O: u8,
        FC1O: u8,
        FC2O: u8,
        VLCDRT: u8,
        VLCDST: u8,
        PRST: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FC0O: u8 = unsafe { ::core::mem::transmute(FC0O) };
            FC0O as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FC1O: u8 = unsafe { ::core::mem::transmute(FC1O) };
            FC1O as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FC2O: u8 = unsafe { ::core::mem::transmute(FC2O) };
            FC2O as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let VLCDRT: u8 = unsafe { ::core::mem::transmute(VLCDRT) };
            VLCDRT as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let VLCDST: u8 = unsafe { ::core::mem::transmute(VLCDST) };
            VLCDST as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PRST: u8 = unsafe { ::core::mem::transmute(PRST) };
            PRST as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(SLCD_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl SLCD_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn FC0O(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC0O(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FC1O(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC1O(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FC2O(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC2O(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VLCDRT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_VLCDRT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VLCDST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_VLCDST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FC0O: u8,
        FC1O: u8,
        FC2O: u8,
        VLCDRT: u8,
        VLCDST: u8,
        PRST: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FC0O: u8 = unsafe { ::core::mem::transmute(FC0O) };
            FC0O as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FC1O: u8 = unsafe { ::core::mem::transmute(FC1O) };
            FC1O as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FC2O: u8 = unsafe { ::core::mem::transmute(FC2O) };
            FC2O as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let VLCDRT: u8 = unsafe { ::core::mem::transmute(VLCDRT) };
            VLCDRT as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let VLCDST: u8 = unsafe { ::core::mem::transmute(VLCDST) };
            VLCDST as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PRST: u8 = unsafe { ::core::mem::transmute(PRST) };
            PRST as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_INTFLAG_Type__bindgen_ty_1))
    );
}
impl SLCD_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn FC0O(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC0O(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FC1O(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC1O(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FC2O(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FC2O(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VLCDRT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_VLCDRT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VLCDST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_VLCDST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FC0O: u8,
        FC1O: u8,
        FC2O: u8,
        VLCDRT: u8,
        VLCDST: u8,
        PRST: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let FC0O: u8 = unsafe { ::core::mem::transmute(FC0O) };
            FC0O as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let FC1O: u8 = unsafe { ::core::mem::transmute(FC1O) };
            FC1O as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FC2O: u8 = unsafe { ::core::mem::transmute(FC2O) };
            FC2O as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let VLCDRT: u8 = unsafe { ::core::mem::transmute(VLCDRT) };
            VLCDRT as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let VLCDST: u8 = unsafe { ::core::mem::transmute(VLCDST) };
            VLCDST as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PRST: u8 = unsafe { ::core::mem::transmute(PRST) };
            PRST as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_STATUS_Type__bindgen_ty_1))
    );
}
impl SLCD_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn VLCDR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_VLCDR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VLCDS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_VLCDS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMWRBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CMWRBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ACMBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ACMBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ABMBUSY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ABMBUSY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        VLCDR: u8,
        PRUN: u8,
        VLCDS: u8,
        CMWRBUSY: u8,
        ACMBUSY: u8,
        ABMBUSY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VLCDR: u8 = unsafe { ::core::mem::transmute(VLCDR) };
            VLCDR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PRUN: u8 = unsafe { ::core::mem::transmute(PRUN) };
            PRUN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let VLCDS: u8 = unsafe { ::core::mem::transmute(VLCDS) };
            VLCDS as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let CMWRBUSY: u8 = unsafe { ::core::mem::transmute(CMWRBUSY) };
            CMWRBUSY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ACMBUSY: u8 = unsafe { ::core::mem::transmute(ACMBUSY) };
            ACMBUSY as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ABMBUSY: u8 = unsafe { ::core::mem::transmute(ABMBUSY) };
            ABMBUSY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_STATUS_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SLCD_SYNCBUSY_Type__bindgen_ty_1)
        )
    );
}
impl SLCD_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTRLD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CTRLD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        CTRLD: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CTRLD: u32 = unsafe { ::core::mem::transmute(CTRLD) };
            CTRLD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SYNCBUSY_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_FC0_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_FC0_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_FC0_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_FC0_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_FC0_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_FC0_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_FC0_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_FC0_Type__bindgen_ty_1))
    );
}
impl SLCD_FC0_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn PB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(OVF: u8, PB: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PB: u8 = unsafe { ::core::mem::transmute(PB) };
            PB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_FC0_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_FC0_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_FC0_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_FC0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_FC0_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_FC0_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_FC0_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_FC0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_FC1_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_FC1_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_FC1_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_FC1_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_FC1_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_FC1_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_FC1_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_FC1_Type__bindgen_ty_1))
    );
}
impl SLCD_FC1_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn PB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(OVF: u8, PB: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PB: u8 = unsafe { ::core::mem::transmute(PB) };
            PB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_FC1_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_FC1_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_FC1_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_FC1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_FC1_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_FC1_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_FC1_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_FC1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_FC2_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_FC2_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_FC2_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_FC2_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_FC2_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_FC2_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_FC2_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_FC2_Type__bindgen_ty_1))
    );
}
impl SLCD_FC2_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn PB(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PB(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(OVF: u8, PB: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PB: u8 = unsafe { ::core::mem::transmute(PB) };
            PB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_FC2_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_FC2_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_FC2_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_FC2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_FC2_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_FC2_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_FC2_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_FC2_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_LPENL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_LPENL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_LPENL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_LPENL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_LPENL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_LPENL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_LPENL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_LPENL_Type__bindgen_ty_1))
    );
}
impl SLCD_LPENL_Type__bindgen_ty_1 {
    #[inline]
    pub fn LPEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_LPEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LPEN: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let LPEN: u32 = unsafe { ::core::mem::transmute(LPEN) };
            LPEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_LPENL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_LPENL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_LPENL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_LPENL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_LPENL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_LPENL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_LPENL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_LPENL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_LPENH_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_LPENH_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_LPENH_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_LPENH_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_LPENH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_LPENH_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_LPENH_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_LPENH_Type__bindgen_ty_1))
    );
}
impl SLCD_LPENH_Type__bindgen_ty_1 {
    #[inline]
    pub fn LPEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_LPEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(LPEN: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let LPEN: u32 = unsafe { ::core::mem::transmute(LPEN) };
            LPEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_LPENH_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_LPENH_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_LPENH_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_LPENH_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_LPENH_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_LPENH_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_LPENH_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_LPENH_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAL0_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAL0_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAL0_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL0_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL0_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL0_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAL0_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL0_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAL0_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL0_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL0_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAH0_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAH0_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAH0_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH0_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH0_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH0_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH0_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAH0_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH0_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAH0_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH0_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH0_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH0_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH0_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH0_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH0_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAL1_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAL1_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAL1_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL1_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL1_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL1_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL1_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL1_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAL1_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL1_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAL1_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL1_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL1_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAH1_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAH1_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAH1_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH1_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH1_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH1_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH1_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH1_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAH1_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH1_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAH1_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH1_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH1_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH1_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH1_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH1_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH1_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAL2_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAL2_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAL2_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL2_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL2_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL2_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL2_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL2_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAL2_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL2_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAL2_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL2_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL2_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL2_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL2_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL2_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAH2_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAH2_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAH2_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH2_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH2_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH2_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH2_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH2_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAH2_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH2_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAH2_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH2_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH2_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH2_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH2_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH2_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH2_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAL3_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAL3_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAL3_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL3_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL3_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL3_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL3_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL3_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAL3_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL3_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAL3_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL3_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL3_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL3_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL3_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL3_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL3_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAH3_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAH3_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAH3_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH3_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH3_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH3_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH3_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH3_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAH3_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH3_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAH3_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH3_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH3_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH3_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH3_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH3_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH3_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAL4_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAL4_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAL4_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL4_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL4_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL4_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL4_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL4_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAL4_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL4_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAL4_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL4_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL4_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL4_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL4_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL4_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL4_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAH4_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAH4_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAH4_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH4_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH4_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH4_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH4_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH4_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAH4_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH4_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAH4_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH4_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH4_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH4_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH4_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH4_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH4_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAL5_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAL5_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAL5_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL5_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL5_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL5_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL5_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL5_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAL5_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL5_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAL5_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL5_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL5_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL5_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL5_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL5_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL5_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAH5_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAH5_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAH5_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH5_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH5_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH5_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH5_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH5_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAH5_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 10u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH5_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAH5_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH5_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH5_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH5_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH5_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH5_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH5_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAL6_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAL6_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAL6_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL6_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL6_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL6_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL6_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL6_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAL6_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL6_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAL6_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL6_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL6_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL6_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL6_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL6_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL6_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAH6_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAH6_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAH6_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH6_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH6_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH6_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH6_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH6_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAH6_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH6_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAH6_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH6_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH6_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH6_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH6_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH6_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH6_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAL7_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAL7_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAL7_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL7_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL7_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL7_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL7_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL7_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAL7_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAL7_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAL7_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAL7_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAL7_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAL7_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAL7_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL7_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAL7_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_SDATAH7_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_SDATAH7_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_SDATAH7_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH7_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH7_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH7_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH7_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH7_Type__bindgen_ty_1))
    );
}
impl SLCD_SDATAH7_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_SDATAH7_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_SDATAH7_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_SDATAH7_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_SDATAH7_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_SDATAH7_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_SDATAH7_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH7_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_SDATAH7_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_ISDATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_ISDATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_ISDATA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_ISDATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_ISDATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_ISDATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_ISDATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_ISDATA_Type__bindgen_ty_1))
    );
}
impl SLCD_ISDATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn SDMASK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_SDMASK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn OFF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_OFF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SDATA: u32,
        SDMASK: u32,
        OFF: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let SDMASK: u32 = unsafe { ::core::mem::transmute(SDMASK) };
            SDMASK as u64
        });
        __bindgen_bitfield_unit.set(16usize, 6u8, {
            let OFF: u32 = unsafe { ::core::mem::transmute(OFF) };
            OFF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_ISDATA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_ISDATA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_ISDATA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_ISDATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_ISDATA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_ISDATA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_ISDATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_ISDATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_BCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_BCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_BCFG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_BCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_BCFG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_BCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_BCFG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_BCFG_Type__bindgen_ty_1))
    );
}
impl SLCD_BCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn MODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FCS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_FCS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn BSS0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BSS0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn BSS1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BSS1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MODE: u32,
        FCS: u32,
        BSS0: u32,
        BSS1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MODE: u32 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let FCS: u32 = unsafe { ::core::mem::transmute(FCS) };
            FCS as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let BSS0: u32 = unsafe { ::core::mem::transmute(BSS0) };
            BSS0 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let BSS1: u32 = unsafe { ::core::mem::transmute(BSS1) };
            BSS1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_BCFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_BCFG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_BCFG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_BCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_BCFG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_BCFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_BCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_BCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_CSRCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_CSRCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_CSRCFG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_CSRCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_CSRCFG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_CSRCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CSRCFG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_CSRCFG_Type__bindgen_ty_1))
    );
}
impl SLCD_CSRCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DIR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FCS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_FCS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_SIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn DATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DIR: u32,
        FCS: u32,
        SIZE: u32,
        DATA: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DIR: u32 = unsafe { ::core::mem::transmute(DIR) };
            DIR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let FCS: u32 = unsafe { ::core::mem::transmute(FCS) };
            FCS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let SIZE: u32 = unsafe { ::core::mem::transmute(SIZE) };
            SIZE as u64
        });
        __bindgen_bitfield_unit.set(8usize, 16u8, {
            let DATA: u32 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_CSRCFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_CSRCFG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_CSRCFG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_CSRCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CSRCFG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_CSRCFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CSRCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CSRCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_CMCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_CMCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_CMCFG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_CMCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_CMCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_CMCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CMCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_CMCFG_Type__bindgen_ty_1))
    );
}
impl SLCD_CMCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn NSEG(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_NSEG(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn DEC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DEC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(NSEG: u8, DEC: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let NSEG: u8 = unsafe { ::core::mem::transmute(NSEG) };
            NSEG as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DEC: u8 = unsafe { ::core::mem::transmute(DEC) };
            DEC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_CMCFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_CMCFG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_CMCFG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_CMCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CMCFG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_CMCFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CMCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CMCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_ACMCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_ACMCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_ACMCFG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_ACMCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_ACMCFG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_ACMCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_ACMCFG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_ACMCFG_Type__bindgen_ty_1))
    );
}
impl SLCD_ACMCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn NCOM(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_NCOM(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn NDIG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_NDIG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn STEPS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_STEPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn NDROW(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_NDROW(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STSEG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_STSEG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn FCS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_FCS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NCOM: u32,
        NDIG: u32,
        STEPS: u32,
        NDROW: u32,
        MODE: u32,
        STSEG: u32,
        FCS: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let NCOM: u32 = unsafe { ::core::mem::transmute(NCOM) };
            NCOM as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let NDIG: u32 = unsafe { ::core::mem::transmute(NDIG) };
            NDIG as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let STEPS: u32 = unsafe { ::core::mem::transmute(STEPS) };
            STEPS as u64
        });
        __bindgen_bitfield_unit.set(16usize, 6u8, {
            let NDROW: u32 = unsafe { ::core::mem::transmute(NDROW) };
            NDROW as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let MODE: u32 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(24usize, 6u8, {
            let STSEG: u32 = unsafe { ::core::mem::transmute(STSEG) };
            STSEG as u64
        });
        __bindgen_bitfield_unit.set(30usize, 2u8, {
            let FCS: u32 = unsafe { ::core::mem::transmute(FCS) };
            FCS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_ACMCFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_ACMCFG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_ACMCFG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_ACMCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_ACMCFG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_ACMCFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_ACMCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_ACMCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_ABMCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_ABMCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_ABMCFG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_ABMCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_ABMCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_ABMCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_ABMCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_ABMCFG_Type__bindgen_ty_1))
    );
}
impl SLCD_ABMCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn FCS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_FCS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SIZE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_SIZE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(FCS: u8, SIZE: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let FCS: u8 = unsafe { ::core::mem::transmute(FCS) };
            FCS as u64
        });
        __bindgen_bitfield_unit.set(2usize, 6u8, {
            let SIZE: u8 = unsafe { ::core::mem::transmute(SIZE) };
            SIZE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_ABMCFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_ABMCFG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_ABMCFG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(SLCD_ABMCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_ABMCFG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(SLCD_ABMCFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_ABMCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_ABMCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_CMDATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_CMDATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_CMDATA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_CMDATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_CMDATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_CMDATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CMDATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_CMDATA_Type__bindgen_ty_1))
    );
}
impl SLCD_CMDATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_SDATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let SDATA: u32 = unsafe { ::core::mem::transmute(SDATA) };
            SDATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_CMDATA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_CMDATA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_CMDATA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_CMDATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CMDATA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_CMDATA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CMDATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CMDATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_CMDMASK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_CMDMASK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_CMDMASK_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_CMDMASK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_CMDMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_CMDMASK_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CMDMASK_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_CMDMASK_Type__bindgen_ty_1))
    );
}
impl SLCD_CMDMASK_Type__bindgen_ty_1 {
    #[inline]
    pub fn SDMASK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_SDMASK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SDMASK: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let SDMASK: u32 = unsafe { ::core::mem::transmute(SDMASK) };
            SDMASK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_CMDMASK_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_CMDMASK_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_CMDMASK_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SLCD_CMDMASK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CMDMASK_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SLCD_CMDMASK_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CMDMASK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CMDMASK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SLCD_CMINDEX_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SLCD_CMINDEX_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct SLCD_CMINDEX_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_SLCD_CMINDEX_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SLCD_CMINDEX_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(SLCD_CMINDEX_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CMINDEX_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(SLCD_CMINDEX_Type__bindgen_ty_1))
    );
}
impl SLCD_CMINDEX_Type__bindgen_ty_1 {
    #[inline]
    pub fn SINDEX(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u16) }
    }
    #[inline]
    pub fn set_SINDEX(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn CINDEX(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_CINDEX(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SINDEX: u16, CINDEX: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let SINDEX: u16 = unsafe { ::core::mem::transmute(SINDEX) };
            SINDEX as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let CINDEX: u16 = unsafe { ::core::mem::transmute(CINDEX) };
            CINDEX as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SLCD_CMINDEX_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SLCD_CMINDEX_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SLCD_CMINDEX_Type>(),
        2usize,
        concat!("Size of: ", stringify!(SLCD_CMINDEX_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SLCD_CMINDEX_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(SLCD_CMINDEX_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CMINDEX_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SLCD_CMINDEX_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Slcd {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Control A"]
    pub CTRLA: SLCD_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 16) Control B"]
    pub CTRLB: SLCD_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W 16) Control C"]
    pub CTRLC: SLCD_CTRLC_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W  8) Control D"]
    pub CTRLD: SLCD_CTRLD_Type,
    pub Reserved1: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Event Control"]
    pub EVCTRL: SLCD_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x0D (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: SLCD_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x0E (R/W  8) Interrupt Enable Set"]
    pub INTENSET: SLCD_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x0F (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: SLCD_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x10 (R/   8) Status"]
    pub STATUS: SLCD_STATUS_Type,
    pub Reserved2: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x14 (R/  32) Synchronization Busy"]
    pub SYNCBUSY: SLCD_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W  8) Frame Counter 0 Configuration"]
    pub FC0: SLCD_FC0_Type,
    #[doc = "< \\brief Offset: 0x19 (R/W  8) Frame Counter 1 Configuration"]
    pub FC1: SLCD_FC1_Type,
    #[doc = "< \\brief Offset: 0x1A (R/W  8) Frame Counter 2 Configuration"]
    pub FC2: SLCD_FC2_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x1C (R/W 32) LCD Pin Enable Low"]
    pub LPENL: SLCD_LPENL_Type,
    #[doc = "< \\brief Offset: 0x20 (R/W 32) LCD Pin Enable High"]
    pub LPENH: SLCD_LPENH_Type,
    #[doc = "< \\brief Offset: 0x24 (R/W 32) Segments Data Low for COM0 Line"]
    pub SDATAL0: SLCD_SDATAL0_Type,
    #[doc = "< \\brief Offset: 0x28 (R/W 32) Segments Data High for COM0 Line"]
    pub SDATAH0: SLCD_SDATAH0_Type,
    #[doc = "< \\brief Offset: 0x2C (R/W 32) Segments Data Low for COM1 Line"]
    pub SDATAL1: SLCD_SDATAL1_Type,
    #[doc = "< \\brief Offset: 0x30 (R/W 32) Segments Data High for COM1 Line"]
    pub SDATAH1: SLCD_SDATAH1_Type,
    #[doc = "< \\brief Offset: 0x34 (R/W 32) Segments Data Low for COM2 Line"]
    pub SDATAL2: SLCD_SDATAL2_Type,
    #[doc = "< \\brief Offset: 0x38 (R/W 32) Segments Data High for COM2 Line"]
    pub SDATAH2: SLCD_SDATAH2_Type,
    #[doc = "< \\brief Offset: 0x3C (R/W 32) Segments Data Low for COM3 Line"]
    pub SDATAL3: SLCD_SDATAL3_Type,
    #[doc = "< \\brief Offset: 0x40 (R/W 32) Segments Data High for COM3 Line"]
    pub SDATAH3: SLCD_SDATAH3_Type,
    #[doc = "< \\brief Offset: 0x44 (R/W 32) Segments Data Low for COM4 Line"]
    pub SDATAL4: SLCD_SDATAL4_Type,
    #[doc = "< \\brief Offset: 0x48 (R/W 32) Segments Data High for COM4 Line"]
    pub SDATAH4: SLCD_SDATAH4_Type,
    #[doc = "< \\brief Offset: 0x4C (R/W 32) Segments Data Low for COM5 Line"]
    pub SDATAL5: SLCD_SDATAL5_Type,
    #[doc = "< \\brief Offset: 0x50 (R/W 32) Segments Data High for COM5 Line"]
    pub SDATAH5: SLCD_SDATAH5_Type,
    #[doc = "< \\brief Offset: 0x54 (R/W 32) Segments Data Low for COM6 Line"]
    pub SDATAL6: SLCD_SDATAL6_Type,
    #[doc = "< \\brief Offset: 0x58 (R/W 32) Segments Data High for COM6 Line"]
    pub SDATAH6: SLCD_SDATAH6_Type,
    #[doc = "< \\brief Offset: 0x5C (R/W 32) Segments Data Low for COM7 Line"]
    pub SDATAL7: SLCD_SDATAL7_Type,
    #[doc = "< \\brief Offset: 0x60 (R/W 32) Segments Data High for COM7 Line"]
    pub SDATAH7: SLCD_SDATAH7_Type,
    #[doc = "< \\brief Offset: 0x64 ( /W 32) Indirect Segments Data Access"]
    pub ISDATA: SLCD_ISDATA_Type,
    #[doc = "< \\brief Offset: 0x68 (R/W 32) Blink Configuration"]
    pub BCFG: SLCD_BCFG_Type,
    #[doc = "< \\brief Offset: 0x6C (R/W 32) Circular Shift Register Configuration"]
    pub CSRCFG: SLCD_CSRCFG_Type,
    #[doc = "< \\brief Offset: 0x70 (R/W  8) Character Mapping Configuration"]
    pub CMCFG: SLCD_CMCFG_Type,
    pub Reserved4: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x74 (R/W 32) Automated Character Mapping Configuration"]
    pub ACMCFG: SLCD_ACMCFG_Type,
    #[doc = "< \\brief Offset: 0x78 (R/W  8) Automated Bit Mapping Configuration"]
    pub ABMCFG: SLCD_ABMCFG_Type,
    pub Reserved5: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x7C ( /W 32) Character Mapping Segments Data"]
    pub CMDATA: SLCD_CMDATA_Type,
    #[doc = "< \\brief Offset: 0x80 (R/W 32) Character Mapping Segments Data Mask"]
    pub CMDMASK: SLCD_CMDMASK_Type,
    #[doc = "< \\brief Offset: 0x84 (R/W 16) Character Mapping SEG/COM Index"]
    pub CMINDEX: SLCD_CMINDEX_Type,
}
#[test]
fn bindgen_test_layout_Slcd() {
    const UNINIT: ::core::mem::MaybeUninit<Slcd> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Slcd>(),
        136usize,
        concat!("Size of: ", stringify!(Slcd))
    );
    assert_eq!(
        ::core::mem::align_of::<Slcd>(),
        4usize,
        concat!("Alignment of ", stringify!(Slcd))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLC) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(CTRLC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLD) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(CTRLD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FC0) as usize - ptr as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Slcd), "::", stringify!(FC0))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FC1) as usize - ptr as usize },
        25usize,
        concat!("Offset of field: ", stringify!(Slcd), "::", stringify!(FC1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FC2) as usize - ptr as usize },
        26usize,
        concat!("Offset of field: ", stringify!(Slcd), "::", stringify!(FC2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LPENL) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(LPENL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LPENH) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(LPENH)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAL0) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAL0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAH0) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAH0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAL1) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAL1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAH1) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAH1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAL2) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAL2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAH2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAH2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAL3) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAL3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAH3) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAH3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAL4) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAL4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAH4) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAH4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAL5) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAL5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAH5) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAH5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAL6) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAL6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAH6) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAH6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAL7) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAL7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SDATAH7) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(SDATAH7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ISDATA) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(ISDATA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BCFG) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(BCFG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CSRCFG) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(CSRCFG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CMCFG) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(CMCFG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ACMCFG) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(ACMCFG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ABMCFG) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(ABMCFG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        121usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CMDATA) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(CMDATA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CMDMASK) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(CMDMASK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CMINDEX) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(Slcd),
            "::",
            stringify!(CMINDEX)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUPC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SUPC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SUPC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SUPC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SUPC_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SUPC_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl SUPC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn BOD33RDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33RDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33DET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33DET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B33SRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B33SRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD12RDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD12RDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD12DET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD12DET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B12SRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B12SRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VREGRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VREGRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn APWSRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_APWSRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VCORERDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VCORERDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BOD33RDY: u32,
        BOD33DET: u32,
        B33SRDY: u32,
        BOD12RDY: u32,
        BOD12DET: u32,
        B12SRDY: u32,
        VREGRDY: u32,
        APWSRDY: u32,
        VCORERDY: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BOD33RDY: u32 = unsafe { ::core::mem::transmute(BOD33RDY) };
            BOD33RDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BOD33DET: u32 = unsafe { ::core::mem::transmute(BOD33DET) };
            BOD33DET as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let B33SRDY: u32 = unsafe { ::core::mem::transmute(B33SRDY) };
            B33SRDY as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let BOD12RDY: u32 = unsafe { ::core::mem::transmute(BOD12RDY) };
            BOD12RDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let BOD12DET: u32 = unsafe { ::core::mem::transmute(BOD12DET) };
            BOD12DET as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let B12SRDY: u32 = unsafe { ::core::mem::transmute(B12SRDY) };
            B12SRDY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let VREGRDY: u32 = unsafe { ::core::mem::transmute(VREGRDY) };
            VREGRDY as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let APWSRDY: u32 = unsafe { ::core::mem::transmute(APWSRDY) };
            APWSRDY as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let VCORERDY: u32 = unsafe { ::core::mem::transmute(VCORERDY) };
            VCORERDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SUPC_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SUPC_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SUPC_INTENCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_INTENCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUPC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SUPC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SUPC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SUPC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SUPC_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SUPC_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl SUPC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn BOD33RDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33RDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33DET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33DET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B33SRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B33SRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD12RDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD12RDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD12DET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD12DET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B12SRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B12SRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VREGRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VREGRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn APWSRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_APWSRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VCORERDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VCORERDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BOD33RDY: u32,
        BOD33DET: u32,
        B33SRDY: u32,
        BOD12RDY: u32,
        BOD12DET: u32,
        B12SRDY: u32,
        VREGRDY: u32,
        APWSRDY: u32,
        VCORERDY: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BOD33RDY: u32 = unsafe { ::core::mem::transmute(BOD33RDY) };
            BOD33RDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BOD33DET: u32 = unsafe { ::core::mem::transmute(BOD33DET) };
            BOD33DET as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let B33SRDY: u32 = unsafe { ::core::mem::transmute(B33SRDY) };
            B33SRDY as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let BOD12RDY: u32 = unsafe { ::core::mem::transmute(BOD12RDY) };
            BOD12RDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let BOD12DET: u32 = unsafe { ::core::mem::transmute(BOD12DET) };
            BOD12DET as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let B12SRDY: u32 = unsafe { ::core::mem::transmute(B12SRDY) };
            B12SRDY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let VREGRDY: u32 = unsafe { ::core::mem::transmute(VREGRDY) };
            VREGRDY as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let APWSRDY: u32 = unsafe { ::core::mem::transmute(APWSRDY) };
            APWSRDY as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let VCORERDY: u32 = unsafe { ::core::mem::transmute(VCORERDY) };
            VCORERDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SUPC_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SUPC_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SUPC_INTENSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_INTENSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUPC_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SUPC_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SUPC_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SUPC_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SUPC_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_INTFLAG_Type__bindgen_ty_1))
    );
}
impl SUPC_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn BOD33RDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33RDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33DET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33DET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B33SRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B33SRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD12RDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD12RDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD12DET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD12DET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B12SRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B12SRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VREGRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VREGRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn APWSRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_APWSRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VCORERDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VCORERDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BOD33RDY: u32,
        BOD33DET: u32,
        B33SRDY: u32,
        BOD12RDY: u32,
        BOD12DET: u32,
        B12SRDY: u32,
        VREGRDY: u32,
        APWSRDY: u32,
        VCORERDY: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BOD33RDY: u32 = unsafe { ::core::mem::transmute(BOD33RDY) };
            BOD33RDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BOD33DET: u32 = unsafe { ::core::mem::transmute(BOD33DET) };
            BOD33DET as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let B33SRDY: u32 = unsafe { ::core::mem::transmute(B33SRDY) };
            B33SRDY as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let BOD12RDY: u32 = unsafe { ::core::mem::transmute(BOD12RDY) };
            BOD12RDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let BOD12DET: u32 = unsafe { ::core::mem::transmute(BOD12DET) };
            BOD12DET as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let B12SRDY: u32 = unsafe { ::core::mem::transmute(B12SRDY) };
            B12SRDY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let VREGRDY: u32 = unsafe { ::core::mem::transmute(VREGRDY) };
            VREGRDY as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let APWSRDY: u32 = unsafe { ::core::mem::transmute(APWSRDY) };
            APWSRDY as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let VCORERDY: u32 = unsafe { ::core::mem::transmute(VCORERDY) };
            VCORERDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SUPC_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SUPC_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SUPC_INTFLAG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_INTFLAG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUPC_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SUPC_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SUPC_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SUPC_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SUPC_STATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_STATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_STATUS_Type__bindgen_ty_1))
    );
}
impl SUPC_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn BOD33RDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33RDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD33DET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD33DET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B33SRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B33SRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD12RDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD12RDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BOD12DET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BOD12DET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn B12SRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_B12SRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VREGRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VREGRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn APWSRDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_APWSRDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VCORERDY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VCORERDY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BBPS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BBPS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BOD33RDY: u32,
        BOD33DET: u32,
        B33SRDY: u32,
        BOD12RDY: u32,
        BOD12DET: u32,
        B12SRDY: u32,
        VREGRDY: u32,
        APWSRDY: u32,
        VCORERDY: u32,
        BBPS: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let BOD33RDY: u32 = unsafe { ::core::mem::transmute(BOD33RDY) };
            BOD33RDY as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let BOD33DET: u32 = unsafe { ::core::mem::transmute(BOD33DET) };
            BOD33DET as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let B33SRDY: u32 = unsafe { ::core::mem::transmute(B33SRDY) };
            B33SRDY as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let BOD12RDY: u32 = unsafe { ::core::mem::transmute(BOD12RDY) };
            BOD12RDY as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let BOD12DET: u32 = unsafe { ::core::mem::transmute(BOD12DET) };
            BOD12DET as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let B12SRDY: u32 = unsafe { ::core::mem::transmute(B12SRDY) };
            B12SRDY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let VREGRDY: u32 = unsafe { ::core::mem::transmute(VREGRDY) };
            VREGRDY as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let APWSRDY: u32 = unsafe { ::core::mem::transmute(APWSRDY) };
            APWSRDY as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let VCORERDY: u32 = unsafe { ::core::mem::transmute(VCORERDY) };
            VCORERDY as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let BBPS: u32 = unsafe { ::core::mem::transmute(BBPS) };
            BBPS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SUPC_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SUPC_STATUS_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SUPC_STATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_STATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUPC_BOD33_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SUPC_BOD33_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SUPC_BOD33_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SUPC_BOD33_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SUPC_BOD33_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_BOD33_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_BOD33_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_BOD33_Type__bindgen_ty_1))
    );
}
impl SUPC_BOD33_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HYST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HYST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ACTION(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ACTION(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn STDBYCFG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_STDBYCFG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNBKUP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNBKUP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ACTCFG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ACTCFG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VMON(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VMON(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_PSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn LEVEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_LEVEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn BKUPLEVEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_BKUPLEVEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u32,
        HYST: u32,
        ACTION: u32,
        STDBYCFG: u32,
        RUNSTDBY: u32,
        RUNBKUP: u32,
        ACTCFG: u32,
        VMON: u32,
        PSEL: u32,
        LEVEL: u32,
        BKUPLEVEL: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HYST: u32 = unsafe { ::core::mem::transmute(HYST) };
            HYST as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let ACTION: u32 = unsafe { ::core::mem::transmute(ACTION) };
            ACTION as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STDBYCFG: u32 = unsafe { ::core::mem::transmute(STDBYCFG) };
            STDBYCFG as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RUNBKUP: u32 = unsafe { ::core::mem::transmute(RUNBKUP) };
            RUNBKUP as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ACTCFG: u32 = unsafe { ::core::mem::transmute(ACTCFG) };
            ACTCFG as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let VMON: u32 = unsafe { ::core::mem::transmute(VMON) };
            VMON as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let PSEL: u32 = unsafe { ::core::mem::transmute(PSEL) };
            PSEL as u64
        });
        __bindgen_bitfield_unit.set(16usize, 6u8, {
            let LEVEL: u32 = unsafe { ::core::mem::transmute(LEVEL) };
            LEVEL as u64
        });
        __bindgen_bitfield_unit.set(24usize, 6u8, {
            let BKUPLEVEL: u32 = unsafe { ::core::mem::transmute(BKUPLEVEL) };
            BKUPLEVEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SUPC_BOD33_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SUPC_BOD33_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SUPC_BOD33_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_BOD33_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_BOD33_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_BOD33_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_BOD33_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_BOD33_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUPC_BOD12_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SUPC_BOD12_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SUPC_BOD12_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SUPC_BOD12_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SUPC_BOD12_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_BOD12_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_BOD12_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_BOD12_Type__bindgen_ty_1))
    );
}
impl SUPC_BOD12_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HYST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HYST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ACTION(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_ACTION(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn STDBYCFG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_STDBYCFG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ACTCFG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ACTCFG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_PSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn LEVEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_LEVEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u32,
        HYST: u32,
        ACTION: u32,
        STDBYCFG: u32,
        RUNSTDBY: u32,
        ACTCFG: u32,
        PSEL: u32,
        LEVEL: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HYST: u32 = unsafe { ::core::mem::transmute(HYST) };
            HYST as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let ACTION: u32 = unsafe { ::core::mem::transmute(ACTION) };
            ACTION as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STDBYCFG: u32 = unsafe { ::core::mem::transmute(STDBYCFG) };
            STDBYCFG as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ACTCFG: u32 = unsafe { ::core::mem::transmute(ACTCFG) };
            ACTCFG as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let PSEL: u32 = unsafe { ::core::mem::transmute(PSEL) };
            PSEL as u64
        });
        __bindgen_bitfield_unit.set(16usize, 6u8, {
            let LEVEL: u32 = unsafe { ::core::mem::transmute(LEVEL) };
            LEVEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SUPC_BOD12_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SUPC_BOD12_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SUPC_BOD12_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_BOD12_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_BOD12_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_BOD12_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_BOD12_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_BOD12_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUPC_VREG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SUPC_VREG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SUPC_VREG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SUPC_VREG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SUPC_VREG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_VREG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_VREG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_VREG_Type__bindgen_ty_1))
    );
}
impl SUPC_VREG_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn STDBYPL0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_STDBYPL0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPEFF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LPEFF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VSVSTEP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_VSVSTEP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn VSPER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_VSPER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u32,
        SEL: u32,
        STDBYPL0: u32,
        RUNSTDBY: u32,
        LPEFF: u32,
        VSVSTEP: u32,
        VSPER: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let SEL: u32 = unsafe { ::core::mem::transmute(SEL) };
            SEL as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STDBYPL0: u32 = unsafe { ::core::mem::transmute(STDBYPL0) };
            STDBYPL0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let LPEFF: u32 = unsafe { ::core::mem::transmute(LPEFF) };
            LPEFF as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let VSVSTEP: u32 = unsafe { ::core::mem::transmute(VSVSTEP) };
            VSVSTEP as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let VSPER: u32 = unsafe { ::core::mem::transmute(VSPER) };
            VSPER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SUPC_VREG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SUPC_VREG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SUPC_VREG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_VREG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_VREG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_VREG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_VREG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_VREG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUPC_VREF_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SUPC_VREF_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SUPC_VREF_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SUPC_VREF_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SUPC_VREF_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_VREF_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_VREF_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_VREF_Type__bindgen_ty_1))
    );
}
impl SUPC_VREF_Type__bindgen_ty_1 {
    #[inline]
    pub fn TSEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TSEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VREFOE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VREFOE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TSSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TSSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_SEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TSEN: u32,
        VREFOE: u32,
        TSSEL: u32,
        RUNSTDBY: u32,
        ONDEMAND: u32,
        SEL: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TSEN: u32 = unsafe { ::core::mem::transmute(TSEN) };
            TSEN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let VREFOE: u32 = unsafe { ::core::mem::transmute(VREFOE) };
            VREFOE as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let TSSEL: u32 = unsafe { ::core::mem::transmute(TSSEL) };
            TSSEL as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u32 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let SEL: u32 = unsafe { ::core::mem::transmute(SEL) };
            SEL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SUPC_VREF_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SUPC_VREF_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SUPC_VREF_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_VREF_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_VREF_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_VREF_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_VREF_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_VREF_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUPC_BBPS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SUPC_BBPS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SUPC_BBPS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SUPC_BBPS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SUPC_BBPS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_BBPS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_BBPS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_BBPS_Type__bindgen_ty_1))
    );
}
impl SUPC_BBPS_Type__bindgen_ty_1 {
    #[inline]
    pub fn CONF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CONF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAKEEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PSOKEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PSOKEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CONF: u32,
        WAKEEN: u32,
        PSOKEN: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let CONF: u32 = unsafe { ::core::mem::transmute(CONF) };
            CONF as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WAKEEN: u32 = unsafe { ::core::mem::transmute(WAKEEN) };
            WAKEEN as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PSOKEN: u32 = unsafe { ::core::mem::transmute(PSOKEN) };
            PSOKEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SUPC_BBPS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SUPC_BBPS_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SUPC_BBPS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_BBPS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_BBPS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_BBPS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_BBPS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_BBPS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUPC_BKOUT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SUPC_BKOUT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SUPC_BKOUT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SUPC_BKOUT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SUPC_BKOUT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_BKOUT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_BKOUT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_BKOUT_Type__bindgen_ty_1))
    );
}
impl SUPC_BKOUT_Type__bindgen_ty_1 {
    #[inline]
    pub fn EN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_EN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CLR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CLR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn SET(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SET(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RTCTGL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RTCTGL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EN: u32,
        CLR: u32,
        SET: u32,
        RTCTGL: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let EN: u32 = unsafe { ::core::mem::transmute(EN) };
            EN as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let CLR: u32 = unsafe { ::core::mem::transmute(CLR) };
            CLR as u64
        });
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let SET: u32 = unsafe { ::core::mem::transmute(SET) };
            SET as u64
        });
        __bindgen_bitfield_unit.set(24usize, 2u8, {
            let RTCTGL: u32 = unsafe { ::core::mem::transmute(RTCTGL) };
            RTCTGL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SUPC_BKOUT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SUPC_BKOUT_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SUPC_BKOUT_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_BKOUT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_BKOUT_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_BKOUT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_BKOUT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_BKOUT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SUPC_BKIN_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: SUPC_BKIN_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct SUPC_BKIN_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_SUPC_BKIN_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<SUPC_BKIN_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_BKIN_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_BKIN_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_BKIN_Type__bindgen_ty_1))
    );
}
impl SUPC_BKIN_Type__bindgen_ty_1 {
    #[inline]
    pub fn BKIN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BKIN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(BKIN: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BKIN: u32 = unsafe { ::core::mem::transmute(BKIN) };
            BKIN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_SUPC_BKIN_Type() {
    const UNINIT: ::core::mem::MaybeUninit<SUPC_BKIN_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SUPC_BKIN_Type>(),
        4usize,
        concat!("Size of: ", stringify!(SUPC_BKIN_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<SUPC_BKIN_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(SUPC_BKIN_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_BKIN_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SUPC_BKIN_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Supc {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Interrupt Enable Clear"]
    pub INTENCLR: SUPC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W 32) Interrupt Enable Set"]
    pub INTENSET: SUPC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W 32) Interrupt Flag Status and Clear"]
    pub INTFLAG: SUPC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0C (R/  32) Power and Clocks Status"]
    pub STATUS: SUPC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 32) BOD33 Control"]
    pub BOD33: SUPC_BOD33_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) BOD12 Control"]
    pub BOD12: SUPC_BOD12_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W 32) VREG Control"]
    pub VREG: SUPC_VREG_Type,
    #[doc = "< \\brief Offset: 0x1C (R/W 32) VREF Control"]
    pub VREF: SUPC_VREF_Type,
    #[doc = "< \\brief Offset: 0x20 (R/W 32) Battery Backup Power Switch"]
    pub BBPS: SUPC_BBPS_Type,
    #[doc = "< \\brief Offset: 0x24 (R/W 32) Backup Output Control"]
    pub BKOUT: SUPC_BKOUT_Type,
    #[doc = "< \\brief Offset: 0x28 (R/  32) Backup Input Control"]
    pub BKIN: SUPC_BKIN_Type,
}
#[test]
fn bindgen_test_layout_Supc() {
    const UNINIT: ::core::mem::MaybeUninit<Supc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Supc>(),
        44usize,
        concat!("Size of: ", stringify!(Supc))
    );
    assert_eq!(
        ::core::mem::align_of::<Supc>(),
        4usize,
        concat!("Alignment of ", stringify!(Supc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Supc),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Supc),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Supc),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Supc),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BOD33) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Supc),
            "::",
            stringify!(BOD33)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BOD12) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Supc),
            "::",
            stringify!(BOD12)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VREG) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Supc),
            "::",
            stringify!(VREG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VREF) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Supc),
            "::",
            stringify!(VREF)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BBPS) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Supc),
            "::",
            stringify!(BBPS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKOUT) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Supc),
            "::",
            stringify!(BKOUT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BKIN) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Supc),
            "::",
            stringify!(BKIN)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_CTRLA_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TC_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TC_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TC_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TC_CTRLA_Type__bindgen_ty_1))
    );
}
impl TC_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCSYNC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PRESCSYNC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONDEMAND(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ONDEMAND(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCALER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_PRESCALER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ALOCK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ALOCK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CAPTEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CAPTEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CAPTEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CAPTEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COPEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COPEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COPEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COPEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        MODE: u32,
        PRESCSYNC: u32,
        RUNSTDBY: u32,
        ONDEMAND: u32,
        PRESCALER: u32,
        ALOCK: u32,
        CAPTEN0: u32,
        CAPTEN1: u32,
        COPEN0: u32,
        COPEN1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let MODE: u32 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let PRESCSYNC: u32 = unsafe { ::core::mem::transmute(PRESCSYNC) };
            PRESCSYNC as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ONDEMAND: u32 = unsafe { ::core::mem::transmute(ONDEMAND) };
            ONDEMAND as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let PRESCALER: u32 = unsafe { ::core::mem::transmute(PRESCALER) };
            PRESCALER as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let ALOCK: u32 = unsafe { ::core::mem::transmute(ALOCK) };
            ALOCK as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let CAPTEN0: u32 = unsafe { ::core::mem::transmute(CAPTEN0) };
            CAPTEN0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let CAPTEN1: u32 = unsafe { ::core::mem::transmute(CAPTEN1) };
            CAPTEN1 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let COPEN0: u32 = unsafe { ::core::mem::transmute(COPEN0) };
            COPEN0 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let COPEN1: u32 = unsafe { ::core::mem::transmute(COPEN1) };
            COPEN1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TC_CTRLA_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TC_CTRLA_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLA_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TC_CTRLA_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLA_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TC_CTRLA_Type__bindgen_ty_2))
    );
}
impl TC_CTRLA_Type__bindgen_ty_2 {
    #[inline]
    pub fn CAPTEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CAPTEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn COPEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_COPEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CAPTEN: u32, COPEN: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(16usize, 2u8, {
            let CAPTEN: u32 = unsafe { ::core::mem::transmute(CAPTEN) };
            CAPTEN as u64
        });
        __bindgen_bitfield_unit.set(20usize, 2u8, {
            let COPEN: u32 = unsafe { ::core::mem::transmute(COPEN) };
            COPEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TC_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TC_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLA_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_CTRLBCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_CTRLBCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_CTRLBCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_CTRLBCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLBCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_CTRLBCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLBCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_CTRLBCLR_Type__bindgen_ty_1))
    );
}
impl TC_CTRLBCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DIR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LUPD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LUPD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONESHOT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ONESHOT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DIR: u8,
        LUPD: u8,
        ONESHOT: u8,
        CMD: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DIR: u8 = unsafe { ::core::mem::transmute(DIR) };
            DIR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LUPD: u8 = unsafe { ::core::mem::transmute(LUPD) };
            LUPD as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ONESHOT: u8 = unsafe { ::core::mem::transmute(ONESHOT) };
            ONESHOT as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let CMD: u8 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_CTRLBCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_CTRLBCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLBCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_CTRLBCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLBCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_CTRLBCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLBCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLBCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_CTRLBSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_CTRLBSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_CTRLBSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_CTRLBSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLBSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_CTRLBSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLBSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_CTRLBSET_Type__bindgen_ty_1))
    );
}
impl TC_CTRLBSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DIR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LUPD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LUPD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONESHOT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ONESHOT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DIR: u8,
        LUPD: u8,
        ONESHOT: u8,
        CMD: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DIR: u8 = unsafe { ::core::mem::transmute(DIR) };
            DIR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LUPD: u8 = unsafe { ::core::mem::transmute(LUPD) };
            LUPD as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ONESHOT: u8 = unsafe { ::core::mem::transmute(ONESHOT) };
            ONESHOT as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let CMD: u8 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_CTRLBSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_CTRLBSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_CTRLBSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_CTRLBSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_CTRLBSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_CTRLBSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLBSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_CTRLBSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TC_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_TC_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TC_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_EVCTRL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_EVCTRL_Type__bindgen_ty_1))
    );
}
impl TC_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn EVACT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_EVACT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn TCINV(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TCINV(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCEI(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TCEI(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OVFEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OVFEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MCEO0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MCEO1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EVACT: u16,
        TCINV: u16,
        TCEI: u16,
        OVFEO: u16,
        MCEO0: u16,
        MCEO1: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let EVACT: u16 = unsafe { ::core::mem::transmute(EVACT) };
            EVACT as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let TCINV: u16 = unsafe { ::core::mem::transmute(TCINV) };
            TCINV as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let TCEI: u16 = unsafe { ::core::mem::transmute(TCEI) };
            TCEI as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let OVFEO: u16 = unsafe { ::core::mem::transmute(OVFEO) };
            OVFEO as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let MCEO0: u16 = unsafe { ::core::mem::transmute(MCEO0) };
            MCEO0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let MCEO1: u16 = unsafe { ::core::mem::transmute(MCEO1) };
            MCEO1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TC_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_TC_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(TC_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_EVCTRL_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_EVCTRL_Type__bindgen_ty_2))
    );
}
impl TC_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn MCEO(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_MCEO(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MCEO: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let MCEO: u16 = unsafe { ::core::mem::transmute(MCEO) };
            MCEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_EVCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_EVCTRL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TC_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_EVCTRL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTENCLR_Type__bindgen_ty_1))
    );
}
impl TC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MC0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MC1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVF: u8,
        ERR: u8,
        MC0: u8,
        MC1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERR: u8 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MC0: u8 = unsafe { ::core::mem::transmute(MC0) };
            MC0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MC1: u8 = unsafe { ::core::mem::transmute(MC1) };
            MC1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTENCLR_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTENCLR_Type__bindgen_ty_2))
    );
}
impl TC_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn MC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_MC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MC: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let MC: u8 = unsafe { ::core::mem::transmute(MC) };
            MC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTENSET_Type__bindgen_ty_1))
    );
}
impl TC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MC0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MC1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVF: u8,
        ERR: u8,
        MC0: u8,
        MC1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERR: u8 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MC0: u8 = unsafe { ::core::mem::transmute(MC0) };
            MC0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MC1: u8 = unsafe { ::core::mem::transmute(MC1) };
            MC1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTENSET_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTENSET_Type__bindgen_ty_2))
    );
}
impl TC_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn MC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_MC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MC: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let MC: u8 = unsafe { ::core::mem::transmute(MC) };
            MC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTFLAG_Type__bindgen_ty_1))
    );
}
impl TC_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MC0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MC1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVF: u8,
        ERR: u8,
        MC0: u8,
        MC1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVF: u8 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERR: u8 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let MC0: u8 = unsafe { ::core::mem::transmute(MC0) };
            MC0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MC1: u8 = unsafe { ::core::mem::transmute(MC1) };
            MC1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTFLAG_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTFLAG_Type__bindgen_ty_2))
    );
}
impl TC_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn MC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_MC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MC: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let MC: u8 = unsafe { ::core::mem::transmute(MC) };
            MC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_STATUS_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_STATUS_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_STATUS_Type__bindgen_ty_1))
    );
}
impl TC_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn STOP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STOP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLAVE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SLAVE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PERBUFV(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PERBUFV(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCBUFV0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CCBUFV0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCBUFV1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CCBUFV1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        STOP: u8,
        SLAVE: u8,
        PERBUFV: u8,
        CCBUFV0: u8,
        CCBUFV1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let STOP: u8 = unsafe { ::core::mem::transmute(STOP) };
            STOP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SLAVE: u8 = unsafe { ::core::mem::transmute(SLAVE) };
            SLAVE as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PERBUFV: u8 = unsafe { ::core::mem::transmute(PERBUFV) };
            PERBUFV as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CCBUFV0: u8 = unsafe { ::core::mem::transmute(CCBUFV0) };
            CCBUFV0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CCBUFV1: u8 = unsafe { ::core::mem::transmute(CCBUFV1) };
            CCBUFV1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_STATUS_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_STATUS_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_STATUS_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(TC_STATUS_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_STATUS_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_STATUS_Type__bindgen_ty_2))
    );
}
impl TC_STATUS_Type__bindgen_ty_2 {
    #[inline]
    pub fn CCBUFV(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CCBUFV(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CCBUFV: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let CCBUFV: u8 = unsafe { ::core::mem::transmute(CCBUFV) };
            CCBUFV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_STATUS_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_STATUS_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_WAVE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_WAVE_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_WAVE_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_WAVE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_WAVE_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_WAVE_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_WAVE_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_WAVE_Type__bindgen_ty_1))
    );
}
impl TC_WAVE_Type__bindgen_ty_1 {
    #[inline]
    pub fn WAVEGEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_WAVEGEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(WAVEGEN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let WAVEGEN: u8 = unsafe { ::core::mem::transmute(WAVEGEN) };
            WAVEGEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_WAVE_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_WAVE_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_WAVE_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_WAVE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_WAVE_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_WAVE_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_WAVE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_WAVE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_DRVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_DRVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_DRVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_DRVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_DRVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_DRVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_DRVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_DRVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_DRVCTRL_Type__bindgen_ty_1))
    );
}
impl TC_DRVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn INVEN0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_INVEN0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_INVEN1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(INVEN0: u8, INVEN1: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let INVEN0: u8 = unsafe { ::core::mem::transmute(INVEN0) };
            INVEN0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let INVEN1: u8 = unsafe { ::core::mem::transmute(INVEN1) };
            INVEN1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_DRVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_DRVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_DRVCTRL_Type__bindgen_ty_2>(),
        1usize,
        concat!("Size of: ", stringify!(TC_DRVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_DRVCTRL_Type__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_DRVCTRL_Type__bindgen_ty_2))
    );
}
impl TC_DRVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn INVEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_INVEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(INVEN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let INVEN: u8 = unsafe { ::core::mem::transmute(INVEN) };
            INVEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_DRVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_DRVCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_DRVCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_DRVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_DRVCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_DRVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_DRVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_DRVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_DRVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_DBGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_DBGCTRL_Type__bindgen_ty_1))
    );
}
impl TC_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGRUN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGRUN: u8 = unsafe { ::core::mem::transmute(DBGRUN) };
            DBGRUN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_DBGCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_DBGCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TC_SYNCBUSY_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TC_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TC_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TC_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TC_SYNCBUSY_Type__bindgen_ty_1))
    );
}
impl TC_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTRLB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CTRLB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STATUS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_STATUS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CC0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CC0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CC1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CC1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        CTRLB: u32,
        STATUS: u32,
        COUNT: u32,
        PER: u32,
        CC0: u32,
        CC1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CTRLB: u32 = unsafe { ::core::mem::transmute(CTRLB) };
            CTRLB as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let STATUS: u32 = unsafe { ::core::mem::transmute(STATUS) };
            STATUS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PER: u32 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let CC0: u32 = unsafe { ::core::mem::transmute(CC0) };
            CC0 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CC1: u32 = unsafe { ::core::mem::transmute(CC1) };
            CC1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TC_SYNCBUSY_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TC_SYNCBUSY_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TC_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TC_SYNCBUSY_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TC_SYNCBUSY_Type__bindgen_ty_2))
    );
}
impl TC_SYNCBUSY_Type__bindgen_ty_2 {
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_SYNCBUSY_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TC_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TC_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_SYNCBUSY_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT16_COUNT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT16_COUNT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT16_COUNT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_TC_COUNT16_COUNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT16_COUNT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TC_COUNT16_COUNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT16_COUNT_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT16_COUNT_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT16_COUNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let COUNT: u16 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT16_COUNT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_COUNT16_COUNT_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT16_COUNT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TC_COUNT16_COUNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT16_COUNT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_COUNT16_COUNT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT16_COUNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT16_COUNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT32_COUNT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT32_COUNT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT32_COUNT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TC_COUNT32_COUNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT32_COUNT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TC_COUNT32_COUNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT32_COUNT_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT32_COUNT_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT32_COUNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT32_COUNT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_COUNT32_COUNT_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT32_COUNT_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TC_COUNT32_COUNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT32_COUNT_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TC_COUNT32_COUNT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT32_COUNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT32_COUNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT8_COUNT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT8_COUNT_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT8_COUNT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_COUNT8_COUNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_COUNT_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_COUNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_COUNT_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT8_COUNT_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT8_COUNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let COUNT: u8 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT8_COUNT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_COUNT8_COUNT_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_COUNT_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_COUNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_COUNT_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_COUNT8_COUNT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_COUNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_COUNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT8_PER_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT8_PER_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT8_PER_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_COUNT8_PER_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_PER_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_PER_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_PER_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT8_PER_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT8_PER_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PER: u8 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT8_PER_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_COUNT8_PER_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_PER_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_PER_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_PER_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_COUNT8_PER_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_PER_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_PER_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT16_CC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT16_CC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT16_CC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_TC_COUNT16_CC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT16_CC_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TC_COUNT16_CC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT16_CC_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT16_CC_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT16_CC_Type__bindgen_ty_1 {
    #[inline]
    pub fn CC(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CC: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let CC: u16 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT16_CC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_COUNT16_CC_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT16_CC_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TC_COUNT16_CC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT16_CC_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_COUNT16_CC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT16_CC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT16_CC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT32_CC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT32_CC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT32_CC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TC_COUNT32_CC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT32_CC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TC_COUNT32_CC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT32_CC_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT32_CC_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT32_CC_Type__bindgen_ty_1 {
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT32_CC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_COUNT32_CC_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT32_CC_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TC_COUNT32_CC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT32_CC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TC_COUNT32_CC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT32_CC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT32_CC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT8_CC_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT8_CC_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT8_CC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_COUNT8_CC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_CC_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_CC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_CC_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_COUNT8_CC_Type__bindgen_ty_1))
    );
}
impl TC_COUNT8_CC_Type__bindgen_ty_1 {
    #[inline]
    pub fn CC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CC: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let CC: u8 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT8_CC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_COUNT8_CC_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_CC_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_CC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_CC_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_COUNT8_CC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_CC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_CC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT8_PERBUF_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT8_PERBUF_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT8_PERBUF_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_COUNT8_PERBUF_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_PERBUF_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_PERBUF_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_PERBUF_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT8_PERBUF_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT8_PERBUF_Type__bindgen_ty_1 {
    #[inline]
    pub fn PERBUF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_PERBUF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PERBUF: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PERBUF: u8 = unsafe { ::core::mem::transmute(PERBUF) };
            PERBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT8_PERBUF_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_COUNT8_PERBUF_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_PERBUF_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_PERBUF_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_PERBUF_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_COUNT8_PERBUF_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_PERBUF_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_PERBUF_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT16_CCBUF_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT16_CCBUF_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT16_CCBUF_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_TC_COUNT16_CCBUF_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT16_CCBUF_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TC_COUNT16_CCBUF_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT16_CCBUF_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT16_CCBUF_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT16_CCBUF_Type__bindgen_ty_1 {
    #[inline]
    pub fn CCBUF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_CCBUF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CCBUF: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let CCBUF: u16 = unsafe { ::core::mem::transmute(CCBUF) };
            CCBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT16_CCBUF_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_COUNT16_CCBUF_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT16_CCBUF_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TC_COUNT16_CCBUF_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT16_CCBUF_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TC_COUNT16_CCBUF_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT16_CCBUF_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT16_CCBUF_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT32_CCBUF_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT32_CCBUF_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT32_CCBUF_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TC_COUNT32_CCBUF_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT32_CCBUF_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TC_COUNT32_CCBUF_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT32_CCBUF_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT32_CCBUF_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT32_CCBUF_Type__bindgen_ty_1 {
    #[inline]
    pub fn CCBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_CCBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CCBUF: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let CCBUF: u32 = unsafe { ::core::mem::transmute(CCBUF) };
            CCBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT32_CCBUF_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_COUNT32_CCBUF_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT32_CCBUF_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TC_COUNT32_CCBUF_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT32_CCBUF_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TC_COUNT32_CCBUF_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT32_CCBUF_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT32_CCBUF_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TC_COUNT8_CCBUF_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TC_COUNT8_CCBUF_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TC_COUNT8_CCBUF_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TC_COUNT8_CCBUF_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_CCBUF_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_CCBUF_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_CCBUF_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(TC_COUNT8_CCBUF_Type__bindgen_ty_1)
        )
    );
}
impl TC_COUNT8_CCBUF_Type__bindgen_ty_1 {
    #[inline]
    pub fn CCBUF(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_CCBUF(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CCBUF: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let CCBUF: u8 = unsafe { ::core::mem::transmute(CCBUF) };
            CCBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TC_COUNT8_CCBUF_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TC_COUNT8_CCBUF_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TC_COUNT8_CCBUF_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TC_COUNT8_CCBUF_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TC_COUNT8_CCBUF_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TC_COUNT8_CCBUF_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_CCBUF_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TC_COUNT8_CCBUF_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TcCount8 {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Control A"]
    pub CTRLA: TC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Control B Clear"]
    pub CTRLBCLR: TC_CTRLBCLR_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Control B Set"]
    pub CTRLBSET: TC_CTRLBSET_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W 16) Event Control"]
    pub EVCTRL: TC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: TC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x09 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: TC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x0A (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: TC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0B (R/W  8) Status"]
    pub STATUS: TC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Waveform Generation Control"]
    pub WAVE: TC_WAVE_Type,
    #[doc = "< \\brief Offset: 0x0D (R/W  8) Control C"]
    pub DRVCTRL: TC_DRVCTRL_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0F (R/W  8) Debug Control"]
    pub DBGCTRL: TC_DBGCTRL_Type,
    #[doc = "< \\brief Offset: 0x10 (R/  32) Synchronization Status"]
    pub SYNCBUSY: TC_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W  8) COUNT8 Count"]
    pub COUNT: TC_COUNT8_COUNT_Type,
    pub Reserved2: [RoReg8; 6usize],
    #[doc = "< \\brief Offset: 0x1B (R/W  8) COUNT8 Period"]
    pub PER: TC_COUNT8_PER_Type,
    #[doc = "< \\brief Offset: 0x1C (R/W  8) COUNT8 Compare and Capture"]
    pub CC: [TC_COUNT8_CC_Type; 2usize],
    pub Reserved3: [RoReg8; 17usize],
    #[doc = "< \\brief Offset: 0x2F (R/W  8) COUNT8 Period Buffer"]
    pub PERBUF: TC_COUNT8_PERBUF_Type,
    #[doc = "< \\brief Offset: 0x30 (R/W  8) COUNT8 Compare and Capture Buffer"]
    pub CCBUF: [TC_COUNT8_CCBUF_Type; 2usize],
}
#[test]
fn bindgen_test_layout_TcCount8() {
    const UNINIT: ::core::mem::MaybeUninit<TcCount8> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TcCount8>(),
        52usize,
        concat!("Size of: ", stringify!(TcCount8))
    );
    assert_eq!(
        ::core::mem::align_of::<TcCount8>(),
        4usize,
        concat!("Alignment of ", stringify!(TcCount8))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLBCLR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(CTRLBCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLBSET) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(CTRLBSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WAVE) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(WAVE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DRVCTRL) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(DRVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COUNT) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(COUNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PER) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(PER)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CC) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(CC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PERBUF) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(PERBUF)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCBUF) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount8),
            "::",
            stringify!(CCBUF)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TcCount16 {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Control A"]
    pub CTRLA: TC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Control B Clear"]
    pub CTRLBCLR: TC_CTRLBCLR_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Control B Set"]
    pub CTRLBSET: TC_CTRLBSET_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W 16) Event Control"]
    pub EVCTRL: TC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: TC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x09 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: TC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x0A (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: TC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0B (R/W  8) Status"]
    pub STATUS: TC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Waveform Generation Control"]
    pub WAVE: TC_WAVE_Type,
    #[doc = "< \\brief Offset: 0x0D (R/W  8) Control C"]
    pub DRVCTRL: TC_DRVCTRL_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0F (R/W  8) Debug Control"]
    pub DBGCTRL: TC_DBGCTRL_Type,
    #[doc = "< \\brief Offset: 0x10 (R/  32) Synchronization Status"]
    pub SYNCBUSY: TC_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 16) COUNT16 Count"]
    pub COUNT: TC_COUNT16_COUNT_Type,
    pub Reserved2: [RoReg8; 6usize],
    #[doc = "< \\brief Offset: 0x1C (R/W 16) COUNT16 Compare and Capture"]
    pub CC: [TC_COUNT16_CC_Type; 2usize],
    pub Reserved3: [RoReg8; 16usize],
    #[doc = "< \\brief Offset: 0x30 (R/W 16) COUNT16 Compare and Capture Buffer"]
    pub CCBUF: [TC_COUNT16_CCBUF_Type; 2usize],
}
#[test]
fn bindgen_test_layout_TcCount16() {
    const UNINIT: ::core::mem::MaybeUninit<TcCount16> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TcCount16>(),
        52usize,
        concat!("Size of: ", stringify!(TcCount16))
    );
    assert_eq!(
        ::core::mem::align_of::<TcCount16>(),
        4usize,
        concat!("Alignment of ", stringify!(TcCount16))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLBCLR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(CTRLBCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLBSET) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(CTRLBSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WAVE) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(WAVE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DRVCTRL) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(DRVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COUNT) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(COUNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CC) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(CC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCBUF) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount16),
            "::",
            stringify!(CCBUF)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TcCount32 {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Control A"]
    pub CTRLA: TC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Control B Clear"]
    pub CTRLBCLR: TC_CTRLBCLR_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Control B Set"]
    pub CTRLBSET: TC_CTRLBSET_Type,
    #[doc = "< \\brief Offset: 0x06 (R/W 16) Event Control"]
    pub EVCTRL: TC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x08 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: TC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x09 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: TC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x0A (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: TC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x0B (R/W  8) Status"]
    pub STATUS: TC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W  8) Waveform Generation Control"]
    pub WAVE: TC_WAVE_Type,
    #[doc = "< \\brief Offset: 0x0D (R/W  8) Control C"]
    pub DRVCTRL: TC_DRVCTRL_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x0F (R/W  8) Debug Control"]
    pub DBGCTRL: TC_DBGCTRL_Type,
    #[doc = "< \\brief Offset: 0x10 (R/  32) Synchronization Status"]
    pub SYNCBUSY: TC_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) COUNT32 Count"]
    pub COUNT: TC_COUNT32_COUNT_Type,
    pub Reserved2: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x1C (R/W 32) COUNT32 Compare and Capture"]
    pub CC: [TC_COUNT32_CC_Type; 2usize],
    pub Reserved3: [RoReg8; 12usize],
    #[doc = "< \\brief Offset: 0x30 (R/W 32) COUNT32 Compare and Capture Buffer"]
    pub CCBUF: [TC_COUNT32_CCBUF_Type; 2usize],
}
#[test]
fn bindgen_test_layout_TcCount32() {
    const UNINIT: ::core::mem::MaybeUninit<TcCount32> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TcCount32>(),
        56usize,
        concat!("Size of: ", stringify!(TcCount32))
    );
    assert_eq!(
        ::core::mem::align_of::<TcCount32>(),
        4usize,
        concat!("Alignment of ", stringify!(TcCount32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLBCLR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(CTRLBCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLBSET) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(CTRLBSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WAVE) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(WAVE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DRVCTRL) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(DRVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COUNT) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(COUNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CC) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(CC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCBUF) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TcCount32),
            "::",
            stringify!(CCBUF)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Tc {
    #[doc = "< \\brief Offset: 0x00 8-bit Counter Mode"]
    pub COUNT8: TcCount8,
    #[doc = "< \\brief Offset: 0x00 16-bit Counter Mode"]
    pub COUNT16: TcCount16,
    #[doc = "< \\brief Offset: 0x00 32-bit Counter Mode"]
    pub COUNT32: TcCount32,
}
#[test]
fn bindgen_test_layout_Tc() {
    const UNINIT: ::core::mem::MaybeUninit<Tc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Tc>(),
        56usize,
        concat!("Size of: ", stringify!(Tc))
    );
    assert_eq!(
        ::core::mem::align_of::<Tc>(),
        4usize,
        concat!("Alignment of ", stringify!(Tc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COUNT8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tc),
            "::",
            stringify!(COUNT8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COUNT16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tc),
            "::",
            stringify!(COUNT16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COUNT32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tc),
            "::",
            stringify!(COUNT32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_CTRLA_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CTRLA_Type__bindgen_ty_1))
    );
}
impl TCC_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RESOLUTION(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RESOLUTION(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCALER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_PRESCALER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PRESCSYNC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_PRESCSYNC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn ALOCK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ALOCK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MSYNC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MSYNC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DMAOS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DMAOS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPTEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPTEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPTEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPTEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPTEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPTEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CPTEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CPTEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        RESOLUTION: u32,
        PRESCALER: u32,
        RUNSTDBY: u32,
        PRESCSYNC: u32,
        ALOCK: u32,
        MSYNC: u32,
        DMAOS: u32,
        CPTEN0: u32,
        CPTEN1: u32,
        CPTEN2: u32,
        CPTEN3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let RESOLUTION: u32 = unsafe { ::core::mem::transmute(RESOLUTION) };
            RESOLUTION as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let PRESCALER: u32 = unsafe { ::core::mem::transmute(PRESCALER) };
            PRESCALER as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let RUNSTDBY: u32 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let PRESCSYNC: u32 = unsafe { ::core::mem::transmute(PRESCSYNC) };
            PRESCSYNC as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ALOCK: u32 = unsafe { ::core::mem::transmute(ALOCK) };
            ALOCK as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let MSYNC: u32 = unsafe { ::core::mem::transmute(MSYNC) };
            MSYNC as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let DMAOS: u32 = unsafe { ::core::mem::transmute(DMAOS) };
            DMAOS as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let CPTEN0: u32 = unsafe { ::core::mem::transmute(CPTEN0) };
            CPTEN0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let CPTEN1: u32 = unsafe { ::core::mem::transmute(CPTEN1) };
            CPTEN1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let CPTEN2: u32 = unsafe { ::core::mem::transmute(CPTEN2) };
            CPTEN2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let CPTEN3: u32 = unsafe { ::core::mem::transmute(CPTEN3) };
            CPTEN3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CTRLA_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_CTRLA_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLA_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CTRLA_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLA_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CTRLA_Type__bindgen_ty_2))
    );
}
impl TCC_CTRLA_Type__bindgen_ty_2 {
    #[inline]
    pub fn CPTEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CPTEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CPTEN: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let CPTEN: u32 = unsafe { ::core::mem::transmute(CPTEN) };
            CPTEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLA_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_CTRLBCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_CTRLBCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CTRLBCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TCC_CTRLBCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLBCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TCC_CTRLBCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLBCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TCC_CTRLBCLR_Type__bindgen_ty_1))
    );
}
impl TCC_CTRLBCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DIR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LUPD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LUPD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONESHOT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ONESHOT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IDXCMD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_IDXCMD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DIR: u8,
        LUPD: u8,
        ONESHOT: u8,
        IDXCMD: u8,
        CMD: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DIR: u8 = unsafe { ::core::mem::transmute(DIR) };
            DIR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LUPD: u8 = unsafe { ::core::mem::transmute(LUPD) };
            LUPD as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ONESHOT: u8 = unsafe { ::core::mem::transmute(ONESHOT) };
            ONESHOT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let IDXCMD: u8 = unsafe { ::core::mem::transmute(IDXCMD) };
            IDXCMD as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let CMD: u8 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_CTRLBCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_CTRLBCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLBCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TCC_CTRLBCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLBCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TCC_CTRLBCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLBCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLBCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_CTRLBSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_CTRLBSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CTRLBSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TCC_CTRLBSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLBSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TCC_CTRLBSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLBSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TCC_CTRLBSET_Type__bindgen_ty_1))
    );
}
impl TCC_CTRLBSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DIR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DIR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LUPD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LUPD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ONESHOT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ONESHOT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IDXCMD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_IDXCMD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CMD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_CMD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DIR: u8,
        LUPD: u8,
        ONESHOT: u8,
        IDXCMD: u8,
        CMD: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DIR: u8 = unsafe { ::core::mem::transmute(DIR) };
            DIR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LUPD: u8 = unsafe { ::core::mem::transmute(LUPD) };
            LUPD as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ONESHOT: u8 = unsafe { ::core::mem::transmute(ONESHOT) };
            ONESHOT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let IDXCMD: u8 = unsafe { ::core::mem::transmute(IDXCMD) };
            IDXCMD as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let CMD: u8 = unsafe { ::core::mem::transmute(CMD) };
            CMD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_CTRLBSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_CTRLBSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_CTRLBSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TCC_CTRLBSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CTRLBSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TCC_CTRLBSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLBSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CTRLBSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_SYNCBUSY_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_SYNCBUSY_Type__bindgen_ty_1))
    );
}
impl TCC_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CTRLB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CTRLB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STATUS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_STATUS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PATT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PATT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAVE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WAVE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CC0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CC0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CC1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CC1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CC2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CC2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CC3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CC3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u32,
        ENABLE: u32,
        CTRLB: u32,
        STATUS: u32,
        COUNT: u32,
        PATT: u32,
        WAVE: u32,
        PER: u32,
        CC0: u32,
        CC1: u32,
        CC2: u32,
        CC3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u32 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CTRLB: u32 = unsafe { ::core::mem::transmute(CTRLB) };
            CTRLB as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let STATUS: u32 = unsafe { ::core::mem::transmute(STATUS) };
            STATUS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PATT: u32 = unsafe { ::core::mem::transmute(PATT) };
            PATT as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let WAVE: u32 = unsafe { ::core::mem::transmute(WAVE) };
            WAVE as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PER: u32 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CC0: u32 = unsafe { ::core::mem::transmute(CC0) };
            CC0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CC1: u32 = unsafe { ::core::mem::transmute(CC1) };
            CC1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CC2: u32 = unsafe { ::core::mem::transmute(CC2) };
            CC2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let CC3: u32 = unsafe { ::core::mem::transmute(CC3) };
            CC3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_SYNCBUSY_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_SYNCBUSY_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_SYNCBUSY_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_SYNCBUSY_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_SYNCBUSY_Type__bindgen_ty_2))
    );
}
impl TCC_SYNCBUSY_Type__bindgen_ty_2 {
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_SYNCBUSY_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_SYNCBUSY_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_FCTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_FCTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_FCTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_FCTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_FCTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_FCTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_FCTRLA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_FCTRLA_Type__bindgen_ty_1))
    );
}
impl TCC_FCTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SRC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SRC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn KEEP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KEEP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QUAL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QUAL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BLANK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_BLANK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RESTART(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RESTART(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HALT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_HALT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CHSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CHSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CAPTURE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_CAPTURE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn BLANKPRESC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BLANKPRESC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BLANKVAL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BLANKVAL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTERVAL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FILTERVAL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SRC: u32,
        KEEP: u32,
        QUAL: u32,
        BLANK: u32,
        RESTART: u32,
        HALT: u32,
        CHSEL: u32,
        CAPTURE: u32,
        BLANKPRESC: u32,
        BLANKVAL: u32,
        FILTERVAL: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let SRC: u32 = unsafe { ::core::mem::transmute(SRC) };
            SRC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let KEEP: u32 = unsafe { ::core::mem::transmute(KEEP) };
            KEEP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let QUAL: u32 = unsafe { ::core::mem::transmute(QUAL) };
            QUAL as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let BLANK: u32 = unsafe { ::core::mem::transmute(BLANK) };
            BLANK as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RESTART: u32 = unsafe { ::core::mem::transmute(RESTART) };
            RESTART as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let HALT: u32 = unsafe { ::core::mem::transmute(HALT) };
            HALT as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let CHSEL: u32 = unsafe { ::core::mem::transmute(CHSEL) };
            CHSEL as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let CAPTURE: u32 = unsafe { ::core::mem::transmute(CAPTURE) };
            CAPTURE as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let BLANKPRESC: u32 = unsafe { ::core::mem::transmute(BLANKPRESC) };
            BLANKPRESC as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let BLANKVAL: u32 = unsafe { ::core::mem::transmute(BLANKVAL) };
            BLANKVAL as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let FILTERVAL: u32 = unsafe { ::core::mem::transmute(FILTERVAL) };
            FILTERVAL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_FCTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_FCTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_FCTRLA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_FCTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_FCTRLA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_FCTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_FCTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_FCTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_FCTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_FCTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_FCTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_FCTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_FCTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_FCTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_FCTRLB_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_FCTRLB_Type__bindgen_ty_1))
    );
}
impl TCC_FCTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn SRC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_SRC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn KEEP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KEEP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn QUAL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_QUAL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BLANK(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_BLANK(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RESTART(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RESTART(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HALT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_HALT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CHSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CHSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CAPTURE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_CAPTURE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn BLANKPRESC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_BLANKPRESC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BLANKVAL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BLANKVAL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTERVAL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FILTERVAL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SRC: u32,
        KEEP: u32,
        QUAL: u32,
        BLANK: u32,
        RESTART: u32,
        HALT: u32,
        CHSEL: u32,
        CAPTURE: u32,
        BLANKPRESC: u32,
        BLANKVAL: u32,
        FILTERVAL: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let SRC: u32 = unsafe { ::core::mem::transmute(SRC) };
            SRC as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let KEEP: u32 = unsafe { ::core::mem::transmute(KEEP) };
            KEEP as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let QUAL: u32 = unsafe { ::core::mem::transmute(QUAL) };
            QUAL as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let BLANK: u32 = unsafe { ::core::mem::transmute(BLANK) };
            BLANK as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RESTART: u32 = unsafe { ::core::mem::transmute(RESTART) };
            RESTART as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let HALT: u32 = unsafe { ::core::mem::transmute(HALT) };
            HALT as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let CHSEL: u32 = unsafe { ::core::mem::transmute(CHSEL) };
            CHSEL as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let CAPTURE: u32 = unsafe { ::core::mem::transmute(CAPTURE) };
            CAPTURE as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let BLANKPRESC: u32 = unsafe { ::core::mem::transmute(BLANKPRESC) };
            BLANKPRESC as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let BLANKVAL: u32 = unsafe { ::core::mem::transmute(BLANKVAL) };
            BLANKVAL as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let FILTERVAL: u32 = unsafe { ::core::mem::transmute(FILTERVAL) };
            FILTERVAL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_FCTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_FCTRLB_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_FCTRLB_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_FCTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_FCTRLB_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_FCTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_FCTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_FCTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_WEXCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_WEXCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_WEXCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_WEXCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_WEXCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WEXCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WEXCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WEXCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WEXCTRL_Type__bindgen_ty_1))
    );
}
impl TCC_WEXCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn OTMX(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_OTMX(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DTIEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DTIEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTIEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DTIEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTIEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DTIEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTIEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DTIEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTLS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_DTLS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn DTHS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_DTHS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OTMX: u32,
        DTIEN0: u32,
        DTIEN1: u32,
        DTIEN2: u32,
        DTIEN3: u32,
        DTLS: u32,
        DTHS: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let OTMX: u32 = unsafe { ::core::mem::transmute(OTMX) };
            OTMX as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DTIEN0: u32 = unsafe { ::core::mem::transmute(DTIEN0) };
            DTIEN0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let DTIEN1: u32 = unsafe { ::core::mem::transmute(DTIEN1) };
            DTIEN1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let DTIEN2: u32 = unsafe { ::core::mem::transmute(DTIEN2) };
            DTIEN2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DTIEN3: u32 = unsafe { ::core::mem::transmute(DTIEN3) };
            DTIEN3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let DTLS: u32 = unsafe { ::core::mem::transmute(DTLS) };
            DTLS as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let DTHS: u32 = unsafe { ::core::mem::transmute(DTHS) };
            DTHS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_WEXCTRL_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_WEXCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WEXCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WEXCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WEXCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WEXCTRL_Type__bindgen_ty_2))
    );
}
impl TCC_WEXCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn DTIEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_DTIEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DTIEN: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let DTIEN: u32 = unsafe { ::core::mem::transmute(DTIEN) };
            DTIEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_WEXCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_WEXCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_WEXCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WEXCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WEXCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WEXCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WEXCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WEXCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WEXCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_DRVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_DRVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_DRVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_DRVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_DRVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_DRVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_DRVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_DRVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_DRVCTRL_Type__bindgen_ty_1))
    );
}
impl TCC_DRVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn NRE0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRE7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRE7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NRV7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN4(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN4(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN5(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN5(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN6(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN6(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN7(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN7(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTERVAL0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FILTERVAL0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn FILTERVAL1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FILTERVAL1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NRE0: u32,
        NRE1: u32,
        NRE2: u32,
        NRE3: u32,
        NRE4: u32,
        NRE5: u32,
        NRE6: u32,
        NRE7: u32,
        NRV0: u32,
        NRV1: u32,
        NRV2: u32,
        NRV3: u32,
        NRV4: u32,
        NRV5: u32,
        NRV6: u32,
        NRV7: u32,
        INVEN0: u32,
        INVEN1: u32,
        INVEN2: u32,
        INVEN3: u32,
        INVEN4: u32,
        INVEN5: u32,
        INVEN6: u32,
        INVEN7: u32,
        FILTERVAL0: u32,
        FILTERVAL1: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NRE0: u32 = unsafe { ::core::mem::transmute(NRE0) };
            NRE0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NRE1: u32 = unsafe { ::core::mem::transmute(NRE1) };
            NRE1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let NRE2: u32 = unsafe { ::core::mem::transmute(NRE2) };
            NRE2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let NRE3: u32 = unsafe { ::core::mem::transmute(NRE3) };
            NRE3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NRE4: u32 = unsafe { ::core::mem::transmute(NRE4) };
            NRE4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let NRE5: u32 = unsafe { ::core::mem::transmute(NRE5) };
            NRE5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let NRE6: u32 = unsafe { ::core::mem::transmute(NRE6) };
            NRE6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let NRE7: u32 = unsafe { ::core::mem::transmute(NRE7) };
            NRE7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let NRV0: u32 = unsafe { ::core::mem::transmute(NRV0) };
            NRV0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let NRV1: u32 = unsafe { ::core::mem::transmute(NRV1) };
            NRV1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let NRV2: u32 = unsafe { ::core::mem::transmute(NRV2) };
            NRV2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let NRV3: u32 = unsafe { ::core::mem::transmute(NRV3) };
            NRV3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let NRV4: u32 = unsafe { ::core::mem::transmute(NRV4) };
            NRV4 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let NRV5: u32 = unsafe { ::core::mem::transmute(NRV5) };
            NRV5 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let NRV6: u32 = unsafe { ::core::mem::transmute(NRV6) };
            NRV6 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let NRV7: u32 = unsafe { ::core::mem::transmute(NRV7) };
            NRV7 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let INVEN0: u32 = unsafe { ::core::mem::transmute(INVEN0) };
            INVEN0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let INVEN1: u32 = unsafe { ::core::mem::transmute(INVEN1) };
            INVEN1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let INVEN2: u32 = unsafe { ::core::mem::transmute(INVEN2) };
            INVEN2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let INVEN3: u32 = unsafe { ::core::mem::transmute(INVEN3) };
            INVEN3 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let INVEN4: u32 = unsafe { ::core::mem::transmute(INVEN4) };
            INVEN4 as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let INVEN5: u32 = unsafe { ::core::mem::transmute(INVEN5) };
            INVEN5 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let INVEN6: u32 = unsafe { ::core::mem::transmute(INVEN6) };
            INVEN6 as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let INVEN7: u32 = unsafe { ::core::mem::transmute(INVEN7) };
            INVEN7 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let FILTERVAL0: u32 = unsafe { ::core::mem::transmute(FILTERVAL0) };
            FILTERVAL0 as u64
        });
        __bindgen_bitfield_unit.set(28usize, 4u8, {
            let FILTERVAL1: u32 = unsafe { ::core::mem::transmute(FILTERVAL1) };
            FILTERVAL1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_DRVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_DRVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_DRVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_DRVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_DRVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_DRVCTRL_Type__bindgen_ty_2))
    );
}
impl TCC_DRVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn NRE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_NRE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn NRV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_NRV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn INVEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_INVEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(NRE: u32, NRV: u32, INVEN: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let NRE: u32 = unsafe { ::core::mem::transmute(NRE) };
            NRE as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let NRV: u32 = unsafe { ::core::mem::transmute(NRV) };
            NRV as u64
        });
        __bindgen_bitfield_unit.set(16usize, 8u8, {
            let INVEN: u32 = unsafe { ::core::mem::transmute(INVEN) };
            INVEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_DRVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_DRVCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_DRVCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_DRVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_DRVCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_DRVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_DRVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_DRVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_DRVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_DBGCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_DBGCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TCC_DBGCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TCC_DBGCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TCC_DBGCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_DBGCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TCC_DBGCTRL_Type__bindgen_ty_1))
    );
}
impl TCC_DBGCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DBGRUN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DBGRUN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FDDBD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_FDDBD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DBGRUN: u8, FDDBD: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DBGRUN: u8 = unsafe { ::core::mem::transmute(DBGRUN) };
            DBGRUN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let FDDBD: u8 = unsafe { ::core::mem::transmute(FDDBD) };
            FDDBD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_DBGCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_DBGCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_DBGCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TCC_DBGCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_DBGCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TCC_DBGCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_DBGCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_DBGCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_EVCTRL_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_EVCTRL_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_EVCTRL_Type__bindgen_ty_1))
    );
}
impl TCC_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn EVACT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_EVACT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn EVACT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_EVACT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn CNTSEL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CNTSEL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn OVFEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVFEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRGEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TRGEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CNTEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CNTEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCINV0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCINV0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCINV1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCINV1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCEI0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCEI0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TCEI1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TCEI1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEI0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEI0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEI1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEI1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEI2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEI2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEI3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEI3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEO0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEO1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEO2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MCEO3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EVACT0: u32,
        EVACT1: u32,
        CNTSEL: u32,
        OVFEO: u32,
        TRGEO: u32,
        CNTEO: u32,
        TCINV0: u32,
        TCINV1: u32,
        TCEI0: u32,
        TCEI1: u32,
        MCEI0: u32,
        MCEI1: u32,
        MCEI2: u32,
        MCEI3: u32,
        MCEO0: u32,
        MCEO1: u32,
        MCEO2: u32,
        MCEO3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let EVACT0: u32 = unsafe { ::core::mem::transmute(EVACT0) };
            EVACT0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 3u8, {
            let EVACT1: u32 = unsafe { ::core::mem::transmute(EVACT1) };
            EVACT1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let CNTSEL: u32 = unsafe { ::core::mem::transmute(CNTSEL) };
            CNTSEL as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let OVFEO: u32 = unsafe { ::core::mem::transmute(OVFEO) };
            OVFEO as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let TRGEO: u32 = unsafe { ::core::mem::transmute(TRGEO) };
            TRGEO as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CNTEO: u32 = unsafe { ::core::mem::transmute(CNTEO) };
            CNTEO as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let TCINV0: u32 = unsafe { ::core::mem::transmute(TCINV0) };
            TCINV0 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let TCINV1: u32 = unsafe { ::core::mem::transmute(TCINV1) };
            TCINV1 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let TCEI0: u32 = unsafe { ::core::mem::transmute(TCEI0) };
            TCEI0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let TCEI1: u32 = unsafe { ::core::mem::transmute(TCEI1) };
            TCEI1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MCEI0: u32 = unsafe { ::core::mem::transmute(MCEI0) };
            MCEI0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MCEI1: u32 = unsafe { ::core::mem::transmute(MCEI1) };
            MCEI1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MCEI2: u32 = unsafe { ::core::mem::transmute(MCEI2) };
            MCEI2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let MCEI3: u32 = unsafe { ::core::mem::transmute(MCEI3) };
            MCEI3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let MCEO0: u32 = unsafe { ::core::mem::transmute(MCEO0) };
            MCEO0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let MCEO1: u32 = unsafe { ::core::mem::transmute(MCEO1) };
            MCEO1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let MCEO2: u32 = unsafe { ::core::mem::transmute(MCEO2) };
            MCEO2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let MCEO3: u32 = unsafe { ::core::mem::transmute(MCEO3) };
            MCEO3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_EVCTRL_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_EVCTRL_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_EVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_EVCTRL_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_EVCTRL_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_EVCTRL_Type__bindgen_ty_2))
    );
}
impl TCC_EVCTRL_Type__bindgen_ty_2 {
    #[inline]
    pub fn TCINV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TCINV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TCEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_TCEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEI(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MCEI(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn MCEO(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MCEO(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TCINV: u32,
        TCEI: u32,
        MCEI: u32,
        MCEO: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(12usize, 2u8, {
            let TCINV: u32 = unsafe { ::core::mem::transmute(TCINV) };
            TCINV as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let TCEI: u32 = unsafe { ::core::mem::transmute(TCEI) };
            TCEI as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let MCEI: u32 = unsafe { ::core::mem::transmute(MCEI) };
            MCEI as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let MCEO: u32 = unsafe { ::core::mem::transmute(MCEO) };
            MCEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_EVCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_EVCTRL_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_EVCTRL_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_EVCTRL_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_INTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTENCLR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTENCLR_Type__bindgen_ty_1))
    );
}
impl TCC_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TRG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UFS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UFS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVF: u32,
        TRG: u32,
        CNT: u32,
        ERR: u32,
        UFS: u32,
        DFS: u32,
        FAULTA: u32,
        FAULTB: u32,
        FAULT0: u32,
        FAULT1: u32,
        MC0: u32,
        MC1: u32,
        MC2: u32,
        MC3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVF: u32 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRG: u32 = unsafe { ::core::mem::transmute(TRG) };
            TRG as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CNT: u32 = unsafe { ::core::mem::transmute(CNT) };
            CNT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ERR: u32 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let UFS: u32 = unsafe { ::core::mem::transmute(UFS) };
            UFS as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DFS: u32 = unsafe { ::core::mem::transmute(DFS) };
            DFS as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let FAULTA: u32 = unsafe { ::core::mem::transmute(FAULTA) };
            FAULTA as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FAULTB: u32 = unsafe { ::core::mem::transmute(FAULTB) };
            FAULTB as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FAULT0: u32 = unsafe { ::core::mem::transmute(FAULT0) };
            FAULT0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FAULT1: u32 = unsafe { ::core::mem::transmute(FAULT1) };
            FAULT1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MC0: u32 = unsafe { ::core::mem::transmute(MC0) };
            MC0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MC1: u32 = unsafe { ::core::mem::transmute(MC1) };
            MC1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MC2: u32 = unsafe { ::core::mem::transmute(MC2) };
            MC2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let MC3: u32 = unsafe { ::core::mem::transmute(MC3) };
            MC3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_INTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_INTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTENCLR_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTENCLR_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTENCLR_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTENCLR_Type__bindgen_ty_2))
    );
}
impl TCC_INTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn MC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let MC: u32 = unsafe { ::core::mem::transmute(MC) };
            MC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_INTENCLR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTENCLR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_INTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTENSET_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTENSET_Type__bindgen_ty_1))
    );
}
impl TCC_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TRG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UFS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UFS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVF: u32,
        TRG: u32,
        CNT: u32,
        ERR: u32,
        UFS: u32,
        DFS: u32,
        FAULTA: u32,
        FAULTB: u32,
        FAULT0: u32,
        FAULT1: u32,
        MC0: u32,
        MC1: u32,
        MC2: u32,
        MC3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVF: u32 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRG: u32 = unsafe { ::core::mem::transmute(TRG) };
            TRG as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CNT: u32 = unsafe { ::core::mem::transmute(CNT) };
            CNT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ERR: u32 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let UFS: u32 = unsafe { ::core::mem::transmute(UFS) };
            UFS as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DFS: u32 = unsafe { ::core::mem::transmute(DFS) };
            DFS as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let FAULTA: u32 = unsafe { ::core::mem::transmute(FAULTA) };
            FAULTA as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FAULTB: u32 = unsafe { ::core::mem::transmute(FAULTB) };
            FAULTB as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FAULT0: u32 = unsafe { ::core::mem::transmute(FAULT0) };
            FAULT0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FAULT1: u32 = unsafe { ::core::mem::transmute(FAULT1) };
            FAULT1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MC0: u32 = unsafe { ::core::mem::transmute(MC0) };
            MC0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MC1: u32 = unsafe { ::core::mem::transmute(MC1) };
            MC1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MC2: u32 = unsafe { ::core::mem::transmute(MC2) };
            MC2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let MC3: u32 = unsafe { ::core::mem::transmute(MC3) };
            MC3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_INTENSET_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_INTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTENSET_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTENSET_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTENSET_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTENSET_Type__bindgen_ty_2))
    );
}
impl TCC_INTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn MC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let MC: u32 = unsafe { ::core::mem::transmute(MC) };
            MC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_INTENSET_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTENSET_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_INTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTFLAG_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTFLAG_Type__bindgen_ty_1))
    );
}
impl TCC_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn OVF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OVF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRG(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_TRG(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ERR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UFS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UFS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MC3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MC3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OVF: u32,
        TRG: u32,
        CNT: u32,
        ERR: u32,
        UFS: u32,
        DFS: u32,
        FAULTA: u32,
        FAULTB: u32,
        FAULT0: u32,
        FAULT1: u32,
        MC0: u32,
        MC1: u32,
        MC2: u32,
        MC3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OVF: u32 = unsafe { ::core::mem::transmute(OVF) };
            OVF as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRG: u32 = unsafe { ::core::mem::transmute(TRG) };
            TRG as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CNT: u32 = unsafe { ::core::mem::transmute(CNT) };
            CNT as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ERR: u32 = unsafe { ::core::mem::transmute(ERR) };
            ERR as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let UFS: u32 = unsafe { ::core::mem::transmute(UFS) };
            UFS as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let DFS: u32 = unsafe { ::core::mem::transmute(DFS) };
            DFS as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let FAULTA: u32 = unsafe { ::core::mem::transmute(FAULTA) };
            FAULTA as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FAULTB: u32 = unsafe { ::core::mem::transmute(FAULTB) };
            FAULTB as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FAULT0: u32 = unsafe { ::core::mem::transmute(FAULT0) };
            FAULT0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FAULT1: u32 = unsafe { ::core::mem::transmute(FAULT1) };
            FAULT1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let MC0: u32 = unsafe { ::core::mem::transmute(MC0) };
            MC0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let MC1: u32 = unsafe { ::core::mem::transmute(MC1) };
            MC1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let MC2: u32 = unsafe { ::core::mem::transmute(MC2) };
            MC2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let MC3: u32 = unsafe { ::core::mem::transmute(MC3) };
            MC3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_INTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_INTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_INTFLAG_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTFLAG_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTFLAG_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTFLAG_Type__bindgen_ty_2))
    );
}
impl TCC_INTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn MC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_MC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(MC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let MC: u32 = unsafe { ::core::mem::transmute(MC) };
            MC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_INTFLAG_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_INTFLAG_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_STATUS_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_STATUS_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_STATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_STATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_STATUS_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_STATUS_Type__bindgen_ty_1))
    );
}
impl TCC_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn STOP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_STOP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IDX(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IDX(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UFS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UFS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DFS(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DFS(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SLAVE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SLAVE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PATTBUFV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PATTBUFV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PERBUFV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PERBUFV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTAIN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTAIN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTBIN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTBIN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT0IN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT0IN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT1IN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT1IN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULTB(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULTB(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FAULT1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FAULT1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCBUFV0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCBUFV0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCBUFV1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCBUFV1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCBUFV2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCBUFV2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CCBUFV3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CCBUFV3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMP0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMP1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMP2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CMP3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        STOP: u32,
        IDX: u32,
        UFS: u32,
        DFS: u32,
        SLAVE: u32,
        PATTBUFV: u32,
        PERBUFV: u32,
        FAULTAIN: u32,
        FAULTBIN: u32,
        FAULT0IN: u32,
        FAULT1IN: u32,
        FAULTA: u32,
        FAULTB: u32,
        FAULT0: u32,
        FAULT1: u32,
        CCBUFV0: u32,
        CCBUFV1: u32,
        CCBUFV2: u32,
        CCBUFV3: u32,
        CMP0: u32,
        CMP1: u32,
        CMP2: u32,
        CMP3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let STOP: u32 = unsafe { ::core::mem::transmute(STOP) };
            STOP as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IDX: u32 = unsafe { ::core::mem::transmute(IDX) };
            IDX as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UFS: u32 = unsafe { ::core::mem::transmute(UFS) };
            UFS as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DFS: u32 = unsafe { ::core::mem::transmute(DFS) };
            DFS as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SLAVE: u32 = unsafe { ::core::mem::transmute(SLAVE) };
            SLAVE as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PATTBUFV: u32 = unsafe { ::core::mem::transmute(PATTBUFV) };
            PATTBUFV as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PERBUFV: u32 = unsafe { ::core::mem::transmute(PERBUFV) };
            PERBUFV as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let FAULTAIN: u32 = unsafe { ::core::mem::transmute(FAULTAIN) };
            FAULTAIN as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let FAULTBIN: u32 = unsafe { ::core::mem::transmute(FAULTBIN) };
            FAULTBIN as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let FAULT0IN: u32 = unsafe { ::core::mem::transmute(FAULT0IN) };
            FAULT0IN as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let FAULT1IN: u32 = unsafe { ::core::mem::transmute(FAULT1IN) };
            FAULT1IN as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let FAULTA: u32 = unsafe { ::core::mem::transmute(FAULTA) };
            FAULTA as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let FAULTB: u32 = unsafe { ::core::mem::transmute(FAULTB) };
            FAULTB as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FAULT0: u32 = unsafe { ::core::mem::transmute(FAULT0) };
            FAULT0 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FAULT1: u32 = unsafe { ::core::mem::transmute(FAULT1) };
            FAULT1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let CCBUFV0: u32 = unsafe { ::core::mem::transmute(CCBUFV0) };
            CCBUFV0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let CCBUFV1: u32 = unsafe { ::core::mem::transmute(CCBUFV1) };
            CCBUFV1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let CCBUFV2: u32 = unsafe { ::core::mem::transmute(CCBUFV2) };
            CCBUFV2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let CCBUFV3: u32 = unsafe { ::core::mem::transmute(CCBUFV3) };
            CCBUFV3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let CMP0: u32 = unsafe { ::core::mem::transmute(CMP0) };
            CMP0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let CMP1: u32 = unsafe { ::core::mem::transmute(CMP1) };
            CMP1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let CMP2: u32 = unsafe { ::core::mem::transmute(CMP2) };
            CMP2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let CMP3: u32 = unsafe { ::core::mem::transmute(CMP3) };
            CMP3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_STATUS_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_STATUS_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_STATUS_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_STATUS_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_STATUS_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_STATUS_Type__bindgen_ty_2))
    );
}
impl TCC_STATUS_Type__bindgen_ty_2 {
    #[inline]
    pub fn CCBUFV(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CCBUFV(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CMP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CMP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CCBUFV: u32, CMP: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let CCBUFV: u32 = unsafe { ::core::mem::transmute(CCBUFV) };
            CCBUFV as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let CMP: u32 = unsafe { ::core::mem::transmute(CMP) };
            CMP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_STATUS_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_STATUS_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_STATUS_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_STATUS_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_COUNT_Type {
    #[doc = "< Structure used for DITH4"]
    pub DITH4: TCC_COUNT_Type__bindgen_ty_1,
    #[doc = "< Structure used for DITH5"]
    pub DITH5: TCC_COUNT_Type__bindgen_ty_2,
    #[doc = "< Structure used for DITH6"]
    pub DITH6: TCC_COUNT_Type__bindgen_ty_3,
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_COUNT_Type__bindgen_ty_4,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_COUNT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_COUNT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_COUNT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_COUNT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_COUNT_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_COUNT_Type__bindgen_ty_1))
    );
}
impl TCC_COUNT_Type__bindgen_ty_1 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_COUNT_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_COUNT_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_COUNT_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_COUNT_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_COUNT_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_COUNT_Type__bindgen_ty_2))
    );
}
impl TCC_COUNT_Type__bindgen_ty_2 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(5usize, 19u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_COUNT_Type__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_COUNT_Type__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<TCC_COUNT_Type__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_COUNT_Type__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_COUNT_Type__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_COUNT_Type__bindgen_ty_3))
    );
}
impl TCC_COUNT_Type__bindgen_ty_3 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(6usize, 18u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_COUNT_Type__bindgen_ty_4 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_COUNT_Type__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<TCC_COUNT_Type__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_COUNT_Type__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_COUNT_Type__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_COUNT_Type__bindgen_ty_4))
    );
}
impl TCC_COUNT_Type__bindgen_ty_4 {
    #[inline]
    pub fn COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(COUNT: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let COUNT: u32 = unsafe { ::core::mem::transmute(COUNT) };
            COUNT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_COUNT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_COUNT_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_COUNT_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_COUNT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_COUNT_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_COUNT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_COUNT_Type),
            "::",
            stringify!(DITH4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH5) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_COUNT_Type),
            "::",
            stringify!(DITH5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_COUNT_Type),
            "::",
            stringify!(DITH6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_COUNT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_COUNT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_PATT_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_PATT_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_PATT_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PATT_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_TCC_PATT_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PATT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TCC_PATT_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PATT_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TCC_PATT_Type__bindgen_ty_1))
    );
}
impl TCC_PATT_Type__bindgen_ty_1 {
    #[inline]
    pub fn PGE0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGE7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGE7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGV7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PGE0: u16,
        PGE1: u16,
        PGE2: u16,
        PGE3: u16,
        PGE4: u16,
        PGE5: u16,
        PGE6: u16,
        PGE7: u16,
        PGV0: u16,
        PGV1: u16,
        PGV2: u16,
        PGV3: u16,
        PGV4: u16,
        PGV5: u16,
        PGV6: u16,
        PGV7: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PGE0: u16 = unsafe { ::core::mem::transmute(PGE0) };
            PGE0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PGE1: u16 = unsafe { ::core::mem::transmute(PGE1) };
            PGE1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PGE2: u16 = unsafe { ::core::mem::transmute(PGE2) };
            PGE2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PGE3: u16 = unsafe { ::core::mem::transmute(PGE3) };
            PGE3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PGE4: u16 = unsafe { ::core::mem::transmute(PGE4) };
            PGE4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PGE5: u16 = unsafe { ::core::mem::transmute(PGE5) };
            PGE5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PGE6: u16 = unsafe { ::core::mem::transmute(PGE6) };
            PGE6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PGE7: u16 = unsafe { ::core::mem::transmute(PGE7) };
            PGE7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let PGV0: u16 = unsafe { ::core::mem::transmute(PGV0) };
            PGV0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let PGV1: u16 = unsafe { ::core::mem::transmute(PGV1) };
            PGV1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PGV2: u16 = unsafe { ::core::mem::transmute(PGV2) };
            PGV2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PGV3: u16 = unsafe { ::core::mem::transmute(PGV3) };
            PGV3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PGV4: u16 = unsafe { ::core::mem::transmute(PGV4) };
            PGV4 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PGV5: u16 = unsafe { ::core::mem::transmute(PGV5) };
            PGV5 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let PGV6: u16 = unsafe { ::core::mem::transmute(PGV6) };
            PGV6 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PGV7: u16 = unsafe { ::core::mem::transmute(PGV7) };
            PGV7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PATT_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_TCC_PATT_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PATT_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(TCC_PATT_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PATT_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(TCC_PATT_Type__bindgen_ty_2))
    );
}
impl TCC_PATT_Type__bindgen_ty_2 {
    #[inline]
    pub fn PGE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PGE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn PGV(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PGV(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PGE: u16, PGV: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PGE: u16 = unsafe { ::core::mem::transmute(PGE) };
            PGE as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let PGV: u16 = unsafe { ::core::mem::transmute(PGV) };
            PGV as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_PATT_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_PATT_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_PATT_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TCC_PATT_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PATT_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TCC_PATT_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PATT_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PATT_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PATT_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_WAVE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_WAVE_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_WAVE_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_WAVE_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_WAVE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WAVE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WAVE_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WAVE_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WAVE_Type__bindgen_ty_1))
    );
}
impl TCC_WAVE_Type__bindgen_ty_1 {
    #[inline]
    pub fn WAVEGEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_WAVEGEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_RAMP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn CIPEREN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CIPEREN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CICCEN0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CICCEN0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CICCEN1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CICCEN1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CICCEN2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CICCEN2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CICCEN3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CICCEN3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POL0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_POL0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POL1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_POL1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POL2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_POL2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn POL3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_POL3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAP0(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAP0(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAP1(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAP1(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAP2(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAP2(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAP3(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SWAP3(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WAVEGEN: u32,
        RAMP: u32,
        CIPEREN: u32,
        CICCEN0: u32,
        CICCEN1: u32,
        CICCEN2: u32,
        CICCEN3: u32,
        POL0: u32,
        POL1: u32,
        POL2: u32,
        POL3: u32,
        SWAP0: u32,
        SWAP1: u32,
        SWAP2: u32,
        SWAP3: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let WAVEGEN: u32 = unsafe { ::core::mem::transmute(WAVEGEN) };
            WAVEGEN as u64
        });
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let RAMP: u32 = unsafe { ::core::mem::transmute(RAMP) };
            RAMP as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let CIPEREN: u32 = unsafe { ::core::mem::transmute(CIPEREN) };
            CIPEREN as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let CICCEN0: u32 = unsafe { ::core::mem::transmute(CICCEN0) };
            CICCEN0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let CICCEN1: u32 = unsafe { ::core::mem::transmute(CICCEN1) };
            CICCEN1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let CICCEN2: u32 = unsafe { ::core::mem::transmute(CICCEN2) };
            CICCEN2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let CICCEN3: u32 = unsafe { ::core::mem::transmute(CICCEN3) };
            CICCEN3 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let POL0: u32 = unsafe { ::core::mem::transmute(POL0) };
            POL0 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let POL1: u32 = unsafe { ::core::mem::transmute(POL1) };
            POL1 as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let POL2: u32 = unsafe { ::core::mem::transmute(POL2) };
            POL2 as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let POL3: u32 = unsafe { ::core::mem::transmute(POL3) };
            POL3 as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let SWAP0: u32 = unsafe { ::core::mem::transmute(SWAP0) };
            SWAP0 as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let SWAP1: u32 = unsafe { ::core::mem::transmute(SWAP1) };
            SWAP1 as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let SWAP2: u32 = unsafe { ::core::mem::transmute(SWAP2) };
            SWAP2 as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let SWAP3: u32 = unsafe { ::core::mem::transmute(SWAP3) };
            SWAP3 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_WAVE_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_WAVE_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_WAVE_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WAVE_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WAVE_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WAVE_Type__bindgen_ty_2))
    );
}
impl TCC_WAVE_Type__bindgen_ty_2 {
    #[inline]
    pub fn CICCEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CICCEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn POL(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_POL(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn SWAP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_SWAP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CICCEN: u32, POL: u32, SWAP: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let CICCEN: u32 = unsafe { ::core::mem::transmute(CICCEN) };
            CICCEN as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let POL: u32 = unsafe { ::core::mem::transmute(POL) };
            POL as u64
        });
        __bindgen_bitfield_unit.set(24usize, 4u8, {
            let SWAP: u32 = unsafe { ::core::mem::transmute(SWAP) };
            SWAP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_WAVE_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_WAVE_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_WAVE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_WAVE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_WAVE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_WAVE_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WAVE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WAVE_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_WAVE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_PER_Type {
    #[doc = "< Structure used for DITH4"]
    pub DITH4: TCC_PER_Type__bindgen_ty_1,
    #[doc = "< Structure used for DITH5"]
    pub DITH5: TCC_PER_Type__bindgen_ty_2,
    #[doc = "< Structure used for DITH6"]
    pub DITH6: TCC_PER_Type__bindgen_ty_3,
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_PER_Type__bindgen_ty_4,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PER_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_PER_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PER_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PER_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PER_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PER_Type__bindgen_ty_1))
    );
}
impl TCC_PER_Type__bindgen_ty_1 {
    #[inline]
    pub fn DITHER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_DITHER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn PER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHER: u32, PER: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let DITHER: u32 = unsafe { ::core::mem::transmute(DITHER) };
            DITHER as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let PER: u32 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PER_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_PER_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PER_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PER_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PER_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PER_Type__bindgen_ty_2))
    );
}
impl TCC_PER_Type__bindgen_ty_2 {
    #[inline]
    pub fn DITHER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DITHER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn PER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHER: u32, PER: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DITHER: u32 = unsafe { ::core::mem::transmute(DITHER) };
            DITHER as u64
        });
        __bindgen_bitfield_unit.set(5usize, 19u8, {
            let PER: u32 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PER_Type__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_PER_Type__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PER_Type__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PER_Type__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PER_Type__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PER_Type__bindgen_ty_3))
    );
}
impl TCC_PER_Type__bindgen_ty_3 {
    #[inline]
    pub fn DITHER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_DITHER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn PER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHER: u32, PER: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let DITHER: u32 = unsafe { ::core::mem::transmute(DITHER) };
            DITHER as u64
        });
        __bindgen_bitfield_unit.set(6usize, 18u8, {
            let PER: u32 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PER_Type__bindgen_ty_4 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_PER_Type__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PER_Type__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PER_Type__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PER_Type__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PER_Type__bindgen_ty_4))
    );
}
impl TCC_PER_Type__bindgen_ty_4 {
    #[inline]
    pub fn PER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let PER: u32 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_PER_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_PER_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_PER_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PER_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PER_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PER_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PER_Type),
            "::",
            stringify!(DITH4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH5) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PER_Type),
            "::",
            stringify!(DITH5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PER_Type),
            "::",
            stringify!(DITH6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PER_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PER_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_CC_Type {
    #[doc = "< Structure used for DITH4"]
    pub DITH4: TCC_CC_Type__bindgen_ty_1,
    #[doc = "< Structure used for DITH5"]
    pub DITH5: TCC_CC_Type__bindgen_ty_2,
    #[doc = "< Structure used for DITH6"]
    pub DITH6: TCC_CC_Type__bindgen_ty_3,
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_CC_Type__bindgen_ty_4,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CC_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_CC_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CC_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CC_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CC_Type__bindgen_ty_1))
    );
}
impl TCC_CC_Type__bindgen_ty_1 {
    #[inline]
    pub fn DITHER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_DITHER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHER: u32, CC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let DITHER: u32 = unsafe { ::core::mem::transmute(DITHER) };
            DITHER as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CC_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_CC_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CC_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CC_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CC_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CC_Type__bindgen_ty_2))
    );
}
impl TCC_CC_Type__bindgen_ty_2 {
    #[inline]
    pub fn DITHER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DITHER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHER: u32, CC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DITHER: u32 = unsafe { ::core::mem::transmute(DITHER) };
            DITHER as u64
        });
        __bindgen_bitfield_unit.set(5usize, 19u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CC_Type__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_CC_Type__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CC_Type__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CC_Type__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CC_Type__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CC_Type__bindgen_ty_3))
    );
}
impl TCC_CC_Type__bindgen_ty_3 {
    #[inline]
    pub fn DITHER(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_DITHER(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHER: u32, CC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let DITHER: u32 = unsafe { ::core::mem::transmute(DITHER) };
            DITHER as u64
        });
        __bindgen_bitfield_unit.set(6usize, 18u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CC_Type__bindgen_ty_4 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_CC_Type__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CC_Type__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CC_Type__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CC_Type__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CC_Type__bindgen_ty_4))
    );
}
impl TCC_CC_Type__bindgen_ty_4 {
    #[inline]
    pub fn CC(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_CC(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CC: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let CC: u32 = unsafe { ::core::mem::transmute(CC) };
            CC as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_CC_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_CC_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_CC_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CC_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CC_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CC_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CC_Type),
            "::",
            stringify!(DITH4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH5) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CC_Type),
            "::",
            stringify!(DITH5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CC_Type),
            "::",
            stringify!(DITH6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CC_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CC_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_PATTBUF_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_PATTBUF_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: TCC_PATTBUF_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PATTBUF_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_TCC_PATTBUF_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PATTBUF_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(TCC_PATTBUF_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PATTBUF_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(TCC_PATTBUF_Type__bindgen_ty_1))
    );
}
impl TCC_PATTBUF_Type__bindgen_ty_1 {
    #[inline]
    pub fn PGEB0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGEB7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PGEB0: u16,
        PGEB1: u16,
        PGEB2: u16,
        PGEB3: u16,
        PGEB4: u16,
        PGEB5: u16,
        PGEB6: u16,
        PGEB7: u16,
        PGVB0: u16,
        PGVB1: u16,
        PGVB2: u16,
        PGVB3: u16,
        PGVB4: u16,
        PGVB5: u16,
        PGVB6: u16,
        PGVB7: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PGEB0: u16 = unsafe { ::core::mem::transmute(PGEB0) };
            PGEB0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PGEB1: u16 = unsafe { ::core::mem::transmute(PGEB1) };
            PGEB1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PGEB2: u16 = unsafe { ::core::mem::transmute(PGEB2) };
            PGEB2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PGEB3: u16 = unsafe { ::core::mem::transmute(PGEB3) };
            PGEB3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PGEB4: u16 = unsafe { ::core::mem::transmute(PGEB4) };
            PGEB4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PGEB5: u16 = unsafe { ::core::mem::transmute(PGEB5) };
            PGEB5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PGEB6: u16 = unsafe { ::core::mem::transmute(PGEB6) };
            PGEB6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PGEB7: u16 = unsafe { ::core::mem::transmute(PGEB7) };
            PGEB7 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let PGVB0: u16 = unsafe { ::core::mem::transmute(PGVB0) };
            PGVB0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let PGVB1: u16 = unsafe { ::core::mem::transmute(PGVB1) };
            PGVB1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PGVB2: u16 = unsafe { ::core::mem::transmute(PGVB2) };
            PGVB2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PGVB3: u16 = unsafe { ::core::mem::transmute(PGVB3) };
            PGVB3 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let PGVB4: u16 = unsafe { ::core::mem::transmute(PGVB4) };
            PGVB4 as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PGVB5: u16 = unsafe { ::core::mem::transmute(PGVB5) };
            PGVB5 as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let PGVB6: u16 = unsafe { ::core::mem::transmute(PGVB6) };
            PGVB6 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let PGVB7: u16 = unsafe { ::core::mem::transmute(PGVB7) };
            PGVB7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PATTBUF_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_TCC_PATTBUF_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PATTBUF_Type__bindgen_ty_2>(),
        2usize,
        concat!("Size of: ", stringify!(TCC_PATTBUF_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PATTBUF_Type__bindgen_ty_2>(),
        2usize,
        concat!("Alignment of ", stringify!(TCC_PATTBUF_Type__bindgen_ty_2))
    );
}
impl TCC_PATTBUF_Type__bindgen_ty_2 {
    #[inline]
    pub fn PGEB(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PGEB(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn PGVB(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_PGVB(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PGEB: u16, PGVB: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PGEB: u16 = unsafe { ::core::mem::transmute(PGEB) };
            PGEB as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let PGVB: u16 = unsafe { ::core::mem::transmute(PGVB) };
            PGVB as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_PATTBUF_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_PATTBUF_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_PATTBUF_Type>(),
        2usize,
        concat!("Size of: ", stringify!(TCC_PATTBUF_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PATTBUF_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(TCC_PATTBUF_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PATTBUF_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PATTBUF_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PATTBUF_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_PERBUF_Type {
    #[doc = "< Structure used for DITH4"]
    pub DITH4: TCC_PERBUF_Type__bindgen_ty_1,
    #[doc = "< Structure used for DITH5"]
    pub DITH5: TCC_PERBUF_Type__bindgen_ty_2,
    #[doc = "< Structure used for DITH6"]
    pub DITH6: TCC_PERBUF_Type__bindgen_ty_3,
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_PERBUF_Type__bindgen_ty_4,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PERBUF_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_PERBUF_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PERBUF_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PERBUF_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PERBUF_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PERBUF_Type__bindgen_ty_1))
    );
}
impl TCC_PERBUF_Type__bindgen_ty_1 {
    #[inline]
    pub fn DITHERBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn PERBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_PERBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERBUF: u32, PERBUF: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let DITHERBUF: u32 = unsafe { ::core::mem::transmute(DITHERBUF) };
            DITHERBUF as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let PERBUF: u32 = unsafe { ::core::mem::transmute(PERBUF) };
            PERBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PERBUF_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_PERBUF_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PERBUF_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PERBUF_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PERBUF_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PERBUF_Type__bindgen_ty_2))
    );
}
impl TCC_PERBUF_Type__bindgen_ty_2 {
    #[inline]
    pub fn DITHERBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn PERBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_PERBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERBUF: u32, PERBUF: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DITHERBUF: u32 = unsafe { ::core::mem::transmute(DITHERBUF) };
            DITHERBUF as u64
        });
        __bindgen_bitfield_unit.set(5usize, 19u8, {
            let PERBUF: u32 = unsafe { ::core::mem::transmute(PERBUF) };
            PERBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PERBUF_Type__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_PERBUF_Type__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PERBUF_Type__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PERBUF_Type__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PERBUF_Type__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PERBUF_Type__bindgen_ty_3))
    );
}
impl TCC_PERBUF_Type__bindgen_ty_3 {
    #[inline]
    pub fn DITHERBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn PERBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_PERBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERBUF: u32, PERBUF: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let DITHERBUF: u32 = unsafe { ::core::mem::transmute(DITHERBUF) };
            DITHERBUF as u64
        });
        __bindgen_bitfield_unit.set(6usize, 18u8, {
            let PERBUF: u32 = unsafe { ::core::mem::transmute(PERBUF) };
            PERBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_PERBUF_Type__bindgen_ty_4 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_PERBUF_Type__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<TCC_PERBUF_Type__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PERBUF_Type__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PERBUF_Type__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PERBUF_Type__bindgen_ty_4))
    );
}
impl TCC_PERBUF_Type__bindgen_ty_4 {
    #[inline]
    pub fn PERBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_PERBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PERBUF: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let PERBUF: u32 = unsafe { ::core::mem::transmute(PERBUF) };
            PERBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_PERBUF_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_PERBUF_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_PERBUF_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_PERBUF_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_PERBUF_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_PERBUF_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PERBUF_Type),
            "::",
            stringify!(DITH4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH5) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PERBUF_Type),
            "::",
            stringify!(DITH5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PERBUF_Type),
            "::",
            stringify!(DITH6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PERBUF_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_PERBUF_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TCC_CCBUF_Type {
    #[doc = "< Structure used for DITH4"]
    pub DITH4: TCC_CCBUF_Type__bindgen_ty_1,
    #[doc = "< Structure used for DITH5"]
    pub DITH5: TCC_CCBUF_Type__bindgen_ty_2,
    #[doc = "< Structure used for DITH6"]
    pub DITH6: TCC_CCBUF_Type__bindgen_ty_3,
    #[doc = "< Structure used for bit  access"]
    pub bit: TCC_CCBUF_Type__bindgen_ty_4,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CCBUF_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_CCBUF_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CCBUF_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CCBUF_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CCBUF_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CCBUF_Type__bindgen_ty_1))
    );
}
impl TCC_CCBUF_Type__bindgen_ty_1 {
    #[inline]
    pub fn CCBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_CCBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn DITHERBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CCBUF: u32, DITHERBUF: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let CCBUF: u32 = unsafe { ::core::mem::transmute(CCBUF) };
            CCBUF as u64
        });
        __bindgen_bitfield_unit.set(4usize, 20u8, {
            let DITHERBUF: u32 = unsafe { ::core::mem::transmute(DITHERBUF) };
            DITHERBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CCBUF_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_CCBUF_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CCBUF_Type__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CCBUF_Type__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CCBUF_Type__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CCBUF_Type__bindgen_ty_2))
    );
}
impl TCC_CCBUF_Type__bindgen_ty_2 {
    #[inline]
    pub fn DITHERBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn CCBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_CCBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERBUF: u32, CCBUF: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let DITHERBUF: u32 = unsafe { ::core::mem::transmute(DITHERBUF) };
            DITHERBUF as u64
        });
        __bindgen_bitfield_unit.set(5usize, 19u8, {
            let CCBUF: u32 = unsafe { ::core::mem::transmute(CCBUF) };
            CCBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CCBUF_Type__bindgen_ty_3 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_CCBUF_Type__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CCBUF_Type__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CCBUF_Type__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CCBUF_Type__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CCBUF_Type__bindgen_ty_3))
    );
}
impl TCC_CCBUF_Type__bindgen_ty_3 {
    #[inline]
    pub fn DITHERBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_DITHERBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn CCBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 18u8) as u32) }
    }
    #[inline]
    pub fn set_CCBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 18u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DITHERBUF: u32, CCBUF: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let DITHERBUF: u32 = unsafe { ::core::mem::transmute(DITHERBUF) };
            DITHERBUF as u64
        });
        __bindgen_bitfield_unit.set(6usize, 18u8, {
            let CCBUF: u32 = unsafe { ::core::mem::transmute(CCBUF) };
            CCBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TCC_CCBUF_Type__bindgen_ty_4 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TCC_CCBUF_Type__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<TCC_CCBUF_Type__bindgen_ty_4>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CCBUF_Type__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CCBUF_Type__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CCBUF_Type__bindgen_ty_4))
    );
}
impl TCC_CCBUF_Type__bindgen_ty_4 {
    #[inline]
    pub fn CCBUF(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_CCBUF(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CCBUF: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let CCBUF: u32 = unsafe { ::core::mem::transmute(CCBUF) };
            CCBUF as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TCC_CCBUF_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TCC_CCBUF_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TCC_CCBUF_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TCC_CCBUF_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TCC_CCBUF_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TCC_CCBUF_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CCBUF_Type),
            "::",
            stringify!(DITH4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH5) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CCBUF_Type),
            "::",
            stringify!(DITH5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DITH6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CCBUF_Type),
            "::",
            stringify!(DITH6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CCBUF_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TCC_CCBUF_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Tcc {
    #[doc = "< \\brief Offset: 0x00 (R/W 32) Control A"]
    pub CTRLA: TCC_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Control B Clear"]
    pub CTRLBCLR: TCC_CTRLBCLR_Type,
    #[doc = "< \\brief Offset: 0x05 (R/W  8) Control B Set"]
    pub CTRLBSET: TCC_CTRLBSET_Type,
    pub Reserved1: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x08 (R/  32) Synchronization Busy"]
    pub SYNCBUSY: TCC_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x0C (R/W 32) Recoverable Fault A Configuration"]
    pub FCTRLA: TCC_FCTRLA_Type,
    #[doc = "< \\brief Offset: 0x10 (R/W 32) Recoverable Fault B Configuration"]
    pub FCTRLB: TCC_FCTRLB_Type,
    #[doc = "< \\brief Offset: 0x14 (R/W 32) Waveform Extension Configuration"]
    pub WEXCTRL: TCC_WEXCTRL_Type,
    #[doc = "< \\brief Offset: 0x18 (R/W 32) Driver Control"]
    pub DRVCTRL: TCC_DRVCTRL_Type,
    pub Reserved2: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x1E (R/W  8) Debug Control"]
    pub DBGCTRL: TCC_DBGCTRL_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x20 (R/W 32) Event Control"]
    pub EVCTRL: TCC_EVCTRL_Type,
    #[doc = "< \\brief Offset: 0x24 (R/W 32) Interrupt Enable Clear"]
    pub INTENCLR: TCC_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x28 (R/W 32) Interrupt Enable Set"]
    pub INTENSET: TCC_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x2C (R/W 32) Interrupt Flag Status and Clear"]
    pub INTFLAG: TCC_INTFLAG_Type,
    #[doc = "< \\brief Offset: 0x30 (R/W 32) Status"]
    pub STATUS: TCC_STATUS_Type,
    #[doc = "< \\brief Offset: 0x34 (R/W 32) Count"]
    pub COUNT: TCC_COUNT_Type,
    #[doc = "< \\brief Offset: 0x38 (R/W 16) Pattern"]
    pub PATT: TCC_PATT_Type,
    pub Reserved4: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x3C (R/W 32) Waveform Control"]
    pub WAVE: TCC_WAVE_Type,
    #[doc = "< \\brief Offset: 0x40 (R/W 32) Period"]
    pub PER: TCC_PER_Type,
    #[doc = "< \\brief Offset: 0x44 (R/W 32) Compare and Capture"]
    pub CC: [TCC_CC_Type; 4usize],
    pub Reserved5: [RoReg8; 16usize],
    #[doc = "< \\brief Offset: 0x64 (R/W 16) Pattern Buffer"]
    pub PATTBUF: TCC_PATTBUF_Type,
    pub Reserved6: [RoReg8; 6usize],
    #[doc = "< \\brief Offset: 0x6C (R/W 32) Period Buffer"]
    pub PERBUF: TCC_PERBUF_Type,
    #[doc = "< \\brief Offset: 0x70 (R/W 32) Compare and Capture Buffer"]
    pub CCBUF: [TCC_CCBUF_Type; 4usize],
}
#[test]
fn bindgen_test_layout_Tcc() {
    const UNINIT: ::core::mem::MaybeUninit<Tcc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Tcc>(),
        128usize,
        concat!("Size of: ", stringify!(Tcc))
    );
    assert_eq!(
        ::core::mem::align_of::<Tcc>(),
        4usize,
        concat!("Alignment of ", stringify!(Tcc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLBCLR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(CTRLBCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLBSET) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(CTRLBSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FCTRLA) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(FCTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FCTRLB) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(FCTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WEXCTRL) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(WEXCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DRVCTRL) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(DRVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DBGCTRL) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(DBGCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).COUNT) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(COUNT)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PATT) as usize - ptr as usize },
        56usize,
        concat!("Offset of field: ", stringify!(Tcc), "::", stringify!(PATT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WAVE) as usize - ptr as usize },
        60usize,
        concat!("Offset of field: ", stringify!(Tcc), "::", stringify!(WAVE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PER) as usize - ptr as usize },
        64usize,
        concat!("Offset of field: ", stringify!(Tcc), "::", stringify!(PER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CC) as usize - ptr as usize },
        68usize,
        concat!("Offset of field: ", stringify!(Tcc), "::", stringify!(CC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PATTBUF) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(PATTBUF)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        102usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PERBUF) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(PERBUF)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CCBUF) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Tcc),
            "::",
            stringify!(CCBUF)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TRNG_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TRNG_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TRNG_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TRNG_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TRNG_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TRNG_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TRNG_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TRNG_CTRLA_Type__bindgen_ty_1))
    );
}
impl TRNG_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ENABLE: u8, RUNSTDBY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let RUNSTDBY: u8 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TRNG_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TRNG_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TRNG_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TRNG_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TRNG_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TRNG_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TRNG_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TRNG_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TRNG_EVCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TRNG_EVCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TRNG_EVCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TRNG_EVCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TRNG_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TRNG_EVCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TRNG_EVCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TRNG_EVCTRL_Type__bindgen_ty_1))
    );
}
impl TRNG_EVCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATARDYEO(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DATARDYEO(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATARDYEO: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DATARDYEO: u8 = unsafe { ::core::mem::transmute(DATARDYEO) };
            DATARDYEO as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TRNG_EVCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TRNG_EVCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TRNG_EVCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TRNG_EVCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TRNG_EVCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TRNG_EVCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TRNG_EVCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TRNG_EVCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TRNG_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TRNG_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TRNG_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TRNG_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TRNG_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TRNG_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TRNG_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(TRNG_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl TRNG_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATARDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DATARDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATARDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DATARDY: u8 = unsafe { ::core::mem::transmute(DATARDY) };
            DATARDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TRNG_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TRNG_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TRNG_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TRNG_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TRNG_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TRNG_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TRNG_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TRNG_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TRNG_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TRNG_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TRNG_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TRNG_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TRNG_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TRNG_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TRNG_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(TRNG_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl TRNG_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATARDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DATARDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATARDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DATARDY: u8 = unsafe { ::core::mem::transmute(DATARDY) };
            DATARDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TRNG_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TRNG_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TRNG_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TRNG_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TRNG_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TRNG_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TRNG_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TRNG_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TRNG_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TRNG_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct TRNG_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_TRNG_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TRNG_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(TRNG_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TRNG_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(TRNG_INTFLAG_Type__bindgen_ty_1))
    );
}
impl TRNG_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATARDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DATARDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATARDY: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DATARDY: u8 = unsafe { ::core::mem::transmute(DATARDY) };
            DATARDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TRNG_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TRNG_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TRNG_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(TRNG_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TRNG_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(TRNG_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TRNG_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TRNG_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TRNG_DATA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: TRNG_DATA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct TRNG_DATA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_TRNG_DATA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<TRNG_DATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(TRNG_DATA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<TRNG_DATA_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TRNG_DATA_Type__bindgen_ty_1))
    );
}
impl TRNG_DATA_Type__bindgen_ty_1 {
    #[inline]
    pub fn DATA(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DATA(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DATA: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DATA: u32 = unsafe { ::core::mem::transmute(DATA) };
            DATA as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_TRNG_DATA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<TRNG_DATA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<TRNG_DATA_Type>(),
        4usize,
        concat!("Size of: ", stringify!(TRNG_DATA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<TRNG_DATA_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(TRNG_DATA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TRNG_DATA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TRNG_DATA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Trng {
    #[doc = "< \\brief Offset: 0x00 (R/W  8) Control A"]
    pub CTRLA: TRNG_CTRLA_Type,
    pub Reserved1: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x04 (R/W  8) Event Control"]
    pub EVCTRL: TRNG_EVCTRL_Type,
    pub Reserved2: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x08 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: TRNG_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x09 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: TRNG_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x0A (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: TRNG_INTFLAG_Type,
    pub Reserved3: [RoReg8; 21usize],
    #[doc = "< \\brief Offset: 0x20 (R/  32) Output Data"]
    pub DATA: TRNG_DATA_Type,
}
#[test]
fn bindgen_test_layout_Trng() {
    const UNINIT: ::core::mem::MaybeUninit<Trng> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Trng>(),
        36usize,
        concat!("Size of: ", stringify!(Trng))
    );
    assert_eq!(
        ::core::mem::align_of::<Trng>(),
        4usize,
        concat!("Alignment of ", stringify!(Trng))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Trng),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Trng),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EVCTRL) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Trng),
            "::",
            stringify!(EVCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Trng),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Trng),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(Trng),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(Trng),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(Trng),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DATA) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Trng),
            "::",
            stringify!(DATA)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_CTRLA_Type__bindgen_ty_1))
    );
}
impl USB_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RUNSTDBY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RUNSTDBY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MODE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_MODE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SWRST: u8,
        ENABLE: u8,
        RUNSTDBY: u8,
        MODE: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RUNSTDBY: u8 = unsafe { ::core::mem::transmute(RUNSTDBY) };
            RUNSTDBY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let MODE: u8 = unsafe { ::core::mem::transmute(MODE) };
            MODE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_SYNCBUSY_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_SYNCBUSY_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_SYNCBUSY_Type__bindgen_ty_1))
    );
}
impl USB_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn SWRST(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SWRST(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SWRST: u8, ENABLE: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SWRST: u8 = unsafe { ::core::mem::transmute(SWRST) };
            SWRST as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_SYNCBUSY_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_SYNCBUSY_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_SYNCBUSY_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_QOSCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_QOSCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_QOSCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_QOSCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_QOSCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_QOSCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_QOSCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_QOSCTRL_Type__bindgen_ty_1))
    );
}
impl USB_QOSCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn CQOS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_CQOS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DQOS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_DQOS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CQOS: u8, DQOS: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let CQOS: u8 = unsafe { ::core::mem::transmute(CQOS) };
            CQOS as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let DQOS: u8 = unsafe { ::core::mem::transmute(DQOS) };
            DQOS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_QOSCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_QOSCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_QOSCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_QOSCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_QOSCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_QOSCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_QOSCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_QOSCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_CTRLB_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_CTRLB_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_CTRLB_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_CTRLB_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_CTRLB_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_CTRLB_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_CTRLB_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_CTRLB_Type__bindgen_ty_1 {
    #[inline]
    pub fn DETACH(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DETACH(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UPRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UPRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SPDCONF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_SPDCONF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn NREPLY(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NREPLY(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TSTJ(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TSTJ(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TSTK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TSTK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TSTPCKT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_TSTPCKT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OPMODE2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_OPMODE2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GNAK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_GNAK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMHDSK(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_LPMHDSK(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DETACH: u16,
        UPRSM: u16,
        SPDCONF: u16,
        NREPLY: u16,
        TSTJ: u16,
        TSTK: u16,
        TSTPCKT: u16,
        OPMODE2: u16,
        GNAK: u16,
        LPMHDSK: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DETACH: u16 = unsafe { ::core::mem::transmute(DETACH) };
            DETACH as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let UPRSM: u16 = unsafe { ::core::mem::transmute(UPRSM) };
            UPRSM as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let SPDCONF: u16 = unsafe { ::core::mem::transmute(SPDCONF) };
            SPDCONF as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NREPLY: u16 = unsafe { ::core::mem::transmute(NREPLY) };
            NREPLY as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let TSTJ: u16 = unsafe { ::core::mem::transmute(TSTJ) };
            TSTJ as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let TSTK: u16 = unsafe { ::core::mem::transmute(TSTK) };
            TSTK as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let TSTPCKT: u16 = unsafe { ::core::mem::transmute(TSTPCKT) };
            TSTPCKT as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let OPMODE2: u16 = unsafe { ::core::mem::transmute(OPMODE2) };
            OPMODE2 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let GNAK: u16 = unsafe { ::core::mem::transmute(GNAK) };
            GNAK as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let LPMHDSK: u16 = unsafe { ::core::mem::transmute(LPMHDSK) };
            LPMHDSK as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_CTRLB_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_CTRLB_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_CTRLB_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_CTRLB_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_CTRLB_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_CTRLB_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_CTRLB_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_CTRLB_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_DADD_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_DADD_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_DADD_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_DADD_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_DADD_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_DADD_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_DADD_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_DADD_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_DADD_Type__bindgen_ty_1 {
    #[inline]
    pub fn DADD(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_DADD(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn ADDEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ADDEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DADD: u8, ADDEN: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let DADD: u8 = unsafe { ::core::mem::transmute(DADD) };
            DADD as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ADDEN: u8 = unsafe { ::core::mem::transmute(ADDEN) };
            ADDEN as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_DADD_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_DADD_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_DADD_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_DADD_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_DADD_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_DADD_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_DADD_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_DADD_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_STATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_STATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_STATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_STATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_STATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_STATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_STATUS_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_STATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn SPEED(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_SPEED(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn LINESTATE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_LINESTATE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SPEED: u8, LINESTATE: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let SPEED: u8 = unsafe { ::core::mem::transmute(SPEED) };
            SPEED as u64
        });
        __bindgen_bitfield_unit.set(6usize, 2u8, {
            let LINESTATE: u8 = unsafe { ::core::mem::transmute(LINESTATE) };
            LINESTATE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_STATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_STATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_STATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_STATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_STATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_STATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_STATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_STATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_FSMSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_FSMSTATUS_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_FSMSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_FSMSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_FSMSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_FSMSTATUS_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_FSMSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_FSMSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl USB_FSMSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn FSMSTATE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
    }
    #[inline]
    pub fn set_FSMSTATE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(FSMSTATE: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let FSMSTATE: u8 = unsafe { ::core::mem::transmute(FSMSTATE) };
            FSMSTATE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_FSMSTATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_FSMSTATUS_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_FSMSTATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_FSMSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_FSMSTATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_FSMSTATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_FSMSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_FSMSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_FNUM_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_FNUM_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_FNUM_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_FNUM_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_FNUM_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_FNUM_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_FNUM_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_FNUM_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_FNUM_Type__bindgen_ty_1 {
    #[inline]
    pub fn MFNUM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_MFNUM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn FNUM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_FNUM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn FNCERR(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_FNCERR(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MFNUM: u16,
        FNUM: u16,
        FNCERR: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let MFNUM: u16 = unsafe { ::core::mem::transmute(MFNUM) };
            MFNUM as u64
        });
        __bindgen_bitfield_unit.set(3usize, 11u8, {
            let FNUM: u16 = unsafe { ::core::mem::transmute(FNUM) };
            FNUM as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let FNCERR: u16 = unsafe { ::core::mem::transmute(FNCERR) };
            FNCERR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_FNUM_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_FNUM_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_FNUM_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_FNUM_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_FNUM_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_FNUM_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_FNUM_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_FNUM_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_INTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_INTENCLR_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_INTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn SUSPEND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SUSPEND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MSOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MSOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EORST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EORST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WAKEUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EORSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EORSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UPRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UPRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMACER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RAMACER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMNYET(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LPMNYET(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMSUSP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LPMSUSP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SUSPEND: u16,
        MSOF: u16,
        SOF: u16,
        EORST: u16,
        WAKEUP: u16,
        EORSM: u16,
        UPRSM: u16,
        RAMACER: u16,
        LPMNYET: u16,
        LPMSUSP: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SUSPEND: u16 = unsafe { ::core::mem::transmute(SUSPEND) };
            SUSPEND as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MSOF: u16 = unsafe { ::core::mem::transmute(MSOF) };
            MSOF as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SOF: u16 = unsafe { ::core::mem::transmute(SOF) };
            SOF as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EORST: u16 = unsafe { ::core::mem::transmute(EORST) };
            EORST as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WAKEUP: u16 = unsafe { ::core::mem::transmute(WAKEUP) };
            WAKEUP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EORSM: u16 = unsafe { ::core::mem::transmute(EORSM) };
            EORSM as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UPRSM: u16 = unsafe { ::core::mem::transmute(UPRSM) };
            UPRSM as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RAMACER: u16 = unsafe { ::core::mem::transmute(RAMACER) };
            RAMACER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let LPMNYET: u16 = unsafe { ::core::mem::transmute(LPMNYET) };
            LPMNYET as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let LPMSUSP: u16 = unsafe { ::core::mem::transmute(LPMSUSP) };
            LPMSUSP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_INTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_INTENCLR_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_INTENCLR_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_INTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_INTENSET_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_INTENSET_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn SUSPEND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SUSPEND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MSOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MSOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EORST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EORST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WAKEUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EORSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EORSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UPRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UPRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMACER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RAMACER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMNYET(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LPMNYET(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMSUSP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LPMSUSP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SUSPEND: u16,
        MSOF: u16,
        SOF: u16,
        EORST: u16,
        WAKEUP: u16,
        EORSM: u16,
        UPRSM: u16,
        RAMACER: u16,
        LPMNYET: u16,
        LPMSUSP: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SUSPEND: u16 = unsafe { ::core::mem::transmute(SUSPEND) };
            SUSPEND as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MSOF: u16 = unsafe { ::core::mem::transmute(MSOF) };
            MSOF as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SOF: u16 = unsafe { ::core::mem::transmute(SOF) };
            SOF as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EORST: u16 = unsafe { ::core::mem::transmute(EORST) };
            EORST as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WAKEUP: u16 = unsafe { ::core::mem::transmute(WAKEUP) };
            WAKEUP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EORSM: u16 = unsafe { ::core::mem::transmute(EORSM) };
            EORSM as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UPRSM: u16 = unsafe { ::core::mem::transmute(UPRSM) };
            UPRSM as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RAMACER: u16 = unsafe { ::core::mem::transmute(RAMACER) };
            RAMACER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let LPMNYET: u16 = unsafe { ::core::mem::transmute(LPMNYET) };
            LPMNYET as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let LPMSUSP: u16 = unsafe { ::core::mem::transmute(LPMSUSP) };
            LPMSUSP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_INTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_INTENSET_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_INTENSET_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_INTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_INTFLAG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_INTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn SUSPEND(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SUSPEND(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MSOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_MSOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SOF(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_SOF(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EORST(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EORST(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WAKEUP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_WAKEUP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EORSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EORSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UPRSM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UPRSM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RAMACER(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RAMACER(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMNYET(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LPMNYET(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LPMSUSP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_LPMSUSP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SUSPEND: u16,
        MSOF: u16,
        SOF: u16,
        EORST: u16,
        WAKEUP: u16,
        EORSM: u16,
        UPRSM: u16,
        RAMACER: u16,
        LPMNYET: u16,
        LPMSUSP: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SUSPEND: u16 = unsafe { ::core::mem::transmute(SUSPEND) };
            SUSPEND as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let MSOF: u16 = unsafe { ::core::mem::transmute(MSOF) };
            MSOF as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SOF: u16 = unsafe { ::core::mem::transmute(SOF) };
            SOF as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EORST: u16 = unsafe { ::core::mem::transmute(EORST) };
            EORST as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let WAKEUP: u16 = unsafe { ::core::mem::transmute(WAKEUP) };
            WAKEUP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EORSM: u16 = unsafe { ::core::mem::transmute(EORSM) };
            EORSM as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let UPRSM: u16 = unsafe { ::core::mem::transmute(UPRSM) };
            UPRSM as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let RAMACER: u16 = unsafe { ::core::mem::transmute(RAMACER) };
            RAMACER as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let LPMNYET: u16 = unsafe { ::core::mem::transmute(LPMNYET) };
            LPMNYET as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let LPMSUSP: u16 = unsafe { ::core::mem::transmute(LPMSUSP) };
            LPMSUSP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_INTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_INTFLAG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_INTFLAG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPINTSMRY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPINTSMRY_Type__bindgen_ty_1 {
    #[inline]
    pub fn EPINT0(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT0(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT1(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT1(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT2(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT2(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT3(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT3(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT4(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT4(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT5(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT5(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT6(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT6(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EPINT7(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT7(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EPINT0: u16,
        EPINT1: u16,
        EPINT2: u16,
        EPINT3: u16,
        EPINT4: u16,
        EPINT5: u16,
        EPINT6: u16,
        EPINT7: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EPINT0: u16 = unsafe { ::core::mem::transmute(EPINT0) };
            EPINT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EPINT1: u16 = unsafe { ::core::mem::transmute(EPINT1) };
            EPINT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EPINT2: u16 = unsafe { ::core::mem::transmute(EPINT2) };
            EPINT2 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let EPINT3: u16 = unsafe { ::core::mem::transmute(EPINT3) };
            EPINT3 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EPINT4: u16 = unsafe { ::core::mem::transmute(EPINT4) };
            EPINT4 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let EPINT5: u16 = unsafe { ::core::mem::transmute(EPINT5) };
            EPINT5 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EPINT6: u16 = unsafe { ::core::mem::transmute(EPINT6) };
            EPINT6 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let EPINT7: u16 = unsafe { ::core::mem::transmute(EPINT7) };
            EPINT7 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPINTSMRY_Type__bindgen_ty_2 {
    #[inline]
    pub fn EPINT(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_EPINT(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EPINT: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let EPINT: u16 = unsafe { ::core::mem::transmute(EPINT) };
            EPINT as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTSMRY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_EPINTSMRY_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTSMRY_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPINTSMRY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTSMRY_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPINTSMRY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTSMRY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTSMRY_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTSMRY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DESCADD_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DESCADD_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DESCADD_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_USB_DESCADD_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DESCADD_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(USB_DESCADD_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DESCADD_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_DESCADD_Type__bindgen_ty_1))
    );
}
impl USB_DESCADD_Type__bindgen_ty_1 {
    #[inline]
    pub fn DESCADD(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_DESCADD(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(DESCADD: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let DESCADD: u32 = unsafe { ::core::mem::transmute(DESCADD) };
            DESCADD as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DESCADD_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DESCADD_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DESCADD_Type>(),
        4usize,
        concat!("Size of: ", stringify!(USB_DESCADD_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DESCADD_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_DESCADD_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DESCADD_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DESCADD_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_PADCAL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_PADCAL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_PADCAL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_USB_PADCAL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_PADCAL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(USB_PADCAL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_PADCAL_Type__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_PADCAL_Type__bindgen_ty_1))
    );
}
impl USB_PADCAL_Type__bindgen_ty_1 {
    #[inline]
    pub fn TRANSP(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_TRANSP(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn TRANSN(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_TRANSN(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn TRIM(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_TRIM(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRANSP: u16,
        TRANSN: u16,
        TRIM: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 5u8, {
            let TRANSP: u16 = unsafe { ::core::mem::transmute(TRANSP) };
            TRANSP as u64
        });
        __bindgen_bitfield_unit.set(6usize, 5u8, {
            let TRANSN: u16 = unsafe { ::core::mem::transmute(TRANSN) };
            TRANSN as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let TRIM: u16 = unsafe { ::core::mem::transmute(TRIM) };
            TRIM as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_PADCAL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_PADCAL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_PADCAL_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_PADCAL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_PADCAL_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_PADCAL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_PADCAL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_PADCAL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPCFG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPCFG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPCFG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPCFG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPCFG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPCFG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPCFG_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPCFG_Type__bindgen_ty_1 {
    #[inline]
    pub fn EPTYPE0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_EPTYPE0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn EPTYPE1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_EPTYPE1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn NYETDIS(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NYETDIS(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EPTYPE0: u8,
        EPTYPE1: u8,
        NYETDIS: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let EPTYPE0: u8 = unsafe { ::core::mem::transmute(EPTYPE0) };
            EPTYPE0 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let EPTYPE1: u8 = unsafe { ::core::mem::transmute(EPTYPE1) };
            EPTYPE1 as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let NYETDIS: u8 = unsafe { ::core::mem::transmute(NYETDIS) };
            NYETDIS as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPCFG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_EPCFG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPCFG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPCFG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPCFG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPCFG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPCFG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPCFG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPSTATUSCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn DTGLOUT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGLOUT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTGLIN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGLIN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CURBK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CURBK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALLRQ0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALLRQ1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK0RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK0RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK1RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK1RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DTGLOUT: u8,
        DTGLIN: u8,
        CURBK: u8,
        STALLRQ0: u8,
        STALLRQ1: u8,
        BK0RDY: u8,
        BK1RDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DTGLOUT: u8 = unsafe { ::core::mem::transmute(DTGLOUT) };
            DTGLOUT as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DTGLIN: u8 = unsafe { ::core::mem::transmute(DTGLIN) };
            DTGLIN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CURBK: u8 = unsafe { ::core::mem::transmute(CURBK) };
            CURBK as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let STALLRQ0: u8 = unsafe { ::core::mem::transmute(STALLRQ0) };
            STALLRQ0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALLRQ1: u8 = unsafe { ::core::mem::transmute(STALLRQ1) };
            STALLRQ1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BK0RDY: u8 = unsafe { ::core::mem::transmute(BK0RDY) };
            BK0RDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BK1RDY: u8 = unsafe { ::core::mem::transmute(BK1RDY) };
            BK1RDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPSTATUSCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn STALLRQ(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(STALLRQ: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let STALLRQ: u8 = unsafe { ::core::mem::transmute(STALLRQ) };
            STALLRQ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUSCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_EPSTATUSCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUSCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPSTATUSCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUSCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPSTATUSCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUSCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPSTATUSSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn DTGLOUT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGLOUT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTGLIN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGLIN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CURBK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CURBK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALLRQ0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALLRQ1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK0RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK0RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK1RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK1RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DTGLOUT: u8,
        DTGLIN: u8,
        CURBK: u8,
        STALLRQ0: u8,
        STALLRQ1: u8,
        BK0RDY: u8,
        BK1RDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DTGLOUT: u8 = unsafe { ::core::mem::transmute(DTGLOUT) };
            DTGLOUT as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DTGLIN: u8 = unsafe { ::core::mem::transmute(DTGLIN) };
            DTGLIN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CURBK: u8 = unsafe { ::core::mem::transmute(CURBK) };
            CURBK as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let STALLRQ0: u8 = unsafe { ::core::mem::transmute(STALLRQ0) };
            STALLRQ0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALLRQ1: u8 = unsafe { ::core::mem::transmute(STALLRQ1) };
            STALLRQ1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BK0RDY: u8 = unsafe { ::core::mem::transmute(BK0RDY) };
            BK0RDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BK1RDY: u8 = unsafe { ::core::mem::transmute(BK1RDY) };
            BK1RDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPSTATUSSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn STALLRQ(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(STALLRQ: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let STALLRQ: u8 = unsafe { ::core::mem::transmute(STALLRQ) };
            STALLRQ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUSSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_EPSTATUSSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUSSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPSTATUSSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUSSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPSTATUSSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUSSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPSTATUS_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPSTATUS_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPSTATUS_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPSTATUS_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUS_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPSTATUS_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUS_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPSTATUS_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPSTATUS_Type__bindgen_ty_1 {
    #[inline]
    pub fn DTGLOUT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGLOUT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DTGLIN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DTGLIN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CURBK(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CURBK(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALLRQ0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALLRQ1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK0RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK0RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BK1RDY(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_BK1RDY(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DTGLOUT: u8,
        DTGLIN: u8,
        CURBK: u8,
        STALLRQ0: u8,
        STALLRQ1: u8,
        BK0RDY: u8,
        BK1RDY: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DTGLOUT: u8 = unsafe { ::core::mem::transmute(DTGLOUT) };
            DTGLOUT as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DTGLIN: u8 = unsafe { ::core::mem::transmute(DTGLIN) };
            DTGLIN as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CURBK: u8 = unsafe { ::core::mem::transmute(CURBK) };
            CURBK as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let STALLRQ0: u8 = unsafe { ::core::mem::transmute(STALLRQ0) };
            STALLRQ0 as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALLRQ1: u8 = unsafe { ::core::mem::transmute(STALLRQ1) };
            STALLRQ1 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let BK0RDY: u8 = unsafe { ::core::mem::transmute(BK0RDY) };
            BK0RDY as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let BK1RDY: u8 = unsafe { ::core::mem::transmute(BK1RDY) };
            BK1RDY as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPSTATUS_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUS_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUS_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPSTATUS_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUS_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPSTATUS_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPSTATUS_Type__bindgen_ty_2 {
    #[inline]
    pub fn STALLRQ(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STALLRQ(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(STALLRQ: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(4usize, 2u8, {
            let STALLRQ: u8 = unsafe { ::core::mem::transmute(STALLRQ) };
            STALLRQ as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPSTATUS_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_EPSTATUS_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPSTATUS_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPSTATUS_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPSTATUS_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPSTATUS_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUS_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUS_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPSTATUS_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPINTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPINTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn TRCPT0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRCPT1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXSTP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXSTP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRCPT0: u8,
        TRCPT1: u8,
        TRFAIL0: u8,
        TRFAIL1: u8,
        RXSTP: u8,
        STALL0: u8,
        STALL1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TRCPT0: u8 = unsafe { ::core::mem::transmute(TRCPT0) };
            TRCPT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRCPT1: u8 = unsafe { ::core::mem::transmute(TRCPT1) };
            TRCPT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let TRFAIL0: u8 = unsafe { ::core::mem::transmute(TRFAIL0) };
            TRFAIL0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let TRFAIL1: u8 = unsafe { ::core::mem::transmute(TRFAIL1) };
            TRFAIL1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RXSTP: u8 = unsafe { ::core::mem::transmute(RXSTP) };
            RXSTP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALL0: u8 = unsafe { ::core::mem::transmute(STALL0) };
            STALL0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let STALL1: u8 = unsafe { ::core::mem::transmute(STALL1) };
            STALL1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPINTFLAG_Type__bindgen_ty_2 {
    #[inline]
    pub fn TRCPT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STALL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(TRCPT: u8, TRFAIL: u8, STALL: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TRCPT: u8 = unsafe { ::core::mem::transmute(TRCPT) };
            TRCPT as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let TRFAIL: u8 = unsafe { ::core::mem::transmute(TRFAIL) };
            TRFAIL as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let STALL: u8 = unsafe { ::core::mem::transmute(STALL) };
            STALL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_EPINTFLAG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPINTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPINTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTFLAG_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPINTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPINTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn TRCPT0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRCPT1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXSTP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXSTP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRCPT0: u8,
        TRCPT1: u8,
        TRFAIL0: u8,
        TRFAIL1: u8,
        RXSTP: u8,
        STALL0: u8,
        STALL1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TRCPT0: u8 = unsafe { ::core::mem::transmute(TRCPT0) };
            TRCPT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRCPT1: u8 = unsafe { ::core::mem::transmute(TRCPT1) };
            TRCPT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let TRFAIL0: u8 = unsafe { ::core::mem::transmute(TRFAIL0) };
            TRFAIL0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let TRFAIL1: u8 = unsafe { ::core::mem::transmute(TRFAIL1) };
            TRFAIL1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RXSTP: u8 = unsafe { ::core::mem::transmute(RXSTP) };
            RXSTP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALL0: u8 = unsafe { ::core::mem::transmute(STALL0) };
            STALL0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let STALL1: u8 = unsafe { ::core::mem::transmute(STALL1) };
            STALL1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPINTENCLR_Type__bindgen_ty_2 {
    #[inline]
    pub fn TRCPT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STALL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(TRCPT: u8, TRFAIL: u8, STALL: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TRCPT: u8 = unsafe { ::core::mem::transmute(TRCPT) };
            TRCPT as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let TRFAIL: u8 = unsafe { ::core::mem::transmute(TRFAIL) };
            TRFAIL as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let STALL: u8 = unsafe { ::core::mem::transmute(STALL) };
            STALL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_EPINTENCLR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPINTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPINTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTENCLR_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EPINTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EPINTENSET_Type__bindgen_ty_1,
    #[doc = "< Structure used for vec  access"]
    pub vec: USB_DEVICE_EPINTENSET_Type__bindgen_ty_2,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTENSET_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTENSET_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EPINTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn TRCPT0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRCPT1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RXSTP(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RXSTP(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL0(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL0(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL1(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_STALL1(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        TRCPT0: u8,
        TRCPT1: u8,
        TRFAIL0: u8,
        TRFAIL1: u8,
        RXSTP: u8,
        STALL0: u8,
        STALL1: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let TRCPT0: u8 = unsafe { ::core::mem::transmute(TRCPT0) };
            TRCPT0 as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let TRCPT1: u8 = unsafe { ::core::mem::transmute(TRCPT1) };
            TRCPT1 as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let TRFAIL0: u8 = unsafe { ::core::mem::transmute(TRFAIL0) };
            TRFAIL0 as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let TRFAIL1: u8 = unsafe { ::core::mem::transmute(TRFAIL1) };
            TRFAIL1 as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let RXSTP: u8 = unsafe { ::core::mem::transmute(RXSTP) };
            RXSTP as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let STALL0: u8 = unsafe { ::core::mem::transmute(STALL0) };
            STALL0 as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let STALL1: u8 = unsafe { ::core::mem::transmute(STALL1) };
            STALL1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EPINTENSET_Type__bindgen_ty_2 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTENSET_Type__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EPINTENSET_Type__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTENSET_Type__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EPINTENSET_Type__bindgen_ty_2)
        )
    );
}
impl USB_DEVICE_EPINTENSET_Type__bindgen_ty_2 {
    #[inline]
    pub fn TRCPT(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRCPT(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn TRFAIL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_TRFAIL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn STALL(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_STALL(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(TRCPT: u8, TRFAIL: u8, STALL: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let TRCPT: u8 = unsafe { ::core::mem::transmute(TRCPT) };
            TRCPT as u64
        });
        __bindgen_bitfield_unit.set(2usize, 2u8, {
            let TRFAIL: u8 = unsafe { ::core::mem::transmute(TRFAIL) };
            TRFAIL as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let STALL: u8 = unsafe { ::core::mem::transmute(STALL) };
            STALL as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EPINTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_EPINTENSET_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EPINTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EPINTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EPINTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EPINTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).vec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTENSET_Type),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EPINTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_ADDR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_ADDR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_ADDR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_ADDR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(USB_DEVICE_ADDR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_ADDR_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_ADDR_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_ADDR_Type__bindgen_ty_1 {
    #[inline]
    pub fn ADDR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_ADDR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ADDR: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let ADDR: u32 = unsafe { ::core::mem::transmute(ADDR) };
            ADDR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_ADDR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_ADDR_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_ADDR_Type>(),
        4usize,
        concat!("Size of: ", stringify!(USB_DEVICE_ADDR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_ADDR_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_ADDR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_ADDR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_ADDR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_PCKSIZE_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_PCKSIZE_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_PCKSIZE_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_PCKSIZE_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_PCKSIZE_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_PCKSIZE_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_PCKSIZE_Type__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_PCKSIZE_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_PCKSIZE_Type__bindgen_ty_1 {
    #[inline]
    pub fn BYTE_COUNT(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_BYTE_COUNT(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn MULTI_PACKET_SIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 14u8) as u32) }
    }
    #[inline]
    pub fn set_MULTI_PACKET_SIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn SIZE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(28usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_SIZE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(28usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn AUTO_ZLP(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AUTO_ZLP(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BYTE_COUNT: u32,
        MULTI_PACKET_SIZE: u32,
        SIZE: u32,
        AUTO_ZLP: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 14u8, {
            let BYTE_COUNT: u32 = unsafe { ::core::mem::transmute(BYTE_COUNT) };
            BYTE_COUNT as u64
        });
        __bindgen_bitfield_unit.set(14usize, 14u8, {
            let MULTI_PACKET_SIZE: u32 = unsafe { ::core::mem::transmute(MULTI_PACKET_SIZE) };
            MULTI_PACKET_SIZE as u64
        });
        __bindgen_bitfield_unit.set(28usize, 3u8, {
            let SIZE: u32 = unsafe { ::core::mem::transmute(SIZE) };
            SIZE as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let AUTO_ZLP: u32 = unsafe { ::core::mem::transmute(AUTO_ZLP) };
            AUTO_ZLP as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_PCKSIZE_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_PCKSIZE_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_PCKSIZE_Type>(),
        4usize,
        concat!("Size of: ", stringify!(USB_DEVICE_PCKSIZE_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_PCKSIZE_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_PCKSIZE_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_PCKSIZE_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_PCKSIZE_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_EXTREG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_EXTREG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u16,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_EXTREG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EXTREG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EXTREG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_EXTREG_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EXTREG_Type__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_EXTREG_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_EXTREG_Type__bindgen_ty_1 {
    #[inline]
    pub fn SUBPID(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_SUBPID(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn VARIABLE(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_VARIABLE(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SUBPID: u16, VARIABLE: u16) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SUBPID: u16 = unsafe { ::core::mem::transmute(SUBPID) };
            SUBPID as u64
        });
        __bindgen_bitfield_unit.set(4usize, 11u8, {
            let VARIABLE: u16 = unsafe { ::core::mem::transmute(VARIABLE) };
            VARIABLE as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_EXTREG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_EXTREG_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_EXTREG_Type>(),
        2usize,
        concat!("Size of: ", stringify!(USB_DEVICE_EXTREG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_EXTREG_Type>(),
        2usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_EXTREG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EXTREG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_EXTREG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union USB_DEVICE_STATUS_BK_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: USB_DEVICE_STATUS_BK_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct USB_DEVICE_STATUS_BK_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_USB_DEVICE_STATUS_BK_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_STATUS_BK_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(USB_DEVICE_STATUS_BK_Type__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_STATUS_BK_Type__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(USB_DEVICE_STATUS_BK_Type__bindgen_ty_1)
        )
    );
}
impl USB_DEVICE_STATUS_BK_Type__bindgen_ty_1 {
    #[inline]
    pub fn CRCERR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CRCERR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ERRORFLOW(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ERRORFLOW(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CRCERR: u8, ERRORFLOW: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CRCERR: u8 = unsafe { ::core::mem::transmute(CRCERR) };
            CRCERR as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ERRORFLOW: u8 = unsafe { ::core::mem::transmute(ERRORFLOW) };
            ERRORFLOW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_USB_DEVICE_STATUS_BK_Type() {
    const UNINIT: ::core::mem::MaybeUninit<USB_DEVICE_STATUS_BK_Type> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<USB_DEVICE_STATUS_BK_Type>(),
        1usize,
        concat!("Size of: ", stringify!(USB_DEVICE_STATUS_BK_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<USB_DEVICE_STATUS_BK_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(USB_DEVICE_STATUS_BK_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_STATUS_BK_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(USB_DEVICE_STATUS_BK_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UsbDeviceDescBank {
    #[doc = "< \\brief Offset: 0x000 (R/W 32) DEVICE_DESC_BANK Endpoint Bank, Adress of Data Buffer"]
    pub ADDR: USB_DEVICE_ADDR_Type,
    #[doc = "< \\brief Offset: 0x004 (R/W 32) DEVICE_DESC_BANK Endpoint Bank, Packet Size"]
    pub PCKSIZE: USB_DEVICE_PCKSIZE_Type,
    #[doc = "< \\brief Offset: 0x008 (R/W 16) DEVICE_DESC_BANK Endpoint Bank, Extended"]
    pub EXTREG: USB_DEVICE_EXTREG_Type,
    #[doc = "< \\brief Offset: 0x00A (R/W  8) DEVICE_DESC_BANK Enpoint Bank, Status of Bank"]
    pub STATUS_BK: USB_DEVICE_STATUS_BK_Type,
    pub Reserved1: [RoReg8; 5usize],
}
#[test]
fn bindgen_test_layout_UsbDeviceDescBank() {
    const UNINIT: ::core::mem::MaybeUninit<UsbDeviceDescBank> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<UsbDeviceDescBank>(),
        16usize,
        concat!("Size of: ", stringify!(UsbDeviceDescBank))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDeviceDescBank>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDeviceDescBank))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ADDR) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceDescBank),
            "::",
            stringify!(ADDR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PCKSIZE) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceDescBank),
            "::",
            stringify!(PCKSIZE)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EXTREG) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceDescBank),
            "::",
            stringify!(EXTREG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS_BK) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceDescBank),
            "::",
            stringify!(STATUS_BK)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceDescBank),
            "::",
            stringify!(Reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UsbDeviceEndpoint {
    #[doc = "< \\brief Offset: 0x000 (R/W  8) DEVICE_ENDPOINT End Point Configuration"]
    pub EPCFG: USB_DEVICE_EPCFG_Type,
    pub Reserved1: [RoReg8; 3usize],
    #[doc = "< \\brief Offset: 0x004 ( /W  8) DEVICE_ENDPOINT End Point Pipe Status Clear"]
    pub EPSTATUSCLR: USB_DEVICE_EPSTATUSCLR_Type,
    #[doc = "< \\brief Offset: 0x005 ( /W  8) DEVICE_ENDPOINT End Point Pipe Status Set"]
    pub EPSTATUSSET: USB_DEVICE_EPSTATUSSET_Type,
    #[doc = "< \\brief Offset: 0x006 (R/   8) DEVICE_ENDPOINT End Point Pipe Status"]
    pub EPSTATUS: USB_DEVICE_EPSTATUS_Type,
    #[doc = "< \\brief Offset: 0x007 (R/W  8) DEVICE_ENDPOINT End Point Interrupt Flag"]
    pub EPINTFLAG: USB_DEVICE_EPINTFLAG_Type,
    #[doc = "< \\brief Offset: 0x008 (R/W  8) DEVICE_ENDPOINT End Point Interrupt Clear Flag"]
    pub EPINTENCLR: USB_DEVICE_EPINTENCLR_Type,
    #[doc = "< \\brief Offset: 0x009 (R/W  8) DEVICE_ENDPOINT End Point Interrupt Set Flag"]
    pub EPINTENSET: USB_DEVICE_EPINTENSET_Type,
    pub Reserved2: [RoReg8; 22usize],
}
#[test]
fn bindgen_test_layout_UsbDeviceEndpoint() {
    const UNINIT: ::core::mem::MaybeUninit<UsbDeviceEndpoint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<UsbDeviceEndpoint>(),
        32usize,
        concat!("Size of: ", stringify!(UsbDeviceEndpoint))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDeviceEndpoint>(),
        1usize,
        concat!("Alignment of ", stringify!(UsbDeviceEndpoint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EPCFG) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPCFG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EPSTATUSCLR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPSTATUSCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EPSTATUSSET) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPSTATUSSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EPSTATUS) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPSTATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EPINTFLAG) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPINTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EPINTENCLR) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPINTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EPINTENSET) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(EPINTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceEndpoint),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UsbDevice {
    #[doc = "< \\brief Offset: 0x000 (R/W  8) Control A"]
    pub CTRLA: USB_CTRLA_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x002 (R/   8) Synchronization Busy"]
    pub SYNCBUSY: USB_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0x003 (R/W  8) USB Quality Of Service"]
    pub QOSCTRL: USB_QOSCTRL_Type,
    pub Reserved2: [RoReg8; 4usize],
    #[doc = "< \\brief Offset: 0x008 (R/W 16) DEVICE Control B"]
    pub CTRLB: USB_DEVICE_CTRLB_Type,
    #[doc = "< \\brief Offset: 0x00A (R/W  8) DEVICE Device Address"]
    pub DADD: USB_DEVICE_DADD_Type,
    pub Reserved3: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x00C (R/   8) DEVICE Status"]
    pub STATUS: USB_DEVICE_STATUS_Type,
    #[doc = "< \\brief Offset: 0x00D (R/   8) Finite State Machine Status"]
    pub FSMSTATUS: USB_FSMSTATUS_Type,
    pub Reserved4: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x010 (R/  16) DEVICE Device Frame Number"]
    pub FNUM: USB_DEVICE_FNUM_Type,
    pub Reserved5: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x014 (R/W 16) DEVICE Device Interrupt Enable Clear"]
    pub INTENCLR: USB_DEVICE_INTENCLR_Type,
    pub Reserved6: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x018 (R/W 16) DEVICE Device Interrupt Enable Set"]
    pub INTENSET: USB_DEVICE_INTENSET_Type,
    pub Reserved7: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x01C (R/W 16) DEVICE Device Interrupt Flag"]
    pub INTFLAG: USB_DEVICE_INTFLAG_Type,
    pub Reserved8: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x020 (R/  16) DEVICE End Point Interrupt Summary"]
    pub EPINTSMRY: USB_DEVICE_EPINTSMRY_Type,
    pub Reserved9: [RoReg8; 2usize],
    #[doc = "< \\brief Offset: 0x024 (R/W 32) Descriptor Address"]
    pub DESCADD: USB_DESCADD_Type,
    #[doc = "< \\brief Offset: 0x028 (R/W 16) USB PAD Calibration"]
    pub PADCAL: USB_PADCAL_Type,
    pub Reserved10: [RoReg8; 214usize],
    #[doc = "< \\brief Offset: 0x100 UsbDeviceEndpoint groups [EPT_NUM]"]
    pub DeviceEndpoint: [UsbDeviceEndpoint; 8usize],
}
#[test]
fn bindgen_test_layout_UsbDevice() {
    const UNINIT: ::core::mem::MaybeUninit<UsbDevice> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<UsbDevice>(),
        512usize,
        concat!("Size of: ", stringify!(UsbDevice))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDevice>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDevice))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QOSCTRL) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(QOSCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLB) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(CTRLB)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DADD) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(DADD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved3) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).STATUS) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(STATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FSMSTATUS) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(FSMSTATUS)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FNUM) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(FNUM)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved5) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved5)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved6) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved7) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved8) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved8)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EPINTSMRY) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(EPINTSMRY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved9) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved9)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DESCADD) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(DESCADD)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PADCAL) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(PADCAL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved10) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(Reserved10)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceEndpoint) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDevice),
            "::",
            stringify!(DeviceEndpoint)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UsbDeviceDescriptor {
    #[doc = "< \\brief Offset: 0x000 UsbDeviceDescBank groups"]
    pub DeviceDescBank: [UsbDeviceDescBank; 2usize],
}
#[test]
fn bindgen_test_layout_UsbDeviceDescriptor() {
    const UNINIT: ::core::mem::MaybeUninit<UsbDeviceDescriptor> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<UsbDeviceDescriptor>(),
        32usize,
        concat!("Size of: ", stringify!(UsbDeviceDescriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<UsbDeviceDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(UsbDeviceDescriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceDescBank) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UsbDeviceDescriptor),
            "::",
            stringify!(DeviceDescBank)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Usb {
    #[doc = "< \\brief Offset: 0x000 USB is Device"]
    pub DEVICE: UsbDevice,
}
#[test]
fn bindgen_test_layout_Usb() {
    const UNINIT: ::core::mem::MaybeUninit<Usb> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Usb>(),
        512usize,
        concat!("Size of: ", stringify!(Usb))
    );
    assert_eq!(
        ::core::mem::align_of::<Usb>(),
        4usize,
        concat!("Alignment of ", stringify!(Usb))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DEVICE) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Usb),
            "::",
            stringify!(DEVICE)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_CTRLA_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_CTRLA_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_CTRLA_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_WDT_CTRLA_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_CTRLA_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_CTRLA_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_CTRLA_Type__bindgen_ty_1))
    );
}
impl WDT_CTRLA_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WEN(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WEN(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ALWAYSON(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ALWAYSON(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u8,
        WEN: u8,
        ALWAYSON: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u8 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WEN: u8 = unsafe { ::core::mem::transmute(WEN) };
            WEN as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ALWAYSON: u8 = unsafe { ::core::mem::transmute(ALWAYSON) };
            ALWAYSON as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_CTRLA_Type() {
    const UNINIT: ::core::mem::MaybeUninit<WDT_CTRLA_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WDT_CTRLA_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_CTRLA_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_CTRLA_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_CTRLA_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_CTRLA_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_CTRLA_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_CONFIG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_CONFIG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_CONFIG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_WDT_CONFIG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_CONFIG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_CONFIG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_CONFIG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_CONFIG_Type__bindgen_ty_1))
    );
}
impl WDT_CONFIG_Type__bindgen_ty_1 {
    #[inline]
    pub fn PER(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_PER(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn WINDOW(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_WINDOW(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PER: u8, WINDOW: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let PER: u8 = unsafe { ::core::mem::transmute(PER) };
            PER as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let WINDOW: u8 = unsafe { ::core::mem::transmute(WINDOW) };
            WINDOW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_CONFIG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<WDT_CONFIG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WDT_CONFIG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_CONFIG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_CONFIG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_CONFIG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_CONFIG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_CONFIG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_EWCTRL_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_EWCTRL_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_EWCTRL_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_WDT_EWCTRL_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_EWCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_EWCTRL_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_EWCTRL_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_EWCTRL_Type__bindgen_ty_1))
    );
}
impl WDT_EWCTRL_Type__bindgen_ty_1 {
    #[inline]
    pub fn EWOFFSET(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_EWOFFSET(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EWOFFSET: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let EWOFFSET: u8 = unsafe { ::core::mem::transmute(EWOFFSET) };
            EWOFFSET as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_EWCTRL_Type() {
    const UNINIT: ::core::mem::MaybeUninit<WDT_EWCTRL_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WDT_EWCTRL_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_EWCTRL_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_EWCTRL_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_EWCTRL_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_EWCTRL_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_EWCTRL_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_INTENCLR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_INTENCLR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_INTENCLR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_WDT_INTENCLR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_INTENCLR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_INTENCLR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_INTENCLR_Type__bindgen_ty_1))
    );
}
impl WDT_INTENCLR_Type__bindgen_ty_1 {
    #[inline]
    pub fn EW(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EW(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EW: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EW: u8 = unsafe { ::core::mem::transmute(EW) };
            EW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_INTENCLR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<WDT_INTENCLR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WDT_INTENCLR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_INTENCLR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_INTENCLR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_INTENCLR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_INTENCLR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_INTENCLR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_INTENSET_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_INTENSET_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_INTENSET_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_WDT_INTENSET_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_INTENSET_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_INTENSET_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_INTENSET_Type__bindgen_ty_1))
    );
}
impl WDT_INTENSET_Type__bindgen_ty_1 {
    #[inline]
    pub fn EW(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EW(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EW: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EW: u8 = unsafe { ::core::mem::transmute(EW) };
            EW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_INTENSET_Type() {
    const UNINIT: ::core::mem::MaybeUninit<WDT_INTENSET_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WDT_INTENSET_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_INTENSET_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_INTENSET_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_INTENSET_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_INTENSET_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_INTENSET_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_INTFLAG_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_INTFLAG_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_INTFLAG_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_WDT_INTFLAG_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_INTFLAG_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_INTFLAG_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_INTFLAG_Type__bindgen_ty_1))
    );
}
impl WDT_INTFLAG_Type__bindgen_ty_1 {
    #[inline]
    pub fn EW(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_EW(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(EW: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EW: u8 = unsafe { ::core::mem::transmute(EW) };
            EW as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_INTFLAG_Type() {
    const UNINIT: ::core::mem::MaybeUninit<WDT_INTFLAG_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WDT_INTFLAG_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_INTFLAG_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_INTFLAG_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_INTFLAG_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_INTFLAG_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_INTFLAG_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_SYNCBUSY_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_SYNCBUSY_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct WDT_SYNCBUSY_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_WDT_SYNCBUSY_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(WDT_SYNCBUSY_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_SYNCBUSY_Type__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(WDT_SYNCBUSY_Type__bindgen_ty_1))
    );
}
impl WDT_SYNCBUSY_Type__bindgen_ty_1 {
    #[inline]
    pub fn ENABLE(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ENABLE(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WEN(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WEN(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ALWAYSON(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ALWAYSON(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CLEAR(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CLEAR(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ENABLE: u32,
        WEN: u32,
        ALWAYSON: u32,
        CLEAR: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ENABLE: u32 = unsafe { ::core::mem::transmute(ENABLE) };
            ENABLE as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WEN: u32 = unsafe { ::core::mem::transmute(WEN) };
            WEN as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ALWAYSON: u32 = unsafe { ::core::mem::transmute(ALWAYSON) };
            ALWAYSON as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CLEAR: u32 = unsafe { ::core::mem::transmute(CLEAR) };
            CLEAR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_SYNCBUSY_Type() {
    const UNINIT: ::core::mem::MaybeUninit<WDT_SYNCBUSY_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WDT_SYNCBUSY_Type>(),
        4usize,
        concat!("Size of: ", stringify!(WDT_SYNCBUSY_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_SYNCBUSY_Type>(),
        4usize,
        concat!("Alignment of ", stringify!(WDT_SYNCBUSY_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_SYNCBUSY_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_SYNCBUSY_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WDT_CLEAR_Type {
    #[doc = "< Structure used for bit  access"]
    pub bit: WDT_CLEAR_Type__bindgen_ty_1,
    #[doc = "< Type      used for register access"]
    pub reg: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct WDT_CLEAR_Type__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_WDT_CLEAR_Type__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<WDT_CLEAR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_CLEAR_Type__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_CLEAR_Type__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_CLEAR_Type__bindgen_ty_1))
    );
}
impl WDT_CLEAR_Type__bindgen_ty_1 {
    #[inline]
    pub fn CLEAR(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u8) }
    }
    #[inline]
    pub fn set_CLEAR(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(CLEAR: u8) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let CLEAR: u8 = unsafe { ::core::mem::transmute(CLEAR) };
            CLEAR as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WDT_CLEAR_Type() {
    const UNINIT: ::core::mem::MaybeUninit<WDT_CLEAR_Type> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<WDT_CLEAR_Type>(),
        1usize,
        concat!("Size of: ", stringify!(WDT_CLEAR_Type))
    );
    assert_eq!(
        ::core::mem::align_of::<WDT_CLEAR_Type>(),
        1usize,
        concat!("Alignment of ", stringify!(WDT_CLEAR_Type))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_CLEAR_Type),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WDT_CLEAR_Type),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Wdt {
    #[doc = "< \\brief Offset: 0x0 (R/W  8) Control"]
    pub CTRLA: WDT_CTRLA_Type,
    #[doc = "< \\brief Offset: 0x1 (R/W  8) Configuration"]
    pub CONFIG: WDT_CONFIG_Type,
    #[doc = "< \\brief Offset: 0x2 (R/W  8) Early Warning Interrupt Control"]
    pub EWCTRL: WDT_EWCTRL_Type,
    pub Reserved1: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x4 (R/W  8) Interrupt Enable Clear"]
    pub INTENCLR: WDT_INTENCLR_Type,
    #[doc = "< \\brief Offset: 0x5 (R/W  8) Interrupt Enable Set"]
    pub INTENSET: WDT_INTENSET_Type,
    #[doc = "< \\brief Offset: 0x6 (R/W  8) Interrupt Flag Status and Clear"]
    pub INTFLAG: WDT_INTFLAG_Type,
    pub Reserved2: [RoReg8; 1usize],
    #[doc = "< \\brief Offset: 0x8 (R/  32) Synchronization Busy"]
    pub SYNCBUSY: WDT_SYNCBUSY_Type,
    #[doc = "< \\brief Offset: 0xC ( /W  8) Clear"]
    pub CLEAR: WDT_CLEAR_Type,
}
#[test]
fn bindgen_test_layout_Wdt() {
    const UNINIT: ::core::mem::MaybeUninit<Wdt> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<Wdt>(),
        16usize,
        concat!("Size of: ", stringify!(Wdt))
    );
    assert_eq!(
        ::core::mem::align_of::<Wdt>(),
        4usize,
        concat!("Alignment of ", stringify!(Wdt))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CTRLA) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(CTRLA)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CONFIG) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(CONFIG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EWCTRL) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(EWCTRL)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENCLR) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(INTENCLR)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTENSET) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(INTENSET)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).INTFLAG) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(INTFLAG)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SYNCBUSY) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(SYNCBUSY)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CLEAR) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Wdt),
            "::",
            stringify!(CLEAR)
        )
    );
}
pub type hri_ac_evctrl_reg_t = u16;
pub type hri_ac_compctrl_reg_t = u32;
pub type hri_ac_syncbusy_reg_t = u32;
pub type hri_ac_ctrla_reg_t = u8;
pub type hri_ac_ctrlb_reg_t = u8;
pub type hri_ac_dbgctrl_reg_t = u8;
pub type hri_ac_intenset_reg_t = u8;
pub type hri_ac_intflag_reg_t = u8;
pub type hri_ac_scaler_reg_t = u8;
pub type hri_ac_statusa_reg_t = u8;
pub type hri_ac_statusb_reg_t = u8;
pub type hri_ac_winctrl_reg_t = u8;
pub type hri_adc_calib_reg_t = u16;
pub type hri_adc_ctrlc_reg_t = u16;
pub type hri_adc_gaincorr_reg_t = u16;
pub type hri_adc_inputctrl_reg_t = u16;
pub type hri_adc_offsetcorr_reg_t = u16;
pub type hri_adc_result_reg_t = u16;
pub type hri_adc_syncbusy_reg_t = u16;
pub type hri_adc_winlt_reg_t = u16;
pub type hri_adc_winut_reg_t = u16;
pub type hri_adc_seqctrl_reg_t = u32;
pub type hri_adc_avgctrl_reg_t = u8;
pub type hri_adc_ctrla_reg_t = u8;
pub type hri_adc_ctrlb_reg_t = u8;
pub type hri_adc_dbgctrl_reg_t = u8;
pub type hri_adc_evctrl_reg_t = u8;
pub type hri_adc_intenset_reg_t = u8;
pub type hri_adc_intflag_reg_t = u8;
pub type hri_adc_refctrl_reg_t = u8;
pub type hri_adc_sampctrl_reg_t = u8;
pub type hri_adc_seqstatus_reg_t = u8;
pub type hri_adc_swtrig_reg_t = u8;
pub type hri_aes_ciplen_reg_t = u32;
pub type hri_aes_ctrla_reg_t = u32;
pub type hri_aes_ghash_reg_t = u32;
pub type hri_aes_hashkey_reg_t = u32;
pub type hri_aes_indata_reg_t = u32;
pub type hri_aes_intvectv_reg_t = u32;
pub type hri_aes_keyword_reg_t = u32;
pub type hri_aes_randseed_reg_t = u32;
pub type hri_aes_ctrlb_reg_t = u8;
pub type hri_aes_databufptr_reg_t = u8;
pub type hri_aes_dbgctrl_reg_t = u8;
pub type hri_aes_intenset_reg_t = u8;
pub type hri_aes_intflag_reg_t = u8;
pub type hri_ccl_lutctrl_reg_t = u32;
pub type hri_ccl_ctrl_reg_t = u8;
pub type hri_ccl_seqctrl_reg_t = u8;
pub type hri_dmac_crcctrl_reg_t = u16;
pub type hri_dmac_ctrl_reg_t = u16;
pub type hri_dmac_intpend_reg_t = u16;
pub type hri_dmacdescriptor_btcnt_reg_t = u16;
pub type hri_dmacdescriptor_btctrl_reg_t = u16;
pub type hri_dmac_active_reg_t = u32;
pub type hri_dmac_baseaddr_reg_t = u32;
pub type hri_dmac_busych_reg_t = u32;
pub type hri_dmac_chctrlb_reg_t = u32;
pub type hri_dmac_crcchksum_reg_t = u32;
pub type hri_dmac_crcdatain_reg_t = u32;
pub type hri_dmac_intstatus_reg_t = u32;
pub type hri_dmac_pendch_reg_t = u32;
pub type hri_dmac_prictrl0_reg_t = u32;
pub type hri_dmac_swtrigctrl_reg_t = u32;
pub type hri_dmac_wrbaddr_reg_t = u32;
pub type hri_dmacdescriptor_descaddr_reg_t = u32;
pub type hri_dmacdescriptor_dstaddr_reg_t = u32;
pub type hri_dmacdescriptor_srcaddr_reg_t = u32;
pub type hri_dmac_chctrla_reg_t = u8;
pub type hri_dmac_chid_reg_t = u8;
pub type hri_dmac_chintenset_reg_t = u8;
pub type hri_dmac_chintflag_reg_t = u8;
pub type hri_dmac_chstatus_reg_t = u8;
pub type hri_dmac_crcstatus_reg_t = u8;
pub type hri_dmac_dbgctrl_reg_t = u8;
pub type hri_dmac_qosctrl_reg_t = u8;
pub type hri_dsu_addr_reg_t = u32;
pub type hri_dsu_cid0_reg_t = u32;
pub type hri_dsu_cid1_reg_t = u32;
pub type hri_dsu_cid2_reg_t = u32;
pub type hri_dsu_cid3_reg_t = u32;
pub type hri_dsu_data_reg_t = u32;
pub type hri_dsu_dcc_reg_t = u32;
pub type hri_dsu_dcfg_reg_t = u32;
pub type hri_dsu_did_reg_t = u32;
pub type hri_dsu_end_reg_t = u32;
pub type hri_dsu_entry0_reg_t = u32;
pub type hri_dsu_entry1_reg_t = u32;
pub type hri_dsu_length_reg_t = u32;
pub type hri_dsu_memtype_reg_t = u32;
pub type hri_dsu_pid0_reg_t = u32;
pub type hri_dsu_pid1_reg_t = u32;
pub type hri_dsu_pid2_reg_t = u32;
pub type hri_dsu_pid3_reg_t = u32;
pub type hri_dsu_pid4_reg_t = u32;
pub type hri_dsu_pid5_reg_t = u32;
pub type hri_dsu_pid6_reg_t = u32;
pub type hri_dsu_pid7_reg_t = u32;
pub type hri_dsu_ctrl_reg_t = u8;
pub type hri_dsu_statusa_reg_t = u8;
pub type hri_dsu_statusb_reg_t = u8;
pub type hri_eic_nmiflag_reg_t = u16;
pub type hri_eic_asynch_reg_t = u32;
pub type hri_eic_config_reg_t = u32;
pub type hri_eic_evctrl_reg_t = u32;
pub type hri_eic_intenset_reg_t = u32;
pub type hri_eic_intflag_reg_t = u32;
pub type hri_eic_syncbusy_reg_t = u32;
pub type hri_eic_ctrla_reg_t = u8;
pub type hri_eic_nmictrl_reg_t = u8;
pub type hri_evsys_channel_reg_t = u32;
pub type hri_evsys_chstatus_reg_t = u32;
pub type hri_evsys_intenset_reg_t = u32;
pub type hri_evsys_intflag_reg_t = u32;
pub type hri_evsys_swevt_reg_t = u32;
pub type hri_evsys_user_reg_t = u32;
pub type hri_evsys_ctrla_reg_t = u8;
pub type hri_freqm_cfga_reg_t = u16;
pub type hri_freqm_syncbusy_reg_t = u32;
pub type hri_freqm_value_reg_t = u32;
pub type hri_freqm_ctrla_reg_t = u8;
pub type hri_freqm_ctrlb_reg_t = u8;
pub type hri_freqm_intenset_reg_t = u8;
pub type hri_freqm_intflag_reg_t = u8;
pub type hri_freqm_status_reg_t = u8;
pub type hri_gclk_genctrl_reg_t = u32;
pub type hri_gclk_pchctrl_reg_t = u32;
pub type hri_gclk_syncbusy_reg_t = u32;
pub type hri_gclk_ctrla_reg_t = u8;
pub type hri_mclk_ahbmask_reg_t = u32;
pub type hri_mclk_apbamask_reg_t = u32;
pub type hri_mclk_apbbmask_reg_t = u32;
pub type hri_mclk_apbcmask_reg_t = u32;
pub type hri_mclk_bupdiv_reg_t = u8;
pub type hri_mclk_cpudiv_reg_t = u8;
pub type hri_mclk_intenset_reg_t = u8;
pub type hri_mclk_intflag_reg_t = u8;
pub type hri_mtb_authstatus_reg_t = u32;
pub type hri_mtb_base_reg_t = u32;
pub type hri_mtb_cid0_reg_t = u32;
pub type hri_mtb_cid1_reg_t = u32;
pub type hri_mtb_cid2_reg_t = u32;
pub type hri_mtb_cid3_reg_t = u32;
pub type hri_mtb_claimset_reg_t = u32;
pub type hri_mtb_devarch_reg_t = u32;
pub type hri_mtb_devid_reg_t = u32;
pub type hri_mtb_devtype_reg_t = u32;
pub type hri_mtb_flow_reg_t = u32;
pub type hri_mtb_itctrl_reg_t = u32;
pub type hri_mtb_lockaccess_reg_t = u32;
pub type hri_mtb_lockstatus_reg_t = u32;
pub type hri_mtb_master_reg_t = u32;
pub type hri_mtb_pid0_reg_t = u32;
pub type hri_mtb_pid1_reg_t = u32;
pub type hri_mtb_pid2_reg_t = u32;
pub type hri_mtb_pid3_reg_t = u32;
pub type hri_mtb_pid4_reg_t = u32;
pub type hri_mtb_pid5_reg_t = u32;
pub type hri_mtb_pid6_reg_t = u32;
pub type hri_mtb_pid7_reg_t = u32;
pub type hri_mtb_position_reg_t = u32;
pub type hri_nvmctrl_ctrla_reg_t = u16;
pub type hri_nvmctrl_lock_reg_t = u16;
pub type hri_nvmctrl_status_reg_t = u16;
pub type hri_nvmctrl_addr_reg_t = u32;
pub type hri_nvmctrl_ctrlb_reg_t = u32;
pub type hri_nvmctrl_param_reg_t = u32;
pub type hri_nvmctrl_intenset_reg_t = u8;
pub type hri_nvmctrl_intflag_reg_t = u8;
pub type hri_osc32kctrl_xosc32k_reg_t = u16;
pub type hri_osc32kctrl_intenset_reg_t = u32;
pub type hri_osc32kctrl_intflag_reg_t = u32;
pub type hri_osc32kctrl_osculp32k_reg_t = u32;
pub type hri_osc32kctrl_status_reg_t = u32;
pub type hri_osc32kctrl_cfdctrl_reg_t = u8;
pub type hri_osc32kctrl_evctrl_reg_t = u8;
pub type hri_osc32kctrl_rtcctrl_reg_t = u8;
pub type hri_osc32kctrl_slcdctrl_reg_t = u8;
pub type hri_oscctrl_dfllctrl_reg_t = u16;
pub type hri_oscctrl_xoscctrl_reg_t = u16;
pub type hri_oscctrl_dfllmul_reg_t = u32;
pub type hri_oscctrl_dfllval_reg_t = u32;
pub type hri_oscctrl_dpllctrlb_reg_t = u32;
pub type hri_oscctrl_dpllratio_reg_t = u32;
pub type hri_oscctrl_intenset_reg_t = u32;
pub type hri_oscctrl_intflag_reg_t = u32;
pub type hri_oscctrl_status_reg_t = u32;
pub type hri_oscctrl_cfdpresc_reg_t = u8;
pub type hri_oscctrl_dfllsync_reg_t = u8;
pub type hri_oscctrl_dpllctrla_reg_t = u8;
pub type hri_oscctrl_dpllpresc_reg_t = u8;
pub type hri_oscctrl_dpllstatus_reg_t = u8;
pub type hri_oscctrl_dpllsyncbusy_reg_t = u8;
pub type hri_oscctrl_evctrl_reg_t = u8;
pub type hri_oscctrl_osc16mctrl_reg_t = u8;
pub type hri_pac_intflaga_reg_t = u32;
pub type hri_pac_intflagahb_reg_t = u32;
pub type hri_pac_intflagb_reg_t = u32;
pub type hri_pac_intflagc_reg_t = u32;
pub type hri_pac_statusa_reg_t = u32;
pub type hri_pac_statusb_reg_t = u32;
pub type hri_pac_statusc_reg_t = u32;
pub type hri_pac_wrctrl_reg_t = u32;
pub type hri_pac_evctrl_reg_t = u8;
pub type hri_pac_intenset_reg_t = u8;
pub type hri_pm_stdbycfg_reg_t = u16;
pub type hri_pm_ctrla_reg_t = u8;
pub type hri_pm_intenset_reg_t = u8;
pub type hri_pm_intflag_reg_t = u8;
pub type hri_pm_plcfg_reg_t = u8;
pub type hri_pm_sleepcfg_reg_t = u8;
pub type hri_port_ctrl_reg_t = u32;
pub type hri_port_dir_reg_t = u32;
pub type hri_port_evctrl_reg_t = u32;
pub type hri_port_in_reg_t = u32;
pub type hri_port_out_reg_t = u32;
pub type hri_port_wrconfig_reg_t = u32;
pub type hri_portgroup_ctrl_reg_t = u32;
pub type hri_portgroup_dir_reg_t = u32;
pub type hri_portgroup_evctrl_reg_t = u32;
pub type hri_portgroup_in_reg_t = u32;
pub type hri_portgroup_out_reg_t = u32;
pub type hri_portgroup_wrconfig_reg_t = u32;
pub type hri_port_pincfg_reg_t = u8;
pub type hri_port_pmux_reg_t = u8;
pub type hri_portgroup_pincfg_reg_t = u8;
pub type hri_portgroup_pmux_reg_t = u8;
pub type hri_rstc_bkupexit_reg_t = u8;
pub type hri_rstc_rcause_reg_t = u8;
pub type hri_rtcmode0_ctrla_reg_t = u16;
pub type hri_rtcmode0_ctrlb_reg_t = u16;
pub type hri_rtcmode0_intenset_reg_t = u16;
pub type hri_rtcmode0_intflag_reg_t = u16;
pub type hri_rtcmode1_comp_reg_t = u16;
pub type hri_rtcmode1_count_reg_t = u16;
pub type hri_rtcmode1_ctrla_reg_t = u16;
pub type hri_rtcmode1_ctrlb_reg_t = u16;
pub type hri_rtcmode1_intenset_reg_t = u16;
pub type hri_rtcmode1_intflag_reg_t = u16;
pub type hri_rtcmode1_per_reg_t = u16;
pub type hri_rtcmode2_ctrla_reg_t = u16;
pub type hri_rtcmode2_ctrlb_reg_t = u16;
pub type hri_rtcmode2_intenset_reg_t = u16;
pub type hri_rtcmode2_intflag_reg_t = u16;
pub type hri_rtc_bkup_reg_t = u32;
pub type hri_rtc_gp_reg_t = u32;
pub type hri_rtc_tampctrl_reg_t = u32;
pub type hri_rtc_tampid_reg_t = u32;
pub type hri_rtcalarm_alarm_reg_t = u32;
pub type hri_rtcmode0_comp_reg_t = u32;
pub type hri_rtcmode0_count_reg_t = u32;
pub type hri_rtcmode0_evctrl_reg_t = u32;
pub type hri_rtcmode0_syncbusy_reg_t = u32;
pub type hri_rtcmode0_timestamp_reg_t = u32;
pub type hri_rtcmode1_evctrl_reg_t = u32;
pub type hri_rtcmode1_syncbusy_reg_t = u32;
pub type hri_rtcmode1_timestamp_reg_t = u32;
pub type hri_rtcmode2_alarm_reg_t = u32;
pub type hri_rtcmode2_clock_reg_t = u32;
pub type hri_rtcmode2_evctrl_reg_t = u32;
pub type hri_rtcmode2_syncbusy_reg_t = u32;
pub type hri_rtcmode2_timestamp_reg_t = u32;
pub type hri_rtc_dbgctrl_reg_t = u8;
pub type hri_rtc_freqcorr_reg_t = u8;
pub type hri_rtcalarm_mask_reg_t = u8;
pub type hri_rtcmode2_mask_reg_t = u8;
pub type hri_sercomi2cm_status_reg_t = u16;
pub type hri_sercomi2cs_status_reg_t = u16;
pub type hri_sercomspi_status_reg_t = u16;
pub type hri_sercomusart_baud_reg_t = u16;
pub type hri_sercomusart_data_reg_t = u16;
pub type hri_sercomusart_status_reg_t = u16;
pub type hri_sercomi2cm_addr_reg_t = u32;
pub type hri_sercomi2cm_baud_reg_t = u32;
pub type hri_sercomi2cm_ctrla_reg_t = u32;
pub type hri_sercomi2cm_ctrlb_reg_t = u32;
pub type hri_sercomi2cm_syncbusy_reg_t = u32;
pub type hri_sercomi2cs_addr_reg_t = u32;
pub type hri_sercomi2cs_ctrla_reg_t = u32;
pub type hri_sercomi2cs_ctrlb_reg_t = u32;
pub type hri_sercomi2cs_syncbusy_reg_t = u32;
pub type hri_sercomspi_addr_reg_t = u32;
pub type hri_sercomspi_ctrla_reg_t = u32;
pub type hri_sercomspi_ctrlb_reg_t = u32;
pub type hri_sercomspi_data_reg_t = u32;
pub type hri_sercomspi_syncbusy_reg_t = u32;
pub type hri_sercomusart_ctrla_reg_t = u32;
pub type hri_sercomusart_ctrlb_reg_t = u32;
pub type hri_sercomusart_ctrlc_reg_t = u32;
pub type hri_sercomusart_syncbusy_reg_t = u32;
pub type hri_sercomi2cm_data_reg_t = u8;
pub type hri_sercomi2cm_dbgctrl_reg_t = u8;
pub type hri_sercomi2cm_intenset_reg_t = u8;
pub type hri_sercomi2cm_intflag_reg_t = u8;
pub type hri_sercomi2cs_data_reg_t = u8;
pub type hri_sercomi2cs_intenset_reg_t = u8;
pub type hri_sercomi2cs_intflag_reg_t = u8;
pub type hri_sercomspi_baud_reg_t = u8;
pub type hri_sercomspi_dbgctrl_reg_t = u8;
pub type hri_sercomspi_intenset_reg_t = u8;
pub type hri_sercomspi_intflag_reg_t = u8;
pub type hri_sercomusart_dbgctrl_reg_t = u8;
pub type hri_sercomusart_intenset_reg_t = u8;
pub type hri_sercomusart_intflag_reg_t = u8;
pub type hri_sercomusart_rxerrcnt_reg_t = u8;
pub type hri_sercomusart_rxpl_reg_t = u8;
pub type hri_slcd_cmindex_reg_t = u16;
pub type hri_slcd_ctrlb_reg_t = u16;
pub type hri_slcd_ctrlc_reg_t = u16;
pub type hri_slcd_acmcfg_reg_t = u32;
pub type hri_slcd_bcfg_reg_t = u32;
pub type hri_slcd_cmdata_reg_t = u32;
pub type hri_slcd_cmdmask_reg_t = u32;
pub type hri_slcd_csrcfg_reg_t = u32;
pub type hri_slcd_ctrla_reg_t = u32;
pub type hri_slcd_isdata_reg_t = u32;
pub type hri_slcd_lpenh_reg_t = u32;
pub type hri_slcd_lpenl_reg_t = u32;
pub type hri_slcd_sdatah0_reg_t = u32;
pub type hri_slcd_sdatah1_reg_t = u32;
pub type hri_slcd_sdatah2_reg_t = u32;
pub type hri_slcd_sdatah3_reg_t = u32;
pub type hri_slcd_sdatah4_reg_t = u32;
pub type hri_slcd_sdatah5_reg_t = u32;
pub type hri_slcd_sdatah6_reg_t = u32;
pub type hri_slcd_sdatah7_reg_t = u32;
pub type hri_slcd_sdatal0_reg_t = u32;
pub type hri_slcd_sdatal1_reg_t = u32;
pub type hri_slcd_sdatal2_reg_t = u32;
pub type hri_slcd_sdatal3_reg_t = u32;
pub type hri_slcd_sdatal4_reg_t = u32;
pub type hri_slcd_sdatal5_reg_t = u32;
pub type hri_slcd_sdatal6_reg_t = u32;
pub type hri_slcd_sdatal7_reg_t = u32;
pub type hri_slcd_syncbusy_reg_t = u32;
pub type hri_slcd_abmcfg_reg_t = u8;
pub type hri_slcd_cmcfg_reg_t = u8;
pub type hri_slcd_ctrld_reg_t = u8;
pub type hri_slcd_evctrl_reg_t = u8;
pub type hri_slcd_fc0_reg_t = u8;
pub type hri_slcd_fc1_reg_t = u8;
pub type hri_slcd_fc2_reg_t = u8;
pub type hri_slcd_intenset_reg_t = u8;
pub type hri_slcd_intflag_reg_t = u8;
pub type hri_slcd_status_reg_t = u8;
pub type hri_supc_bbps_reg_t = u32;
pub type hri_supc_bkin_reg_t = u32;
pub type hri_supc_bkout_reg_t = u32;
pub type hri_supc_bod12_reg_t = u32;
pub type hri_supc_bod33_reg_t = u32;
pub type hri_supc_intenset_reg_t = u32;
pub type hri_supc_intflag_reg_t = u32;
pub type hri_supc_status_reg_t = u32;
pub type hri_supc_vref_reg_t = u32;
pub type hri_supc_vreg_reg_t = u32;
pub type hri_tc_evctrl_reg_t = u16;
pub type hri_tccount16_cc_reg_t = u16;
pub type hri_tccount16_ccbuf_reg_t = u16;
pub type hri_tccount16_count_reg_t = u16;
pub type hri_tc_ctrla_reg_t = u32;
pub type hri_tc_syncbusy_reg_t = u32;
pub type hri_tccount32_cc_reg_t = u32;
pub type hri_tccount32_ccbuf_reg_t = u32;
pub type hri_tccount32_count_reg_t = u32;
pub type hri_tc_ctrlbset_reg_t = u8;
pub type hri_tc_dbgctrl_reg_t = u8;
pub type hri_tc_drvctrl_reg_t = u8;
pub type hri_tc_intenset_reg_t = u8;
pub type hri_tc_intflag_reg_t = u8;
pub type hri_tc_status_reg_t = u8;
pub type hri_tc_wave_reg_t = u8;
pub type hri_tccount8_cc_reg_t = u8;
pub type hri_tccount8_ccbuf_reg_t = u8;
pub type hri_tccount8_count_reg_t = u8;
pub type hri_tccount8_per_reg_t = u8;
pub type hri_tccount8_perbuf_reg_t = u8;
pub type hri_tcc_patt_reg_t = u16;
pub type hri_tcc_pattbuf_reg_t = u16;
pub type hri_tcc_cc_reg_t = u32;
pub type hri_tcc_ccbuf_reg_t = u32;
pub type hri_tcc_count_reg_t = u32;
pub type hri_tcc_ctrla_reg_t = u32;
pub type hri_tcc_drvctrl_reg_t = u32;
pub type hri_tcc_evctrl_reg_t = u32;
pub type hri_tcc_fctrla_reg_t = u32;
pub type hri_tcc_fctrlb_reg_t = u32;
pub type hri_tcc_intenset_reg_t = u32;
pub type hri_tcc_intflag_reg_t = u32;
pub type hri_tcc_per_reg_t = u32;
pub type hri_tcc_perbuf_reg_t = u32;
pub type hri_tcc_status_reg_t = u32;
pub type hri_tcc_syncbusy_reg_t = u32;
pub type hri_tcc_wave_reg_t = u32;
pub type hri_tcc_wexctrl_reg_t = u32;
pub type hri_tcc_ctrlbset_reg_t = u8;
pub type hri_tcc_dbgctrl_reg_t = u8;
pub type hri_trng_data_reg_t = u32;
pub type hri_trng_ctrla_reg_t = u8;
pub type hri_trng_evctrl_reg_t = u8;
pub type hri_trng_intenset_reg_t = u8;
pub type hri_trng_intflag_reg_t = u8;
pub type hri_usb_padcal_reg_t = u16;
pub type hri_usbdesc_bank_extreg_reg_t = u16;
pub type hri_usbdescriptordevice_extreg_reg_t = u16;
pub type hri_usbdevice_ctrlb_reg_t = u16;
pub type hri_usbdevice_epintsmry_reg_t = u16;
pub type hri_usbdevice_fnum_reg_t = u16;
pub type hri_usbdevice_intenset_reg_t = u16;
pub type hri_usbdevice_intflag_reg_t = u16;
pub type hri_usb_descadd_reg_t = u32;
pub type hri_usbdesc_bank_addr_reg_t = u32;
pub type hri_usbdesc_bank_pcksize_reg_t = u32;
pub type hri_usbdescriptordevice_addr_reg_t = u32;
pub type hri_usbdescriptordevice_pcksize_reg_t = u32;
pub type hri_usb_ctrla_reg_t = u8;
pub type hri_usb_fsmstatus_reg_t = u8;
pub type hri_usb_qosctrl_reg_t = u8;
pub type hri_usb_syncbusy_reg_t = u8;
pub type hri_usbdesc_bank_status_bk_reg_t = u8;
pub type hri_usbdescriptordevice_status_bk_reg_t = u8;
pub type hri_usbdevice_dadd_reg_t = u8;
pub type hri_usbdevice_epcfg_reg_t = u8;
pub type hri_usbdevice_epintenset_reg_t = u8;
pub type hri_usbdevice_epintflag_reg_t = u8;
pub type hri_usbdevice_epstatus_reg_t = u8;
pub type hri_usbdevice_status_reg_t = u8;
pub type hri_usbendpoint_epcfg_reg_t = u8;
pub type hri_usbendpoint_epintenset_reg_t = u8;
pub type hri_usbendpoint_epintflag_reg_t = u8;
pub type hri_usbendpoint_epstatus_reg_t = u8;
pub type hri_wdt_syncbusy_reg_t = u32;
pub type hri_wdt_clear_reg_t = u8;
pub type hri_wdt_config_reg_t = u8;
pub type hri_wdt_ctrla_reg_t = u8;
pub type hri_wdt_ewctrl_reg_t = u8;
pub type hri_wdt_intenset_reg_t = u8;
pub type hri_wdt_intflag_reg_t = u8;
#[doc = " \\brief Type for the register holding global interrupt enable flag"]
pub type hal_atomic_t = u32;
extern "C" {
    #[doc = " \\brief Disable interrupts, enter critical section\n\n Disables global interrupts. Supports nested critical sections,\n so that global interrupts are only re-enabled\n upon leaving the outermost nested critical section.\n\n \\param[out] atomic The pointer to a variable to store the value of global\n interrupt enable flag"]
    pub fn atomic_enter_critical(atomic: *mut hal_atomic_t);
}
extern "C" {
    #[doc = " \\brief Exit atomic section\n\n Enables global interrupts. Supports nested critical sections,\n so that global interrupts are only re-enabled\n upon leaving the outermost nested critical section.\n\n \\param[in] atomic The pointer to a variable, which stores the latest stored\n value of the global interrupt enable flag"]
    pub fn atomic_leave_critical(atomic: *mut hal_atomic_t);
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version\n\n \\return Current driver version."]
    pub fn atomic_get_version() -> u32;
}
#[doc = " \\brief IRQ descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _irq_descriptor {
    pub handler: ::core::option::Option<unsafe extern "C" fn(parameter: *mut ::core::ffi::c_void)>,
    pub parameter: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout__irq_descriptor() {
    const UNINIT: ::core::mem::MaybeUninit<_irq_descriptor> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_irq_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(_irq_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<_irq_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(_irq_descriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_irq_descriptor),
            "::",
            stringify!(handler)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parameter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_irq_descriptor),
            "::",
            stringify!(parameter)
        )
    );
}
extern "C" {
    #[doc = " \\brief Retrieve current IRQ number\n\n \\return The current IRQ number"]
    pub fn _irq_get_current() -> u8;
}
extern "C" {
    #[doc = " \\brief Disable the given IRQ\n\n \\param[in] n The number of IRQ to disable"]
    pub fn _irq_disable(n: u8);
}
extern "C" {
    #[doc = " \\brief Set the given IRQ\n\n \\param[in] n The number of IRQ to set"]
    pub fn _irq_set(n: u8);
}
extern "C" {
    #[doc = " \\brief Clear the given IRQ\n\n \\param[in] n The number of IRQ to clear"]
    pub fn _irq_clear(n: u8);
}
extern "C" {
    #[doc = " \\brief Enable the given IRQ\n\n \\param[in] n The number of IRQ to enable"]
    pub fn _irq_enable(n: u8);
}
extern "C" {
    #[doc = " \\brief Register IRQ handler\n\n \\param[in] number The number registered IRQ\n \\param[in] irq The pointer to irq handler to register\n\n \\return The status of IRQ handler registering\n \\retval -1 Passed parameters were invalid\n \\retval 0 The registering is completed successfully"]
    pub fn _irq_register(number: u8, irq: *mut _irq_descriptor);
}
pub const reset_reason_RESET_REASON_POR: reset_reason = 1;
pub const reset_reason_RESET_REASON_BOD12: reset_reason = 2;
pub const reset_reason_RESET_REASON_BOD33: reset_reason = 4;
pub const reset_reason_RESET_REASON_EXT: reset_reason = 16;
pub const reset_reason_RESET_REASON_WDT: reset_reason = 32;
pub const reset_reason_RESET_REASON_SYST: reset_reason = 64;
pub const reset_reason_RESET_REASON_BACKUP: reset_reason = 128;
#[doc = " \\brief Reset reason enumeration\n\n The list of possible reset reasons."]
pub type reset_reason = ::core::ffi::c_uint;
extern "C" {
    #[doc = " \\brief Retrieve the reset reason\n\n Retrieves the reset reason of the last MCU reset.\n\n\\return An enum value indicating the reason of the last reset."]
    pub fn _get_reset_reason() -> reset_reason;
}
extern "C" {
    #[doc = " \\brief Reset MCU"]
    pub fn _reset_mcu();
}
extern "C" {
    #[doc = " \\brief Set the sleep mode for the device\n\n This function sets the sleep mode for the device.\n For an overview of which systems are disabled in sleep for the different\n sleep modes see datasheet.\n\n \\param[in] mode Sleep mode to use\n\n \\return the status of a sleep request\n \\retval -1 The requested sleep mode was invalid\n \\retval  0 The operation completed successfully, sleep mode is set"]
    pub fn _set_sleep_mode(mode: u8) -> i32;
}
extern "C" {
    #[doc = " \\brief Put MCU to sleep"]
    pub fn _go_to_sleep();
}
extern "C" {
    #[doc = " \\brief Initialize Delay driver\n\n \\param[in] hw The pointer to hardware instance"]
    pub fn delay_init(hw: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " \\brief Perform delay in us\n\n This function performs delay for the given amount of microseconds.\n\n \\param[in] us The amount delay in us"]
    pub fn delay_us(us: u16);
}
extern "C" {
    #[doc = " \\brief Perform delay in ms\n\n This function performs delay for the given amount of milliseconds.\n\n \\param[in] ms The amount delay in ms"]
    pub fn delay_ms(ms: u16);
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version\n\n \\return Current driver version."]
    pub fn delay_get_version() -> u32;
}
pub const gpio_pull_mode_GPIO_PULL_OFF: gpio_pull_mode = 0;
pub const gpio_pull_mode_GPIO_PULL_UP: gpio_pull_mode = 1;
pub const gpio_pull_mode_GPIO_PULL_DOWN: gpio_pull_mode = 2;
#[doc = " \\brief PORT pull mode settings"]
pub type gpio_pull_mode = ::core::ffi::c_uint;
pub const gpio_direction_GPIO_DIRECTION_OFF: gpio_direction = 0;
pub const gpio_direction_GPIO_DIRECTION_IN: gpio_direction = 1;
pub const gpio_direction_GPIO_DIRECTION_OUT: gpio_direction = 2;
#[doc = " \\brief PORT direction settins"]
pub type gpio_direction = ::core::ffi::c_uint;
pub const gpio_port_GPIO_PORTA: gpio_port = 0;
pub const gpio_port_GPIO_PORTB: gpio_port = 1;
pub const gpio_port_GPIO_PORTC: gpio_port = 2;
pub const gpio_port_GPIO_PORTD: gpio_port = 3;
pub const gpio_port_GPIO_PORTE: gpio_port = 4;
#[doc = " \\brief PORT group abstraction"]
pub type gpio_port = ::core::ffi::c_uint;
extern "C" {
    #[doc = " \\brief Port initialization function\n\n Port initialization function should setup the port module based\n on a static configuration file, this function should normally\n not be called directly, but is a part of hal_init()"]
    pub fn _gpio_init();
}
extern "C" {
    #[doc = " \\brief Assert function\n\n This function is used to throw asserts.\n\n \\param[in] condition A condition to be checked; assert is thrown if the given\n                      condition is false\n \\param[in] file File name\n \\param[in] line Line number"]
    pub fn assert(condition: bool, file: *const ::core::ffi::c_char, line: ::core::ffi::c_int);
}
extern "C" {
    #[doc = " \\brief Get current driver version"]
    pub fn gpio_get_version() -> u32;
}
extern "C" {
    #[doc = " \\brief Initializes clock sources"]
    pub fn _sysctrl_init_sources();
}
extern "C" {
    #[doc = " \\brief Initializes Power Manager"]
    pub fn _pm_init();
}
extern "C" {
    #[doc = " \\brief Initialize generators"]
    pub fn _gclk_init_generators();
}
extern "C" {
    #[doc = " \\brief Initialize 32 kHz clock sources"]
    pub fn _osc32kctrl_init_sources();
}
extern "C" {
    #[doc = " \\brief Initialize clock sources"]
    pub fn _oscctrl_init_sources();
}
extern "C" {
    #[doc = " \\brief Initialize clock sources that need input reference clocks"]
    pub fn _sysctrl_init_referenced_generators();
}
extern "C" {
    #[doc = " \\brief Initialize clock sources that need input reference clocks"]
    pub fn _oscctrl_init_referenced_generators();
}
extern "C" {
    #[doc = " \\brief Initialize master clock generator"]
    pub fn _mclk_init();
}
extern "C" {
    #[doc = " \\brief Initialize clock generator"]
    pub fn _lpmcu_misc_regs_init();
}
extern "C" {
    #[doc = " \\brief Initialize clock generator"]
    pub fn _pmc_init();
}
extern "C" {
    #[doc = " \\brief Set performance level\n\n \\param[in] level The performance level to set"]
    pub fn _set_performance_level(level: u8);
}
extern "C" {
    #[doc = " \\brief Initialize the chip"]
    pub fn _init_chip();
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version\n\n \\return Current driver version."]
    pub fn init_get_version() -> u32;
}
#[doc = " \\brief I/O write function pointer type"]
pub type io_write_t = ::core::option::Option<
    unsafe extern "C" fn(io_descr: *mut io_descriptor, buf: *const u8, length: u16) -> i32,
>;
#[doc = " \\brief I/O read function pointer type"]
pub type io_read_t = ::core::option::Option<
    unsafe extern "C" fn(io_descr: *mut io_descriptor, buf: *mut u8, length: u16) -> i32,
>;
#[doc = " \\brief I/O descriptor\n\n The I/O descriptor forward declaration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_descriptor {
    pub write: io_write_t,
    #[doc = " The write function pointer."]
    pub read: io_read_t,
}
#[test]
fn bindgen_test_layout_io_descriptor() {
    const UNINIT: ::core::mem::MaybeUninit<io_descriptor> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<io_descriptor>(),
        16usize,
        concat!("Size of: ", stringify!(io_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<io_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(io_descriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_descriptor),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_descriptor),
            "::",
            stringify!(read)
        )
    );
}
extern "C" {
    #[doc = " \\brief I/O write interface\n\n This function writes up to \\p length of bytes to a given I/O descriptor.\n It returns the number of bytes actually write.\n\n \\param[in] descr  An I/O descriptor to write\n \\param[in] buf    The buffer pointer to story the write data\n \\param[in] length The number of bytes to write\n\n \\return The number of bytes written"]
    pub fn io_write(io_descr: *mut io_descriptor, buf: *const u8, length: u16) -> i32;
}
extern "C" {
    #[doc = " \\brief I/O read interface\n\n This function reads up to \\p length bytes from a given I/O descriptor, and\n stores it in the buffer pointed to by \\p buf. It returns the number of bytes\n actually read.\n\n \\param[in] descr  An I/O descriptor to read\n \\param[in] buf    The buffer pointer to story the read data\n \\param[in] length The number of bytes to read\n\n \\return The number of bytes actually read. This number can be less than the\n         requested length. E.g., in a driver that uses ring buffer for\n         reception, it may depend on the availability of data in the\n         ring buffer."]
    pub fn io_read(io_descr: *mut io_descriptor, buf: *mut u8, length: u16) -> i32;
}
extern "C" {
    #[doc = " \\brief Set the sleep mode of the device and put the MCU to sleep\n\n For an overview of which systems are disabled in sleep for the different\n sleep modes, see the data sheet.\n\n \\param[in] mode Sleep mode to use\n\n \\return The status of a sleep request\n \\retval -1 The requested sleep mode was invalid or not available\n \\retval  0 The operation completed successfully, returned after leaving the\n            sleep"]
    pub fn sleep(mode: u8) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version\n\n \\return Current driver version."]
    pub fn sleep_get_version() -> u32;
}
extern "C" {
    #[doc = " \\brief Initialize external interrupt module\n\n This function does low level external interrupt configuration.\n\n \\param[in] cb The pointer to callback function from external interrupt\n\n \\return Initialization status.\n \\retval -1 External irq module is already initialized\n \\retval 0 The initialization is completed successfully"]
    pub fn _ext_irq_init(cb: ::core::option::Option<unsafe extern "C" fn(pin: u32)>) -> i32;
}
extern "C" {
    #[doc = " \\brief Deinitialize external interrupt module\n\n \\return Initialization status.\n \\retval -1 External irq module is already deinitialized\n \\retval 0 The de-initialization is completed successfully"]
    pub fn _ext_irq_deinit() -> i32;
}
extern "C" {
    #[doc = " \\brief Enable / disable external irq\n\n \\param[in] pin Pin to enable external irq on\n \\param[in] enable True to enable, false to disable\n\n \\return Status of external irq enabling / disabling\n \\retval -1 External irq module can't be enabled / disabled\n \\retval 0 External irq module is enabled / disabled successfully"]
    pub fn _ext_irq_enable(pin: u32, enable: bool) -> i32;
}
#[doc = " \\brief External IRQ callback type"]
pub type ext_irq_cb_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " \\brief Initialize external IRQ component, if any\n\n \\return Initialization status.\n \\retval -1 External IRQ module is already initialized\n \\retval 0 The initialization is completed successfully"]
    pub fn ext_irq_init() -> i32;
}
extern "C" {
    #[doc = " \\brief Deinitialize external IRQ, if any\n\n \\return De-initialization status.\n \\retval -1 External IRQ module is already deinitialized\n \\retval 0 The de-initialization is completed successfully"]
    pub fn ext_irq_deinit() -> i32;
}
extern "C" {
    #[doc = " \\brief Register callback for the given external interrupt\n\n \\param[in] pin Pin to enable external IRQ on\n \\param[in] cb Callback function\n\n \\return Registration status.\n \\retval -1 Passed parameters were invalid\n \\retval 0 The callback registration is completed successfully"]
    pub fn ext_irq_register(pin: u32, cb: ext_irq_cb_t) -> i32;
}
extern "C" {
    #[doc = " \\brief Enable external IRQ\n\n \\param[in] pin Pin to enable external IRQ on\n\n \\return Enabling status.\n \\retval -1 Passed parameters were invalid\n \\retval 0 The enabling is completed successfully"]
    pub fn ext_irq_enable(pin: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief Disable external IRQ\n\n \\param[in] pin Pin to enable external IRQ on\n\n \\return Disabling status.\n \\retval -1 Passed parameters were invalid\n \\retval 0 The disabling is completed successfully"]
    pub fn ext_irq_disable(pin: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version\n\n \\return Current driver version."]
    pub fn ext_irq_get_version() -> u32;
}
#[doc = " \\brief i2c master message structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _i2c_m_msg {
    pub addr: u16,
    pub flags: u16,
    pub len: i32,
    pub buffer: *mut u8,
}
#[test]
fn bindgen_test_layout__i2c_m_msg() {
    const UNINIT: ::core::mem::MaybeUninit<_i2c_m_msg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_i2c_m_msg>(),
        16usize,
        concat!("Size of: ", stringify!(_i2c_m_msg))
    );
    assert_eq!(
        ::core::mem::align_of::<_i2c_m_msg>(),
        8usize,
        concat!("Alignment of ", stringify!(_i2c_m_msg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_m_msg),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_m_msg),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_m_msg),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_m_msg),
            "::",
            stringify!(buffer)
        )
    );
}
#[doc = " \\brief i2c master service"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _i2c_m_service {
    pub msg: _i2c_m_msg,
    pub mode: u16,
    pub trise: u16,
}
#[test]
fn bindgen_test_layout__i2c_m_service() {
    const UNINIT: ::core::mem::MaybeUninit<_i2c_m_service> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_i2c_m_service>(),
        24usize,
        concat!("Size of: ", stringify!(_i2c_m_service))
    );
    assert_eq!(
        ::core::mem::align_of::<_i2c_m_service>(),
        8usize,
        concat!("Alignment of ", stringify!(_i2c_m_service))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_m_service),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_m_service),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trise) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_m_service),
            "::",
            stringify!(trise)
        )
    );
}
#[doc = " \\brief i2c sync master device structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _i2c_m_sync_device {
    pub service: _i2c_m_service,
    pub hw: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout__i2c_m_sync_device() {
    const UNINIT: ::core::mem::MaybeUninit<_i2c_m_sync_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_i2c_m_sync_device>(),
        32usize,
        concat!("Size of: ", stringify!(_i2c_m_sync_device))
    );
    assert_eq!(
        ::core::mem::align_of::<_i2c_m_sync_device>(),
        8usize,
        concat!("Alignment of ", stringify!(_i2c_m_sync_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).service) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_m_sync_device),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_i2c_m_sync_device),
            "::",
            stringify!(hw)
        )
    );
}
extern "C" {
    #[doc = " \\brief Initialize I2C\n\n This function does low level I2C configuration.\n\n \\param[in] i2c_dev The pointer to i2c device structure\n \\param[in] hw The pointer to hardware instance\n\n \\return Return 0 for success and negative value for error"]
    pub fn _i2c_m_sync_init(i2c_dev: *mut _i2c_m_sync_device, hw: *mut ::core::ffi::c_void) -> i32;
}
extern "C" {
    #[doc = " \\brief Deinitialize I2C\n\n \\param[in] i2c_dev The pointer to i2c device structure\n\n \\return Return 0 for success and negative value for error"]
    pub fn _i2c_m_sync_deinit(i2c_dev: *mut _i2c_m_sync_device) -> i32;
}
extern "C" {
    #[doc = " \\brief Enable I2C module\n\n This function does low level I2C enable.\n\n \\param[in] i2c_dev The pointer to i2c device structure\n\n \\return Return 0 for success and negative value for error"]
    pub fn _i2c_m_sync_enable(i2c_dev: *mut _i2c_m_sync_device) -> i32;
}
extern "C" {
    #[doc = " \\brief Disable I2C module\n\n This function does low level I2C disable.\n\n \\param[in] i2c_dev The pointer to i2c device structure\n\n \\return Return 0 for success and negative value for error"]
    pub fn _i2c_m_sync_disable(i2c_dev: *mut _i2c_m_sync_device) -> i32;
}
extern "C" {
    #[doc = " \\brief Transfer data by I2C\n\n This function does low level I2C data transfer.\n\n \\param[in] i2c_dev The pointer to i2c device structure\n \\param[in] msg The pointer to i2c msg structure\n\n \\return Return 0 for success and negative value for error"]
    pub fn _i2c_m_sync_transfer(i2c_dev: *mut _i2c_m_sync_device, msg: *mut _i2c_m_msg) -> i32;
}
extern "C" {
    #[doc = " \\brief Set baud rate of I2C\n\n This function does low level I2C set baud rate.\n\n \\param[in] i2c_dev The pointer to i2c device structure\n \\param[in] clkrate The clock rate(KHz) input to i2c module\n \\param[in] baudrate The demand baud rate(KHz) of i2c module\n\n \\return Return 0 for success and negative value for error"]
    pub fn _i2c_m_sync_set_baudrate(
        i2c_dev: *mut _i2c_m_sync_device,
        clkrate: u32,
        baudrate: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Send send condition on the I2C bus\n\n This function will generate a stop condition on the I2C bus\n\n \\param[in] i2c_dev The pointer to i2c device struct\n\n \\return Return 0 for success and negative value for error"]
    pub fn _i2c_m_sync_send_stop(i2c_dev: *mut _i2c_m_sync_device) -> i32;
}
#[doc = " \\brief I2C descriptor structure, embed i2c_device & i2c_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct i2c_m_sync_desc {
    pub device: _i2c_m_sync_device,
    pub io: io_descriptor,
    pub periph_addr: u16,
}
#[test]
fn bindgen_test_layout_i2c_m_sync_desc() {
    const UNINIT: ::core::mem::MaybeUninit<i2c_m_sync_desc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<i2c_m_sync_desc>(),
        56usize,
        concat!("Size of: ", stringify!(i2c_m_sync_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<i2c_m_sync_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(i2c_m_sync_desc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_m_sync_desc),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_m_sync_desc),
            "::",
            stringify!(io)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).periph_addr) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(i2c_m_sync_desc),
            "::",
            stringify!(periph_addr)
        )
    );
}
extern "C" {
    #[doc = " \\brief Initialize synchronous I2C interface\n\n This function initializes the given I/O descriptor to be used as a\n synchronous I2C interface descriptor.\n It checks if the given hardware is not initialized and if the given hardware\n is permitted to be initialized.\n\n \\param[in] i2c An I2C descriptor, which is used to communicate through I2C\n \\param[in] hw The pointer to hardware instance\n\n \\return Initialization status.\n \\retval -1 The passed parameters were invalid or the interface is already initialized\n \\retval 0 The initialization is completed successfully"]
    pub fn i2c_m_sync_init(i2c: *mut i2c_m_sync_desc, hw: *mut ::core::ffi::c_void) -> i32;
}
extern "C" {
    #[doc = " \\brief Deinitialize I2C interface\n\n This function deinitializes the given I/O descriptor.\n It checks if the given hardware is initialized and if the given hardware is permitted to be deinitialized.\n\n \\param[in] i2c An I2C descriptor, which is used to communicate through I2C\n\n \\return Uninitialization status.\n \\retval -1 The passed parameters were invalid or the interface is already deinitialized\n \\retval 0 The de-initialization is completed successfully"]
    pub fn i2c_m_sync_deinit(i2c: *mut i2c_m_sync_desc) -> i32;
}
extern "C" {
    #[doc = " \\brief Set the peripheral device address\n\n This function sets the next transfer target peripheral I2C device address.\n It takes no effect to any already started access.\n\n \\param[in] i2c An I2C descriptor, which is used to communicate through I2C\n \\param[in] addr The peripheral address to access\n \\param[in] addr_len The peripheral address length, can be I2C_M_TEN or I2C_M_SEVEN\n\n \\return Masked peripheral address. The mask is a maximum 10-bit address, and 10th\n         bit is set if a 10-bit address is used"]
    pub fn i2c_m_sync_set_periphaddr(i2c: *mut i2c_m_sync_desc, addr: i16, addr_len: i32) -> i32;
}
extern "C" {
    #[doc = " \\brief Set baudrate\n\n This function sets the I2C device to the specified baudrate.\n It only takes effect when the hardware is disabled.\n\n \\param[in] i2c An I2C descriptor, which is used to communicate through I2C\n \\param[in] clkrate Unused parameter. Should always be 0\n \\param[in] baudrate The baudrate value set to controller\n\n \\return Whether successfully set the baudrate\n \\retval -1 The passed parameters were invalid or the device is already enabled\n \\retval 0 The baudrate set is completed successfully"]
    pub fn i2c_m_sync_set_baudrate(i2c: *mut i2c_m_sync_desc, clkrate: u32, baudrate: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief Sync version of enable hardware\n\n This function enables the I2C device, and then waits for this enabling operation to be done\n\n \\param[in] i2c An I2C descriptor, which is used to communicate through I2C\n\n \\return Whether successfully enable the device\n \\retval -1 The passed parameters were invalid or the device enable failed\n \\retval 0 The hardware enabling is completed successfully"]
    pub fn i2c_m_sync_enable(i2c: *mut i2c_m_sync_desc) -> i32;
}
extern "C" {
    #[doc = " \\brief Sync version of disable hardware\n\n This function disables the I2C device and then waits for this disabling operation to be done\n\n \\param[in] i2c An I2C descriptor, which is used to communicate through I2C\n\n \\return Whether successfully disable the device\n \\retval -1 The passed parameters were invalid or the device disable failed\n \\retval 0 The hardware disabling is completed successfully"]
    pub fn i2c_m_sync_disable(i2c: *mut i2c_m_sync_desc) -> i32;
}
extern "C" {
    #[doc = " \\brief Sync version of write command to I2C peripheral\n\n This function will write the value to a specified register in the I2C peripheral device and\n then wait for this operation to be done.\n\n The sequence of this routine is\n sta->address(write)->ack->reg address->ack->resta->address(write)->ack->reg value->nack->stt\n\n \\param[in] i2c An I2C descriptor, which is used to communicate through I2C\n \\param[in] reg The internal address/register of the I2C peripheral device\n \\param[in] buffer The buffer holding data to write to the I2C peripheral device\n \\param[in] length The length (in bytes) to write to the I2C peripheral device\n\n \\return Whether successfully write to the device\n \\retval <0 The passed parameters were invalid or write fail\n \\retval 0 Writing to register is completed successfully"]
    pub fn i2c_m_sync_cmd_write(
        i2c: *mut i2c_m_sync_desc,
        reg: u8,
        buffer: *mut u8,
        length: u8,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Sync version of read register value from I2C peripheral\n\n This function will read a byte value from a specified register in the I2C peripheral device and\n then wait for this operation to be done.\n\n The sequence of this routine is\n sta->address(write)->ack->reg address->ack->resta->address(read)->ack->reg value->nack->stt\n\n \\param[in] i2c An I2C descriptor, which is used to communicate through I2C\n \\param[in] reg The internal address/register of the I2C peripheral device\n \\param[in] buffer The buffer to hold the read data from the I2C peripheral device\n \\param[in] length The length (in bytes) to read from the I2C peripheral device\n\n \\return Whether successfully read from the device\n \\retval <0 The passed parameters were invalid or read fail\n \\retval 0 Reading from register is completed successfully"]
    pub fn i2c_m_sync_cmd_read(
        i2c: *mut i2c_m_sync_desc,
        reg: u8,
        buffer: *mut u8,
        length: u8,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Sync version of transfer message to/from the I2C peripheral\n\n This function will transfer a message between the I2C peripheral and the controller.\n This function will wait for the operation to be done.\n\n \\param[in] i2c An I2C descriptor, which is used to communicate through I2C\n \\param[in] msg  An i2c_m_msg struct\n\n \\return The status of the operation\n \\retval 0 Operation completed successfully\n \\retval <0 Operation failed"]
    pub fn i2c_m_sync_transfer(i2c: *mut i2c_m_sync_desc, msg: *mut _i2c_m_msg) -> i32;
}
extern "C" {
    #[doc = " \\brief Sync version of send stop condition on the i2c bus\n\n This function will create a stop condition on the i2c bus to release the bus\n\n \\param[in] i2c An I2C descriptor, which is used to communicate through I2C\n\n \\return The status of the operation\n \\retval 0 Operation completed successfully\n \\retval <0 Operation failed"]
    pub fn i2c_m_sync_send_stop(i2c: *mut i2c_m_sync_desc) -> i32;
}
extern "C" {
    #[doc = " \\brief Return I/O descriptor for this I2C instance\n\n This function will return a I/O instance for this I2C driver instance\n\n \\param[in] i2c_m_sync_desc An I2C descriptor, which is used to communicate through I2C\n \\param[in] io_descriptor A pointer to an I/O descriptor pointer type\n\n \\return Error code\n \\retval 0 No error detected\n \\retval <0 Error code"]
    pub fn i2c_m_sync_get_io_descriptor(
        i2c: *mut i2c_m_sync_desc,
        io: *mut *mut io_descriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version\n\n \\return Current driver version."]
    pub fn i2c_m_sync_get_version() -> u32;
}
#[doc = " \\brief Pointer to function"]
pub type FUNC_PTR = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_msg {
    #[doc = " Pointer to the output data buffer"]
    pub txbuf: *mut u8,
    #[doc = " Pointer to the input data buffer"]
    pub rxbuf: *mut u8,
    #[doc = " Size of the message data in SPI characters"]
    pub size: u32,
}
#[test]
fn bindgen_test_layout_spi_msg() {
    const UNINIT: ::core::mem::MaybeUninit<spi_msg> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<spi_msg>(),
        24usize,
        concat!("Size of: ", stringify!(spi_msg))
    );
    assert_eq!(
        ::core::mem::align_of::<spi_msg>(),
        8usize,
        concat!("Alignment of ", stringify!(spi_msg))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_msg),
            "::",
            stringify!(txbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxbuf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_msg),
            "::",
            stringify!(rxbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_msg),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " Leading edge is rising edge, data sample on leading edge."]
pub const spi_transfer_mode_SPI_MODE_0: spi_transfer_mode = 0;
#[doc = " Leading edge is rising edge, data sample on trailing edge."]
pub const spi_transfer_mode_SPI_MODE_1: spi_transfer_mode = 1;
#[doc = " Leading edge is falling edge, data sample on leading edge."]
pub const spi_transfer_mode_SPI_MODE_2: spi_transfer_mode = 2;
#[doc = " Leading edge is falling edge, data sample on trailing edge."]
pub const spi_transfer_mode_SPI_MODE_3: spi_transfer_mode = 3;
#[doc = "  \\brief SPI transfer modes\n  SPI transfer mode controls clock polarity and clock phase.\n  Mode 0: leading edge is rising edge, data sample on leading edge.\n  Mode 1: leading edge is rising edge, data sample on trailing edge.\n  Mode 2: leading edge is falling edge, data sample on leading edge.\n  Mode 3: leading edge is falling edge, data sample on trailing edge."]
pub type spi_transfer_mode = ::core::ffi::c_uint;
#[doc = " Character size is 8 bit."]
pub const spi_char_size_SPI_CHAR_SIZE_8: spi_char_size = 0;
#[doc = " Character size is 9 bit."]
pub const spi_char_size_SPI_CHAR_SIZE_9: spi_char_size = 1;
#[doc = " Character size is 10 bit."]
pub const spi_char_size_SPI_CHAR_SIZE_10: spi_char_size = 2;
#[doc = " Character size is 11 bit."]
pub const spi_char_size_SPI_CHAR_SIZE_11: spi_char_size = 3;
#[doc = " Character size is 12 bit."]
pub const spi_char_size_SPI_CHAR_SIZE_12: spi_char_size = 4;
#[doc = " Character size is 13 bit."]
pub const spi_char_size_SPI_CHAR_SIZE_13: spi_char_size = 5;
#[doc = " Character size is 14 bit."]
pub const spi_char_size_SPI_CHAR_SIZE_14: spi_char_size = 6;
#[doc = " Character size is 15 bit."]
pub const spi_char_size_SPI_CHAR_SIZE_15: spi_char_size = 7;
#[doc = " Character size is 16 bit."]
pub const spi_char_size_SPI_CHAR_SIZE_16: spi_char_size = 8;
#[doc = "  \\brief SPI character sizes\n  The character size influence the way the data is sent/received.\n  For char size <= 8 data is stored byte by byte.\n  For char size between 9 ~ 16 data is stored in 2-byte length.\n  Note that the default and recommended char size is 8 bit since it's\n  supported by all system."]
pub type spi_char_size = ::core::ffi::c_uint;
#[doc = " MSB goes first."]
pub const spi_data_order_SPI_DATA_ORDER_MSB_1ST: spi_data_order = 0;
#[doc = " LSB goes first."]
pub const spi_data_order_SPI_DATA_ORDER_LSB_1ST: spi_data_order = 1;
#[doc = "  \\brief SPI data order"]
pub type spi_data_order = ::core::ffi::c_uint;
#[doc = " \\brief Transfer descriptor for SPI\n  Transfer descriptor holds TX and RX buffers"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_xfer {
    #[doc = " Pointer to data buffer to TX"]
    pub txbuf: *mut u8,
    #[doc = " Pointer to data buffer to RX"]
    pub rxbuf: *mut u8,
    #[doc = " Size of data characters to TX & RX"]
    pub size: u32,
}
#[test]
fn bindgen_test_layout_spi_xfer() {
    const UNINIT: ::core::mem::MaybeUninit<spi_xfer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<spi_xfer>(),
        24usize,
        concat!("Size of: ", stringify!(spi_xfer))
    );
    assert_eq!(
        ::core::mem::align_of::<spi_xfer>(),
        8usize,
        concat!("Alignment of ", stringify!(spi_xfer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).txbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_xfer),
            "::",
            stringify!(txbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rxbuf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_xfer),
            "::",
            stringify!(rxbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_xfer),
            "::",
            stringify!(size)
        )
    );
}
#[doc = " SPI generic driver."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_dev {
    #[doc = " Pointer to the hardware base or private data for special device."]
    pub prvt: *mut ::core::ffi::c_void,
    #[doc = " Reference start of sync/async variables"]
    pub sync_async_misc: [u32; 1usize],
}
#[test]
fn bindgen_test_layout_spi_dev() {
    const UNINIT: ::core::mem::MaybeUninit<spi_dev> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<spi_dev>(),
        16usize,
        concat!("Size of: ", stringify!(spi_dev))
    );
    assert_eq!(
        ::core::mem::align_of::<spi_dev>(),
        8usize,
        concat!("Alignment of ", stringify!(spi_dev))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prvt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_dev),
            "::",
            stringify!(prvt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sync_async_misc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_dev),
            "::",
            stringify!(sync_async_misc)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Calculate the baudrate value for hardware to use to set baudrate\n  \\param[in, out] dev Pointer to the SPI device instance.\n  \\param[in] clk Clock frequency (Hz) for baudrate generation.\n  \\param[in] baud Target baudrate (bps).\n  \\return Error or baudrate value.\n  \\retval >0 Baudrate value.\n  \\retval ERR_INVALID_ARG Calculation fail."]
    pub fn _spi_calc_baud_val(dev: *mut spi_dev, clk: u32, baud: u32) -> i32;
}
#[doc = " SPI driver to support sync HAL"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _spi_sync_dev {
    #[doc = " Pointer to the hardware base or private data for special device."]
    pub prvt: *mut ::core::ffi::c_void,
    #[doc = " Data size, number of bytes for each character"]
    pub char_size: u8,
    #[doc = " Dummy byte used in master mode when reading the slave"]
    pub dummy_byte: u16,
}
#[test]
fn bindgen_test_layout__spi_sync_dev() {
    const UNINIT: ::core::mem::MaybeUninit<_spi_sync_dev> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_spi_sync_dev>(),
        16usize,
        concat!("Size of: ", stringify!(_spi_sync_dev))
    );
    assert_eq!(
        ::core::mem::align_of::<_spi_sync_dev>(),
        8usize,
        concat!("Alignment of ", stringify!(_spi_sync_dev))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prvt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_spi_sync_dev),
            "::",
            stringify!(prvt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).char_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_spi_sync_dev),
            "::",
            stringify!(char_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dummy_byte) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_spi_sync_dev),
            "::",
            stringify!(dummy_byte)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Initialize SPI for access without interrupts\n  It will load default hardware configuration and software struct.\n  \\param[in, out] dev Pointer to the SPI device instance.\n  \\param[in] hw Pointer to the hardware base.\n  \\return Operation status.\n  \\retval ERR_INVALID_ARG Input parameter problem.\n  \\retval ERR_BUSY SPI hardware not ready (resetting).\n  \\retval ERR_DENIED SPI has been enabled.\n  \\retval 0 Operation done successfully."]
    pub fn _spi_m_sync_init(dev: *mut _spi_sync_dev, hw: *mut ::core::ffi::c_void) -> i32;
}
extern "C" {
    #[doc = "  \\brief Deinitialize SPI\n  Disable, reset the hardware and the software struct.\n  \\param[in, out] dev Pointer to the SPI device instance.\n  \\return Operation status.\n  \\retval 0 Operation done successfully."]
    pub fn _spi_m_sync_deinit(dev: *mut _spi_sync_dev) -> i32;
}
extern "C" {
    #[doc = "  \\brief Enable SPI for access without interrupts\n  \\param[in, out] dev Pointer to the SPI device instance.\n  \\return Operation status.\n  \\retval ERR_BUSY SPI hardware not ready (resetting).\n  \\retval 0 Operation done successfully."]
    pub fn _spi_m_sync_enable(dev: *mut _spi_sync_dev) -> i32;
}
extern "C" {
    #[doc = "  \\brief Disable SPI for access without interrupts\n  Disable SPI. Deactivate all CS pins if works as master.\n  \\param[in, out] dev Pointer to the SPI device instance.\n  \\return Operation status.\n  \\retval 0 Operation done successfully."]
    pub fn _spi_m_sync_disable(dev: *mut _spi_sync_dev) -> i32;
}
extern "C" {
    #[doc = "  \\brief Set SPI transfer mode\n  Set SPI transfer mode (\\ref spi_transfer_mode),\n  which controls clock polarity and clock phase.\n  Mode 0: leading edge is rising edge, data sample on leading edge.\n  Mode 1: leading edge is rising edge, data sample on trailing edge.\n  Mode 2: leading edge is falling edge, data sample on leading edge.\n  Mode 3: leading edge is falling edge, data sample on trailing edge.\n  \\param[in, out] dev Pointer to the SPI device instance.\n  \\param[in] mode The SPI transfer mode.\n  \\return Operation status.\n  \\retval ERR_BUSY SPI is not ready to accept new setting.\n  \\retval 0 Operation done successfully."]
    pub fn _spi_m_sync_set_mode(dev: *mut _spi_sync_dev, mode: spi_transfer_mode) -> i32;
}
extern "C" {
    #[doc = "  \\brief Set SPI baudrate\n  \\param[in, out] dev Pointer to the SPI device instance.\n  \\param[in] baud_val The SPI baudrate value, see \\ref _spi_calc_baud_val() on\n                  how it's generated.\n  \\return Operation status.\n  \\retval ERR_BUSY SPI is not ready to accept new setting.\n  \\retval 0 Operation done successfully."]
    pub fn _spi_m_sync_set_baudrate(dev: *mut _spi_sync_dev, baud_val: u32) -> i32;
}
extern "C" {
    #[doc = "  \\brief Set SPI char size\n  \\param[in, out] dev Pointer to the SPI device instance.\n  \\param[in] char_size The character size, see \\ref spi_char_size.\n  \\return Operation status.\n  \\retval ERR_INVALID_ARG The character size is not supported.\n  \\retval ERR_BUSY SPI is not ready to accept new setting.\n  \\retval 0 Operation done successfully."]
    pub fn _spi_m_sync_set_char_size(dev: *mut _spi_sync_dev, char_size: spi_char_size) -> i32;
}
extern "C" {
    #[doc = "  \\brief Set SPI data order\n  \\param[in, out] dev Pointer to the SPI device instance.\n  \\param[in] dord SPI data order (LSB/MSB first).\n  \\return Operation status.\n  \\retval ERR_INVALID_ARG The character size is not supported.\n  \\retval ERR_BUSY SPI is not ready to accept new setting.\n  \\retval 0 Operation done successfully."]
    pub fn _spi_m_sync_set_data_order(dev: *mut _spi_sync_dev, dord: spi_data_order) -> i32;
}
extern "C" {
    #[doc = "  \\brief Transfer the whole message without interrupt\n  Transfer the message, it will keep waiting until the message finish or\n  error.\n  \\param[in, out] dev Pointer to the SPI device instance.\n  \\param[in] msg Pointer to the message instance to process.\n  \\return Error or number of characters transferred.\n  \\retval ERR_BUSY SPI hardware is not ready to start transfer (not\n                   enabled, busy applying settings, ...).\n  \\retval SPI_ERR_OVERFLOW Overflow error.\n  \\retval >=0 Number of characters transferred."]
    pub fn _spi_m_sync_trans(dev: *mut _spi_sync_dev, msg: *const spi_msg) -> i32;
}
#[doc = " \\brief SPI HAL driver struct for polling mode\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_m_sync_descriptor {
    pub func: *mut _spi_m_sync_hpl_interface,
    #[doc = " SPI device instance"]
    pub dev: _spi_sync_dev,
    #[doc = " I/O read/write"]
    pub io: io_descriptor,
    #[doc = " Flags for HAL driver"]
    pub flags: u16,
}
#[test]
fn bindgen_test_layout_spi_m_sync_descriptor() {
    const UNINIT: ::core::mem::MaybeUninit<spi_m_sync_descriptor> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<spi_m_sync_descriptor>(),
        48usize,
        concat!("Size of: ", stringify!(spi_m_sync_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<spi_m_sync_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(spi_m_sync_descriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_m_sync_descriptor),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_m_sync_descriptor),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_m_sync_descriptor),
            "::",
            stringify!(io)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_m_sync_descriptor),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " \\brief Set the SPI HAL instance function pointer for HPL APIs.\n\n  Set SPI HAL instance function pointer for HPL APIs.\n\n  \\param[in] spi Pointer to the HAL SPI instance.\n  \\param[in] func Pointer to the HPL api structure.\n"]
    pub fn spi_m_sync_set_func_ptr(spi: *mut spi_m_sync_descriptor, func: *mut ::core::ffi::c_void);
}
extern "C" {
    #[doc = " \\brief Initialize SPI HAL instance and hardware for polling mode\n\n  Initialize SPI HAL with polling mode.\n\n  \\param[in] spi Pointer to the HAL SPI instance.\n  \\param[in] hw Pointer to the hardware base.\n\n  \\return Operation status.\n  \\retval ERR_NONE Success.\n  \\retval ERR_INVALID_DATA Error, initialized."]
    pub fn spi_m_sync_init(spi: *mut spi_m_sync_descriptor, hw: *mut ::core::ffi::c_void) -> i32;
}
extern "C" {
    #[doc = " \\brief Deinitialize the SPI HAL instance and hardware\n\n  Abort transfer, disable and reset SPI, deinit software.\n\n  \\param[in] spi Pointer to the HAL SPI instance.\n\n  \\return Operation status.\n  \\retval ERR_NONE Success.\n  \\retval <0 Error code."]
    pub fn spi_m_sync_deinit(spi: *mut spi_m_sync_descriptor);
}
extern "C" {
    #[doc = " \\brief Enable SPI\n\n  \\param[in] spi Pointer to the HAL SPI instance.\n\n  \\return Operation status.\n  \\retval ERR_NONE Success.\n  \\retval <0 Error code."]
    pub fn spi_m_sync_enable(spi: *mut spi_m_sync_descriptor);
}
extern "C" {
    #[doc = " \\brief Disable SPI\n\n  \\param[in] spi Pointer to the HAL SPI instance.\n\n  \\return Operation status.\n  \\retval ERR_NONE Success.\n  \\retval <0 Error code."]
    pub fn spi_m_sync_disable(spi: *mut spi_m_sync_descriptor);
}
extern "C" {
    #[doc = " \\brief Set SPI baudrate\n\n  Works if SPI is initialized as master, it sets the baudrate.\n\n  \\param[in] spi Pointer to the HAL SPI instance.\n  \\param[in] baud_val The target baudrate value\n                  (see \"baudrate calculation\" for calculating the value).\n\n  \\return Operation status.\n  \\retval ERR_NONE Success.\n  \\retval ERR_BUSY Busy\n  \\retval ERR_INVALID_ARG The baudrate is not supported."]
    pub fn spi_m_sync_set_baudrate(spi: *mut spi_m_sync_descriptor, baud_val: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief Set SPI mode\n\n  Set the SPI transfer mode (\\ref spi_transfer_mode),\n  which controls the clock polarity and clock phase:\n  - Mode 0: leading edge is rising edge, data sample on leading edge.\n  - Mode 1: leading edge is rising edge, data sample on trailing edge.\n  - Mode 2: leading edge is falling edge, data sample on leading edge.\n  - Mode 3: leading edge is falling edge, data sample on trailing edge.\n\n  \\param[in] spi Pointer to the HAL SPI instance.\n  \\param[in] mode The mode (0~3).\n\n  \\return Operation status.\n  \\retval ERR_NONE Success.\n  \\retval ERR_BUSY Busy\n  \\retval ERR_INVALID_ARG The mode is not supported."]
    pub fn spi_m_sync_set_mode(spi: *mut spi_m_sync_descriptor, mode: spi_transfer_mode) -> i32;
}
extern "C" {
    #[doc = " \\brief Set SPI transfer character size in number of bits\n\n  The character size (\\ref spi_char_size) influence the way the data is\n  sent/received.\n  For char size <= 8-bit, data is stored byte by byte.\n  For char size between 9-bit ~ 16-bit, data is stored in 2-byte length.\n  Note that the default and recommended char size is 8-bit since it's\n  supported by all system.\n\n  \\param[in] spi Pointer to the HAL SPI instance.\n  \\param[in] char_size The char size (~16, recommended 8).\n\n  \\return Operation status.\n  \\retval ERR_NONE Success.\n  \\retval ERR_BUSY Busy\n  \\retval ERR_INVALID_ARG The char size is not supported."]
    pub fn spi_m_sync_set_char_size(
        spi: *mut spi_m_sync_descriptor,
        char_size: spi_char_size,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Set SPI transfer data order\n\n  \\param[in] spi Pointer to the HAL SPI instance.\n  \\param[in] dord The data order: send LSB/MSB first.\n\n  \\return Operation status.\n  \\retval ERR_NONE Success.\n  \\retval ERR_BUSY Busy\n  \\retval ERR_INVALID_ARG The data order is not supported."]
    pub fn spi_m_sync_set_data_order(spi: *mut spi_m_sync_descriptor, dord: spi_data_order) -> i32;
}
extern "C" {
    #[doc = " \\brief Perform the SPI data transfer (TX and RX) in polling way\n\n  Activate CS, do TX and RX and deactivate CS. It blocks.\n\n  \\param[in, out] spi Pointer to the HAL SPI instance.\n  \\param[in] xfer Pointer to the transfer information (\\ref spi_xfer).\n\n  \\retval size Success.\n  \\retval >=0 Timeout, with number of characters transferred.\n  \\retval ERR_BUSY SPI is busy"]
    pub fn spi_m_sync_transfer(spi: *mut spi_m_sync_descriptor, xfer: *const spi_xfer) -> i32;
}
extern "C" {
    #[doc = " \\brief Return the I/O descriptor for this SPI instance\n\n This function will return an I/O instance for this SPI driver instance.\n\n \\param[in] spi An SPI master descriptor, which is used to communicate through\n                SPI\n \\param[in, out] io A pointer to an I/O descriptor pointer type\n\n \\retval ERR_NONE"]
    pub fn spi_m_sync_get_io_descriptor(
        spi: *mut spi_m_sync_descriptor,
        io: *mut *mut io_descriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version\n\n  \\return Current driver version."]
    pub fn spi_m_sync_get_version() -> u32;
}
#[doc = " \\brief USART flow control state"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union usart_flow_control_state {
    pub bit: usart_flow_control_state__bindgen_ty_1,
    pub value: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usart_flow_control_state__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
}
#[test]
fn bindgen_test_layout_usart_flow_control_state__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<usart_flow_control_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(usart_flow_control_state__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<usart_flow_control_state__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(usart_flow_control_state__bindgen_ty_1)
        )
    );
}
impl usart_flow_control_state__bindgen_ty_1 {
    #[inline]
    pub fn cts(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_cts(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn rts(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_rts(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn unavailable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_unavailable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cts: u8,
        rts: u8,
        unavailable: u8,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let cts: u8 = unsafe { ::core::mem::transmute(cts) };
            cts as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let rts: u8 = unsafe { ::core::mem::transmute(rts) };
            rts as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let unavailable: u8 = unsafe { ::core::mem::transmute(unavailable) };
            unavailable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 5u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_usart_flow_control_state() {
    const UNINIT: ::core::mem::MaybeUninit<usart_flow_control_state> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usart_flow_control_state>(),
        1usize,
        concat!("Size of: ", stringify!(usart_flow_control_state))
    );
    assert_eq!(
        ::core::mem::align_of::<usart_flow_control_state>(),
        1usize,
        concat!("Alignment of ", stringify!(usart_flow_control_state))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usart_flow_control_state),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usart_flow_control_state),
            "::",
            stringify!(value)
        )
    );
}
pub const usart_baud_rate_mode_USART_BAUDRATE_ASYNCH_ARITHMETIC: usart_baud_rate_mode = 0;
pub const usart_baud_rate_mode_USART_BAUDRATE_ASYNCH_FRACTIONAL: usart_baud_rate_mode = 1;
pub const usart_baud_rate_mode_USART_BAUDRATE_SYNCH: usart_baud_rate_mode = 2;
#[doc = " \\brief USART baud rate mode"]
pub type usart_baud_rate_mode = ::core::ffi::c_uint;
pub const usart_data_order_USART_DATA_ORDER_MSB: usart_data_order = 0;
pub const usart_data_order_USART_DATA_ORDER_LSB: usart_data_order = 1;
#[doc = " \\brief USART data order"]
pub type usart_data_order = ::core::ffi::c_uint;
pub const usart_mode_USART_MODE_ASYNCHRONOUS: usart_mode = 0;
pub const usart_mode_USART_MODE_SYNCHRONOUS: usart_mode = 1;
#[doc = " \\brief USART mode"]
pub type usart_mode = ::core::ffi::c_uint;
pub const usart_parity_USART_PARITY_EVEN: usart_parity = 0;
pub const usart_parity_USART_PARITY_ODD: usart_parity = 1;
pub const usart_parity_USART_PARITY_NONE: usart_parity = 2;
pub const usart_parity_USART_PARITY_SPACE: usart_parity = 3;
pub const usart_parity_USART_PARITY_MARK: usart_parity = 4;
#[doc = " \\brief USART parity"]
pub type usart_parity = ::core::ffi::c_uint;
pub const usart_stop_bits_USART_STOP_BITS_ONE: usart_stop_bits = 0;
pub const usart_stop_bits_USART_STOP_BITS_TWO: usart_stop_bits = 1;
pub const usart_stop_bits_USART_STOP_BITS_ONE_P_FIVE: usart_stop_bits = 2;
#[doc = " \\brief USART stop bits mode"]
pub type usart_stop_bits = ::core::ffi::c_uint;
pub const usart_character_size_USART_CHARACTER_SIZE_8BITS: usart_character_size = 0;
pub const usart_character_size_USART_CHARACTER_SIZE_9BITS: usart_character_size = 1;
pub const usart_character_size_USART_CHARACTER_SIZE_5BITS: usart_character_size = 5;
pub const usart_character_size_USART_CHARACTER_SIZE_6BITS: usart_character_size = 6;
pub const usart_character_size_USART_CHARACTER_SIZE_7BITS: usart_character_size = 7;
#[doc = " \\brief USART character size"]
pub type usart_character_size = ::core::ffi::c_uint;
#[doc = " \\brief USART descriptor device structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _usart_sync_device {
    pub hw: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout__usart_sync_device() {
    const UNINIT: ::core::mem::MaybeUninit<_usart_sync_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_usart_sync_device>(),
        8usize,
        concat!("Size of: ", stringify!(_usart_sync_device))
    );
    assert_eq!(
        ::core::mem::align_of::<_usart_sync_device>(),
        8usize,
        concat!("Alignment of ", stringify!(_usart_sync_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_usart_sync_device),
            "::",
            stringify!(hw)
        )
    );
}
extern "C" {
    #[doc = " \\brief Initialize synchronous USART\n\n This function does low level USART configuration.\n\n \\param[in] device The pointer to USART device instance\n \\param[in] hw The pointer to hardware instance\n\n \\return Initialization status"]
    pub fn _usart_sync_init(device: *mut _usart_sync_device, hw: *mut ::core::ffi::c_void) -> i32;
}
extern "C" {
    #[doc = " \\brief Deinitialize USART\n\n This function closes the given USART by disabling its clock.\n\n \\param[in] device The pointer to USART device instance"]
    pub fn _usart_sync_deinit(device: *mut _usart_sync_device);
}
extern "C" {
    #[doc = " \\brief Enable usart module\n\n This function will enable the usart module\n\n \\param[in] device The pointer to USART device instance"]
    pub fn _usart_sync_enable(device: *mut _usart_sync_device);
}
extern "C" {
    #[doc = " \\brief Disable usart module\n\n This function will disable the usart module\n\n \\param[in] device The pointer to USART device instance"]
    pub fn _usart_sync_disable(device: *mut _usart_sync_device);
}
extern "C" {
    #[doc = " \\brief Calculate baud rate register value\n\n \\param[in] baud Required baud rate\n \\param[in] clock_rate clock frequency\n \\param[in] samples The number of samples\n \\param[in] mode USART mode\n \\param[in] fraction A fraction value\n\n \\return Calculated baud rate register value"]
    pub fn _usart_sync_calculate_baud_rate(
        baud: u32,
        clock_rate: u32,
        samples: u8,
        mode: usart_baud_rate_mode,
        fraction: u8,
    ) -> u16;
}
extern "C" {
    #[doc = " \\brief Set baud rate\n\n \\param[in] device The pointer to USART device instance\n \\param[in] baud_rate A baud rate to set"]
    pub fn _usart_sync_set_baud_rate(device: *mut _usart_sync_device, baud_rate: u32);
}
extern "C" {
    #[doc = " \\brief Set data order\n\n \\param[in] device The pointer to USART device instance\n \\param[in] order A data order to set"]
    pub fn _usart_sync_set_data_order(device: *mut _usart_sync_device, order: usart_data_order);
}
extern "C" {
    #[doc = " \\brief Set mode\n\n \\param[in] device The pointer to USART device instance\n \\param[in] mode A mode to set"]
    pub fn _usart_sync_set_mode(device: *mut _usart_sync_device, mode: usart_mode);
}
extern "C" {
    #[doc = " \\brief Set parity\n\n \\param[in] device The pointer to USART device instance\n \\param[in] parity A parity to set"]
    pub fn _usart_sync_set_parity(device: *mut _usart_sync_device, parity: usart_parity);
}
extern "C" {
    #[doc = " \\brief Set stop bits mode\n\n \\param[in] device The pointer to USART device instance\n \\param[in] stop_bits A stop bits mode to set"]
    pub fn _usart_sync_set_stop_bits(device: *mut _usart_sync_device, stop_bits: usart_stop_bits);
}
extern "C" {
    #[doc = " \\brief Set character size\n\n \\param[in] device The pointer to USART device instance\n \\param[in] size A character size to set"]
    pub fn _usart_sync_set_character_size(
        device: *mut _usart_sync_device,
        size: usart_character_size,
    );
}
extern "C" {
    #[doc = " \\brief Retrieve usart status\n\n \\param[in] device The pointer to USART device instance"]
    pub fn _usart_sync_get_status(device: *const _usart_sync_device) -> u32;
}
extern "C" {
    #[doc = " \\brief Write a byte to the given USART instance\n\n \\param[in] device The pointer to USART device instance\n \\param[in] data Data to write"]
    pub fn _usart_sync_write_byte(device: *mut _usart_sync_device, data: u8);
}
extern "C" {
    #[doc = " \\brief Read a byte from the given USART instance\n\n \\param[in] device The pointer to USART device instance\n \\param[in] data Data to write\n\n \\return Data received via USART interface."]
    pub fn _usart_sync_read_byte(device: *const _usart_sync_device) -> u8;
}
extern "C" {
    #[doc = " \\brief Check if USART is ready to send next byte\n\n \\param[in] device The pointer to USART device instance\n\n \\return Status of the ready check.\n \\retval true if the USART is ready to send next byte\n \\retval false if the USART is not ready to send next byte"]
    pub fn _usart_sync_is_ready_to_send(device: *const _usart_sync_device) -> bool;
}
extern "C" {
    #[doc = " \\brief Check if USART transmitter has sent the byte\n\n \\param[in] device The pointer to USART device instance\n\n \\return Status of the ready check.\n \\retval true if the USART transmitter has sent the byte\n \\retval false if the USART transmitter has not send the byte"]
    pub fn _usart_sync_is_transmit_done(device: *const _usart_sync_device) -> bool;
}
extern "C" {
    #[doc = " \\brief Check if there is data received by USART\n\n \\param[in] device The pointer to USART device instance\n\n \\return Status of the data received check.\n \\retval true if the USART has received a byte\n \\retval false if the USART has not received a byte"]
    pub fn _usart_sync_is_byte_received(device: *const _usart_sync_device) -> bool;
}
extern "C" {
    #[doc = " \\brief Set the state of flow control pins\n\n \\param[in] device The pointer to USART device instance\n \\param[in] state - A state of flow control pins to set"]
    pub fn _usart_sync_set_flow_control_state(
        device: *mut _usart_sync_device,
        state: usart_flow_control_state,
    );
}
extern "C" {
    #[doc = " \\brief Retrieve the state of flow control pins\n\n This function retrieves the of flow control pins.\n\n \\return USART_FLOW_CONTROL_STATE_UNAVAILABLE."]
    pub fn _usart_sync_get_flow_control_state(
        device: *const _usart_sync_device,
    ) -> usart_flow_control_state;
}
extern "C" {
    #[doc = " \\brief Retrieve ordinal number of the given USART hardware instance\n\n \\param[in] device The pointer to USART device instance\n\n \\return The ordinal number of the given USART hardware instance"]
    pub fn _usart_sync_get_hardware_index(device: *const _usart_sync_device) -> u8;
}
#[doc = " \\brief Synchronous USART descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct usart_sync_descriptor {
    pub io: io_descriptor,
    pub device: _usart_sync_device,
}
#[test]
fn bindgen_test_layout_usart_sync_descriptor() {
    const UNINIT: ::core::mem::MaybeUninit<usart_sync_descriptor> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<usart_sync_descriptor>(),
        24usize,
        concat!("Size of: ", stringify!(usart_sync_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<usart_sync_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(usart_sync_descriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(usart_sync_descriptor),
            "::",
            stringify!(io)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).device) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(usart_sync_descriptor),
            "::",
            stringify!(device)
        )
    );
}
extern "C" {
    #[doc = " \\brief Initialize USART interface\n\n This function initializes the given I/O descriptor to be used\n as USART interface descriptor.\n It checks if the given hardware is not initialized and\n if the given hardware is permitted to be initialized.\n\n \\param[out] descr A USART descriptor which is used to communicate via USART\n \\param[in] hw The pointer to hardware instance\n \\param[in] func The pointer to as set of functions pointers\n\n \\return Initialization status."]
    pub fn usart_sync_init(
        descr: *mut usart_sync_descriptor,
        hw: *mut ::core::ffi::c_void,
        func: *mut ::core::ffi::c_void,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Deinitialize USART interface\n\n This function deinitializes the given I/O descriptor.\n It checks if the given hardware is initialized and\n if the given hardware is permitted to be deinitialized.\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n\n \\return De-initialization status."]
    pub fn usart_sync_deinit(descr: *mut usart_sync_descriptor) -> i32;
}
extern "C" {
    #[doc = " \\brief Enable USART interface\n\n Enables the USART interface\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n\n \\return Enabling status."]
    pub fn usart_sync_enable(descr: *mut usart_sync_descriptor) -> i32;
}
extern "C" {
    #[doc = " \\brief Disable USART interface\n\n Disables the USART interface\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n\n \\return Disabling status."]
    pub fn usart_sync_disable(descr: *mut usart_sync_descriptor) -> i32;
}
extern "C" {
    #[doc = " \\brief Retrieve I/O descriptor\n\n This function retrieves the I/O descriptor of the given USART descriptor.\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n \\param[out] io An I/O descriptor to retrieve\n\n \\return The status of the I/O descriptor retrieving."]
    pub fn usart_sync_get_io_descriptor(
        descr: *mut usart_sync_descriptor,
        io: *mut *mut io_descriptor,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Specify action for flow control pins\n\n This function sets the action (or state) for the flow control pins\n if the flow control is enabled.\n It sets the state of flow control pins only if the automatic support of\n the flow control is not supported by the hardware.\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n \\param[in] state A state to set the flow control pins\n\n \\return The status of flow control action setup."]
    pub fn usart_sync_set_flow_control(
        descr: *mut usart_sync_descriptor,
        state: usart_flow_control_state,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Set USART baud rate\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n \\param[in] baud_rate A baud rate to set\n\n \\return The status of baud rate setting."]
    pub fn usart_sync_set_baud_rate(descr: *mut usart_sync_descriptor, baud_rate: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief Set USART data order\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n \\param[in] data_order A data order to set\n\n \\return The status of data order setting."]
    pub fn usart_sync_set_data_order(
        descr: *mut usart_sync_descriptor,
        data_order: usart_data_order,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Set USART mode\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n \\param[in] mode A mode to set\n\n \\return The status of mode setting."]
    pub fn usart_sync_set_mode(descr: *mut usart_sync_descriptor, mode: usart_mode) -> i32;
}
extern "C" {
    #[doc = " \\brief Set USART parity\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n \\param[in] parity A parity to set\n\n \\return The status of parity setting."]
    pub fn usart_sync_set_parity(descr: *mut usart_sync_descriptor, parity: usart_parity) -> i32;
}
extern "C" {
    #[doc = " \\brief Set USART stop bits\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n \\param[in] stop_bits Stop bits to set\n\n \\return The status of stop bits setting."]
    pub fn usart_sync_set_stopbits(
        descr: *mut usart_sync_descriptor,
        stop_bits: usart_stop_bits,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Set USART character size\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n \\param[in] size A character size to set\n\n \\return The status of character size setting."]
    pub fn usart_sync_set_character_size(
        descr: *mut usart_sync_descriptor,
        size: usart_character_size,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Retrieve the state of flow control pins\n\n This function retrieves the of flow control pins\n if the flow control is enabled.\n Function can return USART_FLOW_CONTROL_STATE_UNAVAILABLE in case\n if the flow control is done by the hardware\n and the pins state cannot be read out.\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n \\param[out] state The state of flow control pins\n\n \\return The status of flow control state reading."]
    pub fn usart_sync_flow_control_status(
        descr: *const usart_sync_descriptor,
        state: *mut usart_flow_control_state,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief Check if the USART transmitter is empty\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n\n \\return The status of USART TX empty checking.\n \\retval 0 The USART transmitter is not empty\n \\retval 1 The USART transmitter is empty"]
    pub fn usart_sync_is_tx_empty(descr: *const usart_sync_descriptor) -> i32;
}
extern "C" {
    #[doc = " \\brief Check if the USART receiver is not empty\n\n \\param[in] descr A USART descriptor which is used to communicate via USART\n\n \\return The status of USART RX empty checking.\n \\retval 1 The USART receiver is not empty\n \\retval 0 The USART receiver is empty"]
    pub fn usart_sync_is_rx_not_empty(descr: *const usart_sync_descriptor) -> i32;
}
extern "C" {
    #[doc = " \\brief Retrieve the current driver version\n\n \\return Current driver version."]
    pub fn usart_sync_get_version() -> u32;
}
#[doc = " \\brief SLCD sync device structure\n\n The SLCD device structure forward declaration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _slcd_sync_device {
    #[doc = "< Hardware module instance handler"]
    pub hw: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout__slcd_sync_device() {
    const UNINIT: ::core::mem::MaybeUninit<_slcd_sync_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_slcd_sync_device>(),
        8usize,
        concat!("Size of: ", stringify!(_slcd_sync_device))
    );
    assert_eq!(
        ::core::mem::align_of::<_slcd_sync_device>(),
        8usize,
        concat!("Alignment of ", stringify!(_slcd_sync_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_slcd_sync_device),
            "::",
            stringify!(hw)
        )
    );
}
extern "C" {
    #[doc = " \\brief              Initialize SLCD Device Descriptor\n\n \\param[in] desc     SLCD descriptor to be initialized\n \\param[in] hw       The pointer to hardware instance"]
    pub fn _slcd_sync_init(dev: *mut _slcd_sync_device, hw: *mut ::core::ffi::c_void) -> i32;
}
extern "C" {
    #[doc = " \\brief              Deinitialize SLCD Device Descriptor\n\n \\param[in] desc     SLCD device descriptor to be deinitialized"]
    pub fn _slcd_sync_deinit(dev: *mut _slcd_sync_device) -> i32;
}
extern "C" {
    #[doc = " \\brief              Enable SLCD driver\n\n \\param[in] dev      SLCD device descriptor to be enabled"]
    pub fn _slcd_sync_enable(dev: *mut _slcd_sync_device) -> i32;
}
extern "C" {
    #[doc = " \\brief              Disable SLCD driver\n\n \\param[in] dev      SLCD Device descriptor to be disabled"]
    pub fn _slcd_sync_disable(dev: *mut _slcd_sync_device) -> i32;
}
extern "C" {
    #[doc = " \\brief               Turn on a Segment\n\n \\param[in] dev       SLCD Device descriptor\n \\param[in] seg       Segment id\n                      value is (common terminals << 16 | segment terminal)"]
    pub fn _slcd_sync_seg_on(dev: *mut _slcd_sync_device, seg: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief               Turn off a Segment\n\n \\param[in] dev       SLCD Device descriptor\n \\param[in] seg       Segment id\n                      value is (common terminals << 16 | segment terminal)"]
    pub fn _slcd_sync_seg_off(dev: *mut _slcd_sync_device, seg: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief               Blink a Segment\n\n \\param[in] dev       SLCD Device descriptor\n \\param[in] seg       Segment index\n                      value is (common terminals << 16 | segment terminal)\n \\param[in] period  Blink period, unit is million second"]
    pub fn _slcd_sync_seg_blink(dev: *mut _slcd_sync_device, seg: u32, period: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief              Displays a character\n\n \\param[in] dev       SLCD Device descriptor\n \\param[in] character Character to be displayed\n \\param[in] index     Index of Character Mapping Group"]
    pub fn _slcd_sync_write_char(dev: *mut _slcd_sync_device, character: u8, index: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief               Start animation play by a segment array\n\n \\param[in] dev       SLCD Device descriptor\n \\param[in] segs      Segment array\n \\param[in] len       Length of the segment array\n \\param[in] period    Period(milliseconds) of the each segment to animation"]
    pub fn _slcd_sync_start_animation(
        dev: *mut _slcd_sync_device,
        segs: *const u32,
        len: u32,
        period: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief               Stop animation play by a segment array\n\n \\param[in] dev       SLCD device descriptor\n \\param[in] segs      Segment array\n \\param[in] len       Length of the segment array"]
    pub fn _slcd_sync_stop_animation(
        dev: *mut _slcd_sync_device,
        segs: *const u32,
        len: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief               Set animation Frequency\n\n \\param[in] dev       SLCD Device descriptor\n \\param[in] period    Period(million second) of the each segment to animation"]
    pub fn _slcd_sync_set_animation_period(dev: *mut _slcd_sync_device, period: u32) -> i32;
}
#[doc = " \\addtogroup doc_driver_hal_slcd_sync\n\n@{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slcd_sync_descriptor {
    #[doc = "< SLCD HPL device descriptor"]
    pub dev: _slcd_sync_device,
}
#[test]
fn bindgen_test_layout_slcd_sync_descriptor() {
    const UNINIT: ::core::mem::MaybeUninit<slcd_sync_descriptor> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<slcd_sync_descriptor>(),
        8usize,
        concat!("Size of: ", stringify!(slcd_sync_descriptor))
    );
    assert_eq!(
        ::core::mem::align_of::<slcd_sync_descriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(slcd_sync_descriptor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slcd_sync_descriptor),
            "::",
            stringify!(dev)
        )
    );
}
extern "C" {
    #[doc = " \\brief               Initialize SLCD Descriptor\n\n \\param[in] descr     SLCD descriptor to be initialized\n \\param[in] hw        The pointer to hardware instance"]
    pub fn slcd_sync_init(descr: *mut slcd_sync_descriptor, hw: *mut ::core::ffi::c_void) -> i32;
}
extern "C" {
    #[doc = " \\brief               Deinitialize SLCD Descriptor\n\n \\param[in] descr      SLCD descriptor to be deinitialized"]
    pub fn slcd_sync_deinit(descr: *mut slcd_sync_descriptor) -> i32;
}
extern "C" {
    #[doc = " \\brief               Enable SLCD driver\n\n \\param[in] descr     SLCD descriptor to be initialized"]
    pub fn slcd_sync_enable(descr: *mut slcd_sync_descriptor) -> i32;
}
extern "C" {
    #[doc = " \\brief               Disable SLCD driver\n\n \\param[in] descr     SLCD descriptor to be disabled"]
    pub fn slcd_sync_disable(descr: *mut slcd_sync_descriptor) -> i32;
}
extern "C" {
    #[doc = " \\brief               Turn on a Segment\n\n \\param[in] descr     SLCD descriptor to be enabled\n \\param[in] seg       Segment index. The segment index is by the combination\n                      of common and segment terminal index. The\n                      SLCD_SEGID(com, seg) macro can generate the index."]
    pub fn slcd_sync_seg_on(descr: *mut slcd_sync_descriptor, seg: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief               Turn off a Segment\n\n \\param[in] descr     SLCD descriptor\n \\param[in] seg       Segment index\n                      value is \"(common terminals << 16 | segment terminal)\""]
    pub fn slcd_sync_seg_off(descr: *mut slcd_sync_descriptor, seg: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief               Blink a Segment\n\n \\param[in] descr     SLCD descriptor\n \\param[in] seg       Segment index\n                      value is \"(common terminals << 16 | segment terminal)\"\n \\param[in] period    Blink period, unit is millisecond"]
    pub fn slcd_sync_seg_blink(descr: *mut slcd_sync_descriptor, seg: u32, period: u32) -> i32;
}
extern "C" {
    #[doc = " \\brief               Displays a character\n\n \\param[in] descr     SLCD descriptor\n \\param[in] character Character to be displayed\n \\param[in] index     Index of the character Mapping Group"]
    pub fn slcd_sync_write_char(descr: *mut slcd_sync_descriptor, character: u8, index: u32)
        -> i32;
}
extern "C" {
    #[doc = " \\brief               Displays character string string\n\n \\param[in] descr     SLCD descriptor\n \\param[in] str       String to be displayed, 0 will turn off the\n                      corresponding char to display\n \\param[in] len       Length of the string array\n \\param[in] index     Index of the character Mapping Group"]
    pub fn slcd_sync_write_string(
        descr: *mut slcd_sync_descriptor,
        str_: *mut u8,
        len: u32,
        index: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief               Start animation play by a segment array\n\n \\param[in] descr     SLCD descriptor\n \\param[in] segs      Segment array\n \\param[in] len       Length of the segment array\n \\param[in] period    Period (milliseconds) of each segment to animation"]
    pub fn slcd_sync_start_animation(
        descr: *mut slcd_sync_descriptor,
        segs: *const u32,
        len: u32,
        period: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief               Stop animation play by a segment array\n\n \\param[in] descr     SLCD descriptor\n \\param[in] segs      Segment array\n \\param[in] len       Length of the segment array"]
    pub fn slcd_sync_stop_animation(
        descr: *mut slcd_sync_descriptor,
        segs: *const u32,
        len: u32,
    ) -> i32;
}
extern "C" {
    #[doc = " \\brief               Set animation Frequency\n\n \\param[in] descr     SLCD descriptor\n \\param[in] period    Period (million second) of each segment to animation"]
    pub fn slcd_sync_set_animation_period(descr: *mut slcd_sync_descriptor, period: u32) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct adc_sync_descriptor {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut ADC_0: adc_sync_descriptor;
}
extern "C" {
    pub static mut I2C_0: i2c_m_sync_desc;
}
extern "C" {
    pub static mut USART_0: usart_sync_descriptor;
}
extern "C" {
    pub static mut SPI_0: spi_m_sync_descriptor;
}
extern "C" {
    pub static mut SEGMENT_LCD_0: slcd_sync_descriptor;
}
extern "C" {
    pub fn I2C_0_CLOCK_init();
}
extern "C" {
    pub fn I2C_0_init();
}
extern "C" {
    pub fn I2C_0_PORT_init();
}
extern "C" {
    pub fn SPI_0_PORT_init();
}
extern "C" {
    pub fn SPI_0_CLOCK_init();
}
extern "C" {
    pub fn SPI_0_init();
}
extern "C" {
    pub fn delay_driver_init();
}
extern "C" {
    pub fn EXTERNAL_IRQ_0_init();
}
extern "C" {
    pub fn SEGMENT_LCD_0_PORT_init();
}
extern "C" {
    pub fn SEGMENT_LCD_0_init();
}
extern "C" {
    #[doc = " @addtogroup app Application Framework\n @brief This section covers the functions that you will implement in your app.c file when designing a Sensor Watch app.\n @details You should be able to write a watch app by simply implementing these functions and declaring callbacks for\n          various GPIO and peripheral interrupts. The main.c file takes care of calling these functions for you. The\n          general flow:\n\n            1. Your app_init() function is called.\n               - This method should only be used to set your initial application state.\n            2. If your app is waking from BACKUP, app_wake_from_backup() is called.\n               - If you saved state in the RTC's backup registers, you can restore it here.\n            3. Your app_setup() method is called.\n               - You may wish to enable some functionality and peripherals here.\n               - You should definitely set up some interrupts here.\n            4. The main run loop begins: your app_loop() function is called.\n               - Run code and update your UI here.\n               - Return true if your app is prepared to enter STANDBY mode.\n            5. This step differs depending on the value returned by app_loop:\n               - If you returned false, execution resumes at (4).\n               - If you returned true, app_prepare_for_standby() is called; execution moves on to (6).\n            6. The microcontroller enters STANDBY mode.\n               - No user code will run, and the watch will enter a low power mode.\n               - The watch will remain in this state until an interrupt wakes it.\n            7. Once woken from STANDBY, your app_wake_from_standby() function is called.\n               - After this, execution resumes at (4).\n/\n/// @{\n/** @brief A function you will implement to initialize your application state. The app_init function is called before\n        anything else. Use it to set up any internal data structures or application state required by your app,\n        but don't configure any peripherals just yet."]
    pub fn app_init();
}
extern "C" {
    #[doc = " @brief A function you will implement to wake from BACKUP mode, which wipes the system's RAM, and with it, your\n        application's state. You may have chosen to store some important application state in the RTC's backup\n        registers prior to entering this mode. You may restore that state here."]
    pub fn app_wake_from_backup();
}
extern "C" {
    #[doc = " @brief A function you will implement to set up your application. The app_setup function is like setup() in Arduino.\n        It is called once when the program begins. You should set pin modes and enable any peripherals you want to\n        set up (real-time clock, I2C, etc.) Depending on your application, you may or may not want to configure\n        sensors on your sensor board here. For example, a low-power accelerometer that will run at all times should\n        be configured here, whereas you may want to enable a more power-hungry sensor only when you need it.\n @note If your app enters the ultra-low power BACKUP sleep mode, this function will be called again when it wakes\n       from that deep sleep state. In this state, the RTC will still be configured with the correct date and time."]
    pub fn app_setup();
}
extern "C" {
    #[doc = " @brief A function you will implement to serve as the app's main run loop. This method will be called repeatedly,\nor if you enter STANDBY mode, as soon as the device wakes from sleep.\n @return You should return true if your app is prepared to enter STANDBY mode. If you return false, your app's\n         app_loop method will be called again immediately. Note that in STANDBY mode, the watch will consume only\n         about 95 microamperes of power, whereas if you return false and keep the app awake, it will consume about\n         355 microamperes. This is the difference between months of battery life and days. As much as possible,\n         you should limit the amount of time your app spends awake.\n @note Only the RTC, the segment LCD controller and the external interrupt controller run in STANDBY mode. If you\n       are using, e.g. the PWM function to set a custom LED color, you should return false here until you are\n       finished with that operation. Note however that the peripherals will continue running after waking up,\n       so e.g. the I2C controller, if configured, will sleep in STANDBY. But you can use it again as soon as your\n       app wakes up."]
    pub fn app_loop() -> bool;
}
extern "C" {
    #[doc = " @brief A function you will implement to prepare to enter STANDBY mode. The app_prepare_for_standby function is\n         called after your app_loop function returns true, and just before the watch enters STANDBY mode. In this\n         mode most peripherals are shut down, and no code will run until the watch receives an interrupt (generally\n         either the 1Hz tick or a press on one of the buttons).\n @note If you are PWM'ing the LED or playing a sound on the buzzer, the TC/TCC peripherals that drive those operations\n       will not run in STANDBY. BUT! the output pins will retain the state they had when entering standby. This means\n       you could end up entering standby with an LED on and draining power, or with a DC potential across the piezo\n       buzzer that could damage it if left in this state. If your app_loop does not prevent sleep during these\n       activities, you should make sure to disable these outputs in app_prepare_for_standby."]
    pub fn app_prepare_for_standby();
}
extern "C" {
    #[doc = " @brief A method you will implement to configure the app after waking from STANDBY mode."]
    pub fn app_wake_from_standby();
}
#[doc = " \\brief Time struct for calendar"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct calendar_time {
    pub sec: u8,
    pub min: u8,
    pub hour: u8,
}
#[test]
fn bindgen_test_layout_calendar_time() {
    const UNINIT: ::core::mem::MaybeUninit<calendar_time> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<calendar_time>(),
        3usize,
        concat!("Size of: ", stringify!(calendar_time))
    );
    assert_eq!(
        ::core::mem::align_of::<calendar_time>(),
        1usize,
        concat!("Alignment of ", stringify!(calendar_time))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(calendar_time),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(calendar_time),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hour) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(calendar_time),
            "::",
            stringify!(hour)
        )
    );
}
#[doc = " \\brief Time struct for calendar"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct calendar_date {
    pub day: u8,
    pub month: u8,
    pub year: u16,
}
#[test]
fn bindgen_test_layout_calendar_date() {
    const UNINIT: ::core::mem::MaybeUninit<calendar_date> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<calendar_date>(),
        4usize,
        concat!("Size of: ", stringify!(calendar_date))
    );
    assert_eq!(
        ::core::mem::align_of::<calendar_date>(),
        2usize,
        concat!("Alignment of ", stringify!(calendar_date))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(calendar_date),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(calendar_date),
            "::",
            stringify!(month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).year) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(calendar_date),
            "::",
            stringify!(year)
        )
    );
}
#[doc = " \\brief Date&Time struct for calendar"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct calendar_date_time {
    pub time: calendar_time,
    pub date: calendar_date,
}
#[test]
fn bindgen_test_layout_calendar_date_time() {
    const UNINIT: ::core::mem::MaybeUninit<calendar_date_time> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<calendar_date_time>(),
        8usize,
        concat!("Size of: ", stringify!(calendar_date_time))
    );
    assert_eq!(
        ::core::mem::align_of::<calendar_date_time>(),
        2usize,
        concat!("Alignment of ", stringify!(calendar_date_time))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(calendar_date_time),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).date) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(calendar_date_time),
            "::",
            stringify!(date)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union watch_date_time {
    pub unit: watch_date_time__bindgen_ty_1,
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct watch_date_time__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_watch_date_time__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<watch_date_time__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(watch_date_time__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<watch_date_time__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(watch_date_time__bindgen_ty_1))
    );
}
impl watch_date_time__bindgen_ty_1 {
    #[inline]
    pub fn second(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_second(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn minute(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_minute(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn hour(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_hour(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn day(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_day(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn month(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(22usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_month(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(22usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn year(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(26usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_year(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(26usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        second: u32,
        minute: u32,
        hour: u32,
        day: u32,
        month: u32,
        year: u32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 6u8, {
            let second: u32 = unsafe { ::core::mem::transmute(second) };
            second as u64
        });
        __bindgen_bitfield_unit.set(6usize, 6u8, {
            let minute: u32 = unsafe { ::core::mem::transmute(minute) };
            minute as u64
        });
        __bindgen_bitfield_unit.set(12usize, 5u8, {
            let hour: u32 = unsafe { ::core::mem::transmute(hour) };
            hour as u64
        });
        __bindgen_bitfield_unit.set(17usize, 5u8, {
            let day: u32 = unsafe { ::core::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(22usize, 4u8, {
            let month: u32 = unsafe { ::core::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(26usize, 6u8, {
            let year: u32 = unsafe { ::core::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_watch_date_time() {
    const UNINIT: ::core::mem::MaybeUninit<watch_date_time> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<watch_date_time>(),
        4usize,
        concat!("Size of: ", stringify!(watch_date_time))
    );
    assert_eq!(
        ::core::mem::align_of::<watch_date_time>(),
        4usize,
        concat!("Alignment of ", stringify!(watch_date_time))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(watch_date_time),
            "::",
            stringify!(unit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(watch_date_time),
            "::",
            stringify!(reg)
        )
    );
}
pub const watch_rtc_alarm_match_ALARM_MATCH_DISABLED: watch_rtc_alarm_match = 0;
pub const watch_rtc_alarm_match_ALARM_MATCH_SS: watch_rtc_alarm_match = 1;
pub const watch_rtc_alarm_match_ALARM_MATCH_MMSS: watch_rtc_alarm_match = 2;
pub const watch_rtc_alarm_match_ALARM_MATCH_HHMMSS: watch_rtc_alarm_match = 3;
pub type watch_rtc_alarm_match = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Called by main.c to check if the RTC is enabled.\n You may call this function, but outside of app_init, it should always return true."]
    pub fn _watch_rtc_is_enabled() -> bool;
}
extern "C" {
    #[doc = " @brief Sets the date and time.\n @param date_time The date and time you wish to set, with a year value from 0-63 representing 2020-2083.\n @note The SAM L22 stores the year as six bits representing a value from 0 to 63. It treats this as a year\n       offset from a reference year, which must be a leap year. Since 2020 was a leap year, and it allows\n       useful dates through 2083, it is assumed that watch apps will use 2020 as the reference year; thus\n       1 means 2021, 2 means 2022, etc. **You will be responsible for handling this offset in your code**,\n       if the calendar year is needed for timestamp calculation logic or display purposes."]
    pub fn watch_rtc_set_date_time(date_time: watch_date_time);
}
extern "C" {
    #[doc = " @brief Returns the date and time.\n @return A watch_date_time with the current date and time, with a year value from 0-63 representing 2020-2083.\n @see watch_rtc_set_date_time for notes about how the year is stored."]
    pub fn watch_rtc_get_date_time() -> watch_date_time;
}
extern "C" {
    #[doc = " @brief Registers an alarm callback that will be called when the RTC time matches the target time, as masked\n        by the provided mask.\n @param callback The function you wish to have called when the alarm fires. If this value is NULL, the alarm\n                 interrupt will still be enabled, but no callback function will be called.\n @param alarm_time The time that you wish to match. The date is currently ignored.\n @param mask One of the values in watch_rtc_alarm_match indicating which values to check.\n @details The alarm interrupt is a versatile tool for scheduling events in the future, especially since it can\n          wake the device from all sleep modes. The key to its versatility is the mask parameter.\n          Suppose we set an alarm for midnight, 00:00:00.\n           * if mask is ALARM_MATCH_SS, the alarm will fire every minute when the clock ticks to seconds == 0.\n           * with ALARM_MATCH_MMSS, the alarm will once an hour, at the top of each hour.\n           * with ALARM_MATCH_HHMMSS, the alarm will fire at midnight every day.\n          In theory the SAM L22's alarm function can match on days, months and even years, but I have not had\n          success with this yet; as such, I am omitting these options for now."]
    pub fn watch_rtc_register_alarm_callback(
        callback: ext_irq_cb_t,
        alarm_time: watch_date_time,
        mask: watch_rtc_alarm_match,
    );
}
extern "C" {
    #[doc = " @brief Disables the alarm callback."]
    pub fn watch_rtc_disable_alarm_callback();
}
extern "C" {
    #[doc = " @brief Registers a \"tick\" callback that will be called once per second.\n @param callback The function you wish to have called when the clock ticks. If you pass in NULL, the tick\n                 interrupt will still be enabled, but no callback function will be called.\n @note this is equivalent to calling watch_rtc_register_periodic_callback with a frequency of 1. It can be\n       disabled with either watch_rtc_disable_tick_callback() or watch_rtc_disable_periodic_callback(1),\n       and will also be disabled when watch_rtc_disable_all_periodic_callbacks is called."]
    pub fn watch_rtc_register_tick_callback(callback: ext_irq_cb_t);
}
extern "C" {
    #[doc = " @brief Disables the tick callback for the given period."]
    pub fn watch_rtc_disable_tick_callback();
}
extern "C" {
    #[doc = " @brief Registers a callback that will be called at a configurable period.\n @param callback The function you wish to have called at the specified period. If you pass in NULL, the periodic\n                 interrupt will still be enabled, but no callback function will be called.\n @param frequency The frequency of the tick in Hz. **Must be a power of 2**, from 1 to 128 inclusive.\n @note A 1 Hz tick (@see watch_rtc_register_tick_callback) is suitable for most applications, in that it gives you a\n       chance to update the display once a second — an ideal update rate for a watch! If however you are displaying\n       a value (such as an accelerometer output) that updates more frequently than once per second, you may want to\n       tick at 16 or 32 Hz to update the screen more quickly. Just remember that the more frequent the tick, the more\n       power your app will consume. Ideally you should enable the fast tick only when the user requires it (i.e. in\n       response to an input event), and move back to the slow tick after some time.\n\n       Also note that the RTC peripheral does not have sub-second resolution, so even if you set a 2 or 4 Hz interval,\n       the system will not have any way of telling you where you are within a given second; watch_rtc_get_date_time\n       will return the exact same timestamp until the second ticks over."]
    pub fn watch_rtc_register_periodic_callback(callback: ext_irq_cb_t, frequency: u8);
}
extern "C" {
    #[doc = " @brief Disables the tick callback for the given period.\n @param frequency The frequency of the tick you wish to disable, in Hz. **Must be a power of 2**, from 1 to 128."]
    pub fn watch_rtc_disable_periodic_callback(frequency: u8);
}
extern "C" {
    #[doc = " @brief Disables tick callbacks for the given periods (as a bitmask).\n @param mask The frequencies of tick callbacks you wish to disable, in Hz.\n The 128 Hz callback is 0b1, the 64 Hz callback is 0b10, the 32 Hz callback is 0b100, etc."]
    pub fn watch_rtc_disable_matching_periodic_callbacks(mask: u8);
}
extern "C" {
    #[doc = " @brief Disables all periodic callbacks, including the once-per-second tick callback."]
    pub fn watch_rtc_disable_all_periodic_callbacks();
}
extern "C" {
    #[doc = " @brief Enable/disable RTC while in-flight. This is quite dangerous operation, so we repeat writing register twice.\n Used when temporarily pausing RTC when adjusting subsecond, which are not accessible otherwise."]
    pub fn watch_rtc_enable(en: bool);
}
extern "C" {
    #[doc = " @brief Adjusts frequency correction in single register write. Not waiting for syncronisation to save power - if you won't write new\n correction value in the same ~millisecond - will not cause issue."]
    pub fn watch_rtc_freqcorr_write(value: i16, sign: i16);
}
#[doc = "< The hourly signal indicator; also useful for indicating that sensors are on."]
pub const WatchIndicatorSegment_WATCH_INDICATOR_SIGNAL: WatchIndicatorSegment = 0;
#[doc = "< The small bell indicating that an alarm is set."]
pub const WatchIndicatorSegment_WATCH_INDICATOR_BELL: WatchIndicatorSegment = 1;
#[doc = "< The PM indicator, indicating that a time is in the afternoon."]
pub const WatchIndicatorSegment_WATCH_INDICATOR_PM: WatchIndicatorSegment = 2;
#[doc = "< The 24H indicator, indicating that the watch is in a 24-hour mode."]
pub const WatchIndicatorSegment_WATCH_INDICATOR_24H: WatchIndicatorSegment = 3;
#[doc = "< The LAP indicator; the F-91W uses this in its stopwatch UI."]
pub const WatchIndicatorSegment_WATCH_INDICATOR_LAP: WatchIndicatorSegment = 4;
#[doc = " An enum listing the icons and indicators available on the watch."]
pub type WatchIndicatorSegment = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Enables the Segment LCD display.\n Call this before attempting to set pixels or display strings."]
    pub fn watch_enable_display();
}
extern "C" {
    #[doc = " @brief Sets a pixel. Use this to manually set a pixel with a given common and segment number.\n        See <a href=\"segmap.html\">segmap.html</a>.\n @param com the common pin, numbered from 0-2.\n @param seg the segment pin, numbered from 0-23."]
    pub fn watch_set_pixel(com: u8, seg: u8);
}
extern "C" {
    #[doc = " @brief Clears a pixel. Use this to manually clear a pixel with a given common and segment number.\n        See <a href=\"segmap.html\">segmap.html</a>.\n @param com the common pin, numbered from 0-2.\n @param seg the segment pin, numbered from 0-23."]
    pub fn watch_clear_pixel(com: u8, seg: u8);
}
extern "C" {
    #[doc = " @brief Clears all segments of the display, including incicators and the colon."]
    pub fn watch_clear_display();
}
extern "C" {
    #[doc = " @brief Displays a string at the given position, starting from the top left. There are ten digits.\nA space in any position will clear that digit.\n @param string A null-terminated string.\n @param position The position where you wish to start displaying the string. The day of week digits\n                 are positions 0 and 1; the day of month digits are positions 2 and 3, and the main\n                 clock line occupies positions 4-9.\n @note This method does not clear the display; if for example you display a two-character string at\nposition 0, positions 2-9 will retain whatever state they were previously displaying."]
    pub fn watch_display_string(string: *mut ::core::ffi::c_char, position: u8);
}
extern "C" {
    #[doc = " @brief Turns the colon segment on."]
    pub fn watch_set_colon();
}
extern "C" {
    #[doc = " @brief Turns the colon segment off."]
    pub fn watch_clear_colon();
}
extern "C" {
    #[doc = " @brief Sets an indicator on the LCD. Use this to turn on one of the indicator segments.\n @param indicator One of the indicator segments from the enum. @see WatchIndicatorSegment"]
    pub fn watch_set_indicator(indicator: WatchIndicatorSegment);
}
extern "C" {
    #[doc = " @brief Clears an indicator on the LCD. Use this to turn off one of the indicator segments.\n @param indicator One of the indicator segments from the enum. @see WatchIndicatorSegment"]
    pub fn watch_clear_indicator(indicator: WatchIndicatorSegment);
}
extern "C" {
    #[doc = " @brief Clears all indicator segments.\n @see WatchIndicatorSegment"]
    pub fn watch_clear_all_indicators();
}
extern "C" {
    #[doc = " @brief Blinks a single character in position 7. Does not affect other positions.\n @details Six of the seven segments in position 7 (and only position 7) are capable of autonomous\n          blinking. This blinking does not require any CPU resources, and will continue even in\n          STANDBY and Sleep mode (but not Deep Sleep mode, since that mode turns off the LCD).\n @param character The character you wish to blink.\n @param duration The duration of the on/off cycle in milliseconds, from 50 to ~4250 ms.\n @note Segment B of position 7 cannot blink autonomously, so not all characters will work well.\n       Supported characters for blinking:\n        * Punctuation: underscore, apostrophe, comma, hyphen, equals sign, tilde (top segment only)\n        * Numbers: 5, 6, ampersand (lowercase 7)\n        * Letters: b, C, c, E, F, h, i, L, l, n, o, S, t"]
    pub fn watch_start_character_blink(character: ::core::ffi::c_char, duration: u32);
}
extern "C" {
    #[doc = " @brief Stops and clears all blinking segments.\n @details This will stop all blinking in position 7, and clear all segments in that digit."]
    pub fn watch_stop_blink();
}
extern "C" {
    #[doc = " @brief Begins a two-segment \"tick-tock\" animation in position 8.\n @details Six of the seven segments in position 8 (and only position 8) are capable of autonomous\n          animation. This animation is very basic, and consists of moving a bit pattern forward\n          or backward in a shift register whose positions map to fixed segments on the LCD. Given\n          this constraint, an animation across all six segments does not make sense; so the watch\n          library offers only a simple \"tick/tock\" in segments D and E. This animation does not\n          require any CPU resources, and will continue even in STANDBY and Sleep mode (but not Deep\n          Sleep mode, since that mode turns off the LCD).\n @param duration The duration of each frame in ms. 500 milliseconds produces a classic tick/tock."]
    pub fn watch_start_tick_animation(duration: u32);
}
extern "C" {
    #[doc = " @brief Checks if the tick animation is currently running.\n @return true if the animation is running; false otherwise."]
    pub fn watch_tick_animation_is_running() -> bool;
}
extern "C" {
    #[doc = " @brief Stops the tick/tock animation and clears all animating segments.\n @details This will stop the animation and clear all segments in position 8."]
    pub fn watch_stop_tick_animation();
}
pub const watch_interrupt_trigger_INTERRUPT_TRIGGER_NONE: watch_interrupt_trigger = 0;
pub const watch_interrupt_trigger_INTERRUPT_TRIGGER_RISING: watch_interrupt_trigger = 1;
pub const watch_interrupt_trigger_INTERRUPT_TRIGGER_FALLING: watch_interrupt_trigger = 2;
pub const watch_interrupt_trigger_INTERRUPT_TRIGGER_BOTH: watch_interrupt_trigger = 3;
#[doc = "@brief An enum defining the types of interrupt trigger you wish to scan for."]
pub type watch_interrupt_trigger = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Enables the external interrupt controller."]
    pub fn watch_enable_external_interrupts();
}
extern "C" {
    #[doc = " @brief Disables the external interrupt controller."]
    pub fn watch_disable_external_interrupts();
}
extern "C" {
    #[doc = " @brief Configures an external interrupt callback on one of the external interrupt pins.\n @details You can set one interrupt callback per pin, and you can monitor for a rising condition,\n          a falling condition, or both. If you just want to detect a button press, register your\n          interrupt with INTERRUPT_TRIGGER_RISING; if you want to detect an active-low interrupt\n          signal from a device on the nine-pin connector, use INTERRUPT_TRIGGER_FALLING. If you\n          want to detect both rising and falling conditions (i.e. button down and button up), use\n          INTERRUPT_TRIGGER_BOTH and use watch_get_pin_level to check the pin level in your callback\n          to determine which condition caused the interrupt.\n @param pin One of BTN_LIGHT, BTN_MODE, BTN_ALARM, A0, A1, A3 or A4. If the pin parameter matches one of\n            the three button pins, this function will also enable an internal pull-down resistor. If\n            the pin parameter is A0-A4, you are responsible for setting any required pull configuration\n            using watch_enable_pull_up or watch_enable_pull_down.\n @param callback The function you wish to have called when the button is pressed.\n @param trigger The condition on which you wish to trigger: rising, falling or both.\n @note Pins A2 and A4 can also generate interrupts via the watch_register_extwake_callback function, which\n       will allow them to trigger even when the watch is in deep sleep mode.\n @warning As of now, A2 is not usable via the watch_register_interrupt_callback function. To enable an\n          external interrupt on pin A2, use the watch_register_extwake_callback function. This issue will be\n          addressed in a future revision of the watch library."]
    pub fn watch_register_interrupt_callback(
        pin: u8,
        callback: ext_irq_cb_t,
        trigger: watch_interrupt_trigger,
    );
}
extern "C" {
    #[doc = " @addtogroup led LED Control\n @brief This section covers functions related to the bi-color red/green LED mounted behind the LCD.\n @details The SAM L22 is an exceedingly power efficient chip, whereas the LED's are relatively power-\n          hungry. The green LED, at full power, consumes more power than the whole chip in active mode,\n          and the red LED consumes about twelve times as much power! The LED's should thus be used only\n          sparingly in order to preserve battery life.\n @note Some watches use a red/blue LED instead of a red/green LED. You will be able to determine this\n       easily when you double tap the reset button: if the pulsing bootloader LED is red, you have a\n       red/green edition; if it is blue, you have a red/blue edition. For red/blue watches, build your\n       project with the command `make LED=BLUE`, and the watch library will automatically swap the pins\n       so that watch_set_led_red sets the red LED, and watch_set_led_green sets the blue one.\n/\n/// @{\n/** @brief Enables the bi-color LED.\n @note The TCC peripheral that drives the LEDs does not run in STANDBY mode — but the outputs do! This\n       means that if you set either red, green or both LEDs to full power, they will shine even when\n       your app is asleep. If, however, you set a custom color using watch_set_led_color, the color will\n       not display correctly in STANDBY mode. You will need to keep your app running while the LED is on."]
    pub fn watch_enable_leds();
}
extern "C" {
    #[doc = " @brief Disables the LEDs.\n @note This method will also disable the buzzer, since the buzzer and LED both make use of the same\n       peripheral to drive their PWM behavior."]
    pub fn watch_disable_leds();
}
extern "C" {
    #[doc = " @brief Sets the LED to a custom color by modulating each output's duty cycle.\n @param red The red value from 0-255.\n @param green The green value from 0-255. If your watch has a red/blue LED, this will be the blue value.\n @note If you are displaying a custom color, you will need to prevent your app from going to sleep\n       while the LED is on; otherwise, the color will not display correctly. You can do this by\n       returning false in your app_loop method."]
    pub fn watch_set_led_color(red: u8, green: u8);
}
extern "C" {
    #[doc = " @brief Sets the red LED to full brightness, and turns the green LED off.\n @details Of the two LED's in the RG bi-color LED, the red LED is the less power-efficient one (~4.5 mA)."]
    pub fn watch_set_led_red();
}
extern "C" {
    #[doc = " @brief Sets the green LED to full brightness, and turns the red LED off.\n @details Of the two LED's in the RG bi-color LED, the green LED is the more power-efficient one (~0.44 mA).\n @note If your watch has a red/blue LED, this method will set the LED to blue."]
    pub fn watch_set_led_green();
}
extern "C" {
    #[doc = " @brief Sets both red and green LEDs to full brightness.\n @details The total current draw between the two LED's in this mode will be ~5 mA, which is more than the\n          watch draws in any other mode. Take care not to drain the battery.\n @note If your watch has a red/blue LED, this method will set the LED to pink."]
    pub fn watch_set_led_yellow();
}
extern "C" {
    #[doc = " @brief Turns both the red and the green LEDs off."]
    pub fn watch_set_led_off();
}
extern "C" {
    #[doc = " @addtogroup buzzer Buzzer\n @brief This section covers functions related to the piezo buzzer embedded in the F-91W's back plate.\n/\n/// @{\n/** @brief Enables the TCC peripheral, which drives the buzzer."]
    pub fn watch_enable_buzzer();
}
extern "C" {
    #[doc = " @brief Sets the period of the buzzer.\n @param period The period of a single cycle for the TCC peripheral. You can determine the period for\n               a desired frequency with the following formula: period = 1000000 / freq"]
    pub fn watch_set_buzzer_period(period: u32);
}
extern "C" {
    #[doc = " @brief Disables the TCC peripheral that drives the buzzer.\n @note If you are using PWM to set custom LED colors, this method will also disable the LED PWM driver,\n       since the buzzer and LED both make use of the same peripheral to drive their PWM behavior."]
    pub fn watch_disable_buzzer();
}
extern "C" {
    #[doc = " @brief Turns the buzzer output on. It will emit a continuous sound at the given frequency.\n @note The TCC peripheral that drives the buzzer does not run in standby mode; if you wish for buzzer\n       output to continue, you should prevent your app from going to sleep."]
    pub fn watch_set_buzzer_on();
}
extern "C" {
    #[doc = " @brief Turns the buzzer output off."]
    pub fn watch_set_buzzer_off();
}
#[doc = "< 55.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A1: BuzzerNote = 0;
#[doc = "< 58.27 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A1SHARP_B1FLAT: BuzzerNote = 1;
#[doc = "< 61.74 Hz"]
pub const BuzzerNote_BUZZER_NOTE_B1: BuzzerNote = 2;
#[doc = "< 65.41 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C2: BuzzerNote = 3;
#[doc = "< 69.30 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C2SHARP_D2FLAT: BuzzerNote = 4;
#[doc = "< 73.42 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D2: BuzzerNote = 5;
#[doc = "< 77.78 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D2SHARP_E2FLAT: BuzzerNote = 6;
#[doc = "< 82.41 Hz"]
pub const BuzzerNote_BUZZER_NOTE_E2: BuzzerNote = 7;
#[doc = "< 87.31 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F2: BuzzerNote = 8;
#[doc = "< 92.50 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F2SHARP_G2FLAT: BuzzerNote = 9;
#[doc = "< 98.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G2: BuzzerNote = 10;
#[doc = "< 103.83 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G2SHARP_A2FLAT: BuzzerNote = 11;
#[doc = "< 110.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A2: BuzzerNote = 12;
#[doc = "< 116.54 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A2SHARP_B2FLAT: BuzzerNote = 13;
#[doc = "< 123.47 Hz"]
pub const BuzzerNote_BUZZER_NOTE_B2: BuzzerNote = 14;
#[doc = "< 130.81 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C3: BuzzerNote = 15;
#[doc = "< 138.59 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C3SHARP_D3FLAT: BuzzerNote = 16;
#[doc = "< 146.83 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D3: BuzzerNote = 17;
#[doc = "< 155.56 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D3SHARP_E3FLAT: BuzzerNote = 18;
#[doc = "< 164.81 Hz"]
pub const BuzzerNote_BUZZER_NOTE_E3: BuzzerNote = 19;
#[doc = "< 174.61 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F3: BuzzerNote = 20;
#[doc = "< 185.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F3SHARP_G3FLAT: BuzzerNote = 21;
#[doc = "< 196.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G3: BuzzerNote = 22;
#[doc = "< 207.65 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G3SHARP_A3FLAT: BuzzerNote = 23;
#[doc = "< 220.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A3: BuzzerNote = 24;
#[doc = "< 233.08 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A3SHARP_B3FLAT: BuzzerNote = 25;
#[doc = "< 246.94 Hz"]
pub const BuzzerNote_BUZZER_NOTE_B3: BuzzerNote = 26;
#[doc = "< 261.63 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C4: BuzzerNote = 27;
#[doc = "< 277.18 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C4SHARP_D4FLAT: BuzzerNote = 28;
#[doc = "< 293.66 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D4: BuzzerNote = 29;
#[doc = "< 311.13 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D4SHARP_E4FLAT: BuzzerNote = 30;
#[doc = "< 329.63 Hz"]
pub const BuzzerNote_BUZZER_NOTE_E4: BuzzerNote = 31;
#[doc = "< 349.23 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F4: BuzzerNote = 32;
#[doc = "< 369.99 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F4SHARP_G4FLAT: BuzzerNote = 33;
#[doc = "< 392.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G4: BuzzerNote = 34;
#[doc = "< 415.30 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G4SHARP_A4FLAT: BuzzerNote = 35;
#[doc = "< 440.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A4: BuzzerNote = 36;
#[doc = "< 466.16 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A4SHARP_B4FLAT: BuzzerNote = 37;
#[doc = "< 493.88 Hz"]
pub const BuzzerNote_BUZZER_NOTE_B4: BuzzerNote = 38;
#[doc = "< 523.25 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C5: BuzzerNote = 39;
#[doc = "< 554.37 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C5SHARP_D5FLAT: BuzzerNote = 40;
#[doc = "< 587.33 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D5: BuzzerNote = 41;
#[doc = "< 622.25 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D5SHARP_E5FLAT: BuzzerNote = 42;
#[doc = "< 659.25 Hz"]
pub const BuzzerNote_BUZZER_NOTE_E5: BuzzerNote = 43;
#[doc = "< 698.46 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F5: BuzzerNote = 44;
#[doc = "< 739.99 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F5SHARP_G5FLAT: BuzzerNote = 45;
#[doc = "< 783.99 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G5: BuzzerNote = 46;
#[doc = "< 830.61 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G5SHARP_A5FLAT: BuzzerNote = 47;
#[doc = "< 880.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A5: BuzzerNote = 48;
#[doc = "< 932.33 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A5SHARP_B5FLAT: BuzzerNote = 49;
#[doc = "< 987.77 Hz"]
pub const BuzzerNote_BUZZER_NOTE_B5: BuzzerNote = 50;
#[doc = "< 1046.50 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C6: BuzzerNote = 51;
#[doc = "< 1108.73 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C6SHARP_D6FLAT: BuzzerNote = 52;
#[doc = "< 1174.66 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D6: BuzzerNote = 53;
#[doc = "< 1244.51 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D6SHARP_E6FLAT: BuzzerNote = 54;
#[doc = "< 1318.51 Hz"]
pub const BuzzerNote_BUZZER_NOTE_E6: BuzzerNote = 55;
#[doc = "< 1396.91 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F6: BuzzerNote = 56;
#[doc = "< 1479.98 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F6SHARP_G6FLAT: BuzzerNote = 57;
#[doc = "< 1567.98 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G6: BuzzerNote = 58;
#[doc = "< 1661.22 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G6SHARP_A6FLAT: BuzzerNote = 59;
#[doc = "< 1760.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A6: BuzzerNote = 60;
#[doc = "< 1864.66 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A6SHARP_B6FLAT: BuzzerNote = 61;
#[doc = "< 1975.53 Hz"]
pub const BuzzerNote_BUZZER_NOTE_B6: BuzzerNote = 62;
#[doc = "< 2093.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C7: BuzzerNote = 63;
#[doc = "< 2217.46 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C7SHARP_D7FLAT: BuzzerNote = 64;
#[doc = "< 2349.32 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D7: BuzzerNote = 65;
#[doc = "< 2489.02 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D7SHARP_E7FLAT: BuzzerNote = 66;
#[doc = "< 2637.02 Hz"]
pub const BuzzerNote_BUZZER_NOTE_E7: BuzzerNote = 67;
#[doc = "< 2793.83 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F7: BuzzerNote = 68;
#[doc = "< 2959.96 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F7SHARP_G7FLAT: BuzzerNote = 69;
#[doc = "< 3135.96 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G7: BuzzerNote = 70;
#[doc = "< 3322.44 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G7SHARP_A7FLAT: BuzzerNote = 71;
#[doc = "< 3520.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A7: BuzzerNote = 72;
#[doc = "< 3729.31 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A7SHARP_B7FLAT: BuzzerNote = 73;
#[doc = "< 3951.07 Hz"]
pub const BuzzerNote_BUZZER_NOTE_B7: BuzzerNote = 74;
#[doc = "< 4186.01 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C8: BuzzerNote = 75;
#[doc = "< 4434.92 Hz"]
pub const BuzzerNote_BUZZER_NOTE_C8SHARP_D8FLAT: BuzzerNote = 76;
#[doc = "< 4698.63 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D8: BuzzerNote = 77;
#[doc = "< 4978.03 Hz"]
pub const BuzzerNote_BUZZER_NOTE_D8SHARP_E8FLAT: BuzzerNote = 78;
#[doc = "< 5274.04 Hz"]
pub const BuzzerNote_BUZZER_NOTE_E8: BuzzerNote = 79;
#[doc = "< 5587.65 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F8: BuzzerNote = 80;
#[doc = "< 5919.91 Hz"]
pub const BuzzerNote_BUZZER_NOTE_F8SHARP_G8FLAT: BuzzerNote = 81;
#[doc = "< 6271.93 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G8: BuzzerNote = 82;
#[doc = "< 6644.88 Hz"]
pub const BuzzerNote_BUZZER_NOTE_G8SHARP_A8FLAT: BuzzerNote = 83;
#[doc = "< 7040.00 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A8: BuzzerNote = 84;
#[doc = "< 7458.62 Hz"]
pub const BuzzerNote_BUZZER_NOTE_A8SHARP_B8FLAT: BuzzerNote = 85;
#[doc = "< 7902.13 Hz"]
pub const BuzzerNote_BUZZER_NOTE_B8: BuzzerNote = 86;
#[doc = "< no sound"]
pub const BuzzerNote_BUZZER_NOTE_REST: BuzzerNote = 87;
#[doc = " @brief 87 notes for use with watch_buzzer_play_note"]
pub type BuzzerNote = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Plays the given note for a set duration.\n @param note The note you wish to play, or BUZZER_NOTE_REST to disable output for the given duration.\n @param duration_ms The duration of the note.\n @note Note that this will block your UI for the duration of the note's play time, and it will\n       after this call, the buzzer period will be set to the period of this note."]
    pub fn watch_buzzer_play_note(note: BuzzerNote, duration_ms: u16);
}
extern "C" {
    #[doc = " @brief An array of periods for all the notes on a piano, corresponding to the names in BuzzerNote."]
    pub static NotePeriods: [u16; 108usize];
}
extern "C" {
    #[doc = " @brief Plays the given sequence of notes in a non-blocking way.\n @param note_sequence A pointer to the sequence of buzzer note & duration tuples, ending with a zero. A simple\n        RLE logic is implemented: a negative number instead of a buzzer note means that the sequence\n        is rewound by the given number of notes. The byte following a negative number determines the number\n        of loops. I.e. if you want to repeat the last three notes of the sequence one time, you should provide\n        the tuple -3, 1. The repeated notes must not contain any other repeat markers, or you will end up with\n        an eternal loop.\n @param callback_on_end A pointer to a callback function to be invoked when the sequence has finished playing.\n @note This function plays the sequence asynchronously, so the UI will not be blocked.\n       Hint: It is not possible to play the lowest note BUZZER_NOTE_A1 (55.00 Hz). The note is represented by a\n       zero byte, which is used here as the end-of-sequence marker. But hey, a frequency that low cannot be\n       played properly by the watch's buzzer, anyway."]
    pub fn watch_buzzer_play_sequence(
        note_sequence: *mut i8,
        callback_on_end: ::core::option::Option<unsafe extern "C" fn()>,
    );
}
extern "C" {
    #[doc = " @brief Aborts a playing sequence."]
    pub fn watch_buzzer_abort_sequence();
}
extern "C" {
    #[doc = " @addtogroup adc Analog Input\n @brief This section covers functions related to the SAM L22's analog-to-digital converter,\n        as well as configuring and reading values from the five analog-capable pins on the\n        9-pin connector.\n/\n/// @{\n/** @brief Enables the ADC peripheral. You must call this before attempting to read a value\n        from an analog pin."]
    pub fn watch_enable_adc();
}
extern "C" {
    #[doc = " @brief Configures the selected pin for analog input.\n @param pin One of pins A0-A4."]
    pub fn watch_enable_analog_input(pin: u8);
}
extern "C" {
    #[doc = " @brief Reads an analog value from one of the pins.\n @param pin One of pins A0-A4.\n @return a 16-bit unsigned integer from 0-65535 representing the sampled value, unless you\n         have changed the number of samples. @see watch_set_num_analog_samples for details\n         on how that function changes the values returned from this one."]
    pub fn watch_get_analog_pin_level(pin: u8) -> u16;
}
extern "C" {
    #[doc = " @brief Sets the number of samples to accumulate when measuring a pin level. Default is 16.\n @param samples A power of 2 <= 1024. Specifically: 1, 2, 4, 8, 16, 32, 64, 128, 256, 512\nor 1024. Any other value will be ignored.\n @details The SAM L22's ADC has a resolution of 12 bits. By default, the watch configures\n          the ADC to take 16 samples of the analog input and accumulate them in the result\n          register; this effectively gives us a 16-bit resolution, at the cost of taking 16\n          ADC cycles to complete a measurement. If you are measuring a slowly changing signal\n          like a thermistor output or an ambient light sensor this is probably fine, even\n          desirable. If you are measuring something a bit more fast-paced, like an analog\n          accelerometer, you may wish to exchange precision for speed. In this case you may\n          call this function to configure the ADC to accumulate fewer samples. HOWEVER! Note\n          that this may change the range of values returned from watch_get_analog_pin_level:\n            - For watch_set_num_analog_samples(1), the returned value will be 12 bits (0-4095).\n            - For watch_set_num_analog_samples(2), the returned value will be 13 bits (0-8191).\n            - For watch_set_num_analog_samples(4), the returned value will be 14 bits (0-16383).\n            - For watch_set_num_analog_samples(8), the returned value will be 15 bits (0-32767).\n         For sampling values over 16, the returned value will still be 16 bits (0-65535); the\n         ADC will automatically divide the measured value by whatever factor is necessary to fit\n         the result in 16 bits.\n @see watch_get_analog_pin_level"]
    pub fn watch_set_analog_num_samples(samples: u16);
}
extern "C" {
    #[doc = " @brief Sets the length of time spent sampling, which allows measurement of higher impedance inputs.\n        Default is 1.\n @param cycles The number of ADC cycles to sample, between 1 and 64.\n @see this article by Thea Flowers: https://blog.thea.codes/getting-the-most-out-of-the-samd21-adc/\n      which is where I learned all of this.\n @details To measure an analog value, the SAM L22 must charge a capacitor to the analog voltage\n          presented at the input. This takes time. Importantly, the higher the input impedance,\n          the more time this takes. As a basic example: if you are using a thermistor tied to\n          VCC to measure temperature, the capacitor has to charge through the thermistor. The\n          higher the resistor value, the higher the input impedance, and the more time we need\n          to allow for the measurement. By default, the ADC is configured to run on a 500 kHz\n          clock with a sample time of one cycle. This is appropriate for an input impedance up\n          to about 28kΩ. Setting the sampling time to 4 cycles allows for an input impedance up\n          to 123kΩ. Setting the sampling time to the maximum of 64 cycles theoretically allows\n          for input impedance up to 2 MΩ. (I based these numbers on the calculator in the linked\n          blog post; it also has a ton of great info on the SAM D21 ADC, which is similar to the\n          SAM L22's)."]
    pub fn watch_set_analog_sampling_length(cycles: u8);
}
pub const watch_adc_reference_voltage_ADC_REFERENCE_INTREF: watch_adc_reference_voltage = 0;
pub const watch_adc_reference_voltage_ADC_REFERENCE_VCC_DIV1POINT6: watch_adc_reference_voltage = 1;
pub const watch_adc_reference_voltage_ADC_REFERENCE_VCC_DIV2: watch_adc_reference_voltage = 2;
pub const watch_adc_reference_voltage_ADC_REFERENCE_VCC: watch_adc_reference_voltage = 3;
pub type watch_adc_reference_voltage = ::core::ffi::c_uint;
extern "C" {
    #[doc = " @brief Selects the reference voltage to use for analog readings. Default is ADC_REFERENCE_VCC.\n @param reference One of ADC_REFERENCE_VCC, ADC_REFERENCE_VCC_DIV1POINT6, ADC_REFERENCE_VCC_DIV2\n                  or ADC_REFERENCE_INTREF.\n @details In order to turn an analog voltage into a 16-bit integer, the ADC needs to compare the\n          measured voltage to a reference point. For example, if you were powering the watch with\n          VCC == 3.0V and you had two 10K resistors connected in series from 3V to GND, you could\n          expect to get 3 volts when you measure the top of the voltage divider, 0 volts at the\n          bottom, and 1.5 volts in the middle. If you read these values uising a reference voltage\n          of ADC_REFERENCE_VCC, the top value would be about 65535, the bottom about 0, and the\n          middle about 32768. However! If we used ADC_REFERENCE_VCC_DIV2 as our reference, we would\n          expect to get 65535 both at the top and the middle, because the largest value the ADC can\n          measure in this configutation is 1.5V (VCC / 2).\n\n          By changing the reference voltage from ADC_REFERENCE_VCC to ADC_REFERENCE_VCC_DIV1POINT6\n          or ADC_REFERENCE_VCC_DIV2, you can get more resolution when measuring small voltages (i.e.\n          a phototransistor circuit in low light).\n\n          There is also a special reference voltage called ADC_REFERENCE_INTREF. The SAM L22's\n          Supply Controller provides a selectable voltage reference (by default, 1.024 V) that you\n          can select as a reference voltage for ADC conversions. Unlike the three references we\n          talked about in the last paragraph, this reference voltage does not depend on VCC, which\n          makes it very useful for measuring the battery voltage (since you can't really compare\n          VCC to itself). You can change the INTREF voltage to 2.048 or 4.096 V by poking at the\n          supply controller's VREF register, but the watch library does not support this use case."]
    pub fn watch_set_analog_reference_voltage(reference: watch_adc_reference_voltage);
}
extern "C" {
    #[doc = " @brief Returns the voltage of the VCC supply in millivolts (i.e. 3000 mV == 3.0 V). If running on\n        a coin cell, this will be the battery voltage.\n @details Unlike other ADC functions, this function does not return a raw value from the ADC, but\n          rather scales it to an actual number of millivolts. This is because the ADC doesn't let\n          us measure VCC per se; it instead lets us measure VCC / 4, and we choose to measure it\n          against the internal reference voltage of 1.024 V. In short, the ADC gives us a number\n          that's complicated to deal with, so we just turn it into a useful number for you :)\n @note This function depends on INTREF being 1.024V. If you have changed it by poking at the supply\n       controller's VREF.SEL bits, this function will return inaccurate values."]
    pub fn watch_get_vcc_voltage() -> u16;
}
extern "C" {
    #[doc = " @brief Disables the analog circuitry on the selected pin.\n @param pin One of pins A0-A4."]
    pub fn watch_disable_analog_input(pin: u8);
}
extern "C" {
    #[doc = " @brief Disables the ADC peripheral.\n @note You will need to call watch_enable_adc to re-enable the ADC peripheral. When you do, it will\n       have the default settings of 16 samples and 1 measurement cycle; if you customized these\n       parameters, you will need to set them up again."]
    pub fn watch_disable_adc();
}
extern "C" {
    #[doc = " @addtogroup gpio Digital Input and Output\n @brief This section covers functions related to general-purpose input and output signals.\n/\n/// @{\n/** @brief Configures the selected pin for digital input.\n @param pin The pin that you wish to act as an input."]
    pub fn watch_enable_digital_input(pin: u8);
}
extern "C" {
    #[doc = " @brief Disables any digital input, along with any pull-up or pull-down configuration.\n @param pin The pin that you wish to disable."]
    pub fn watch_disable_digital_input(pin: u8);
}
extern "C" {
    #[doc = " @brief Enables a pull-up resistor on the selected pin.\n @param pin The pin that you wish to configure."]
    pub fn watch_enable_pull_up(pin: u8);
}
extern "C" {
    #[doc = " @brief Enables a pull-down resistor on the selected pin.\n @param pin The pin that you wish to configure."]
    pub fn watch_enable_pull_down(pin: u8);
}
extern "C" {
    #[doc = " @brief Gets the level of the selected pin.\n @param pin The pin whose value you wish to read.\n @return true if the pin was logic high; otherwise, false."]
    pub fn watch_get_pin_level(pin: u8) -> bool;
}
extern "C" {
    #[doc = " @brief Configures the selected pin for digital output.\n @param pin The pin that you wish to act as an output."]
    pub fn watch_enable_digital_output(pin: u8);
}
extern "C" {
    #[doc = " @brief Disables digital output on the selected pin.\n @param pin The pin that you wish disable."]
    pub fn watch_disable_digital_output(pin: u8);
}
extern "C" {
    #[doc = " @brief Sets the level of the selected pin.\n @param pin The pin whose value you wish to set.\n @param level The level you wish to set: true for high, false for low."]
    pub fn watch_set_pin_level(pin: u8, level: bool);
}
extern "C" {
    #[doc = " @addtogroup i2c I2C Controller Driver\n @brief This section covers functions related to the SAM L22's built-I2C driver, including\n        configuring the I2C bus, putting values directly on the bus and reading data from\n        registers on I2C devices.\n/\n/// @{\n/** @brief Enables the I2C peripheral. Call this before attempting to interface with I2C devices."]
    pub fn watch_enable_i2c();
}
extern "C" {
    #[doc = " @brief Disables the I2C peripheral."]
    pub fn watch_disable_i2c();
}
extern "C" {
    #[doc = " @brief Sends a series of values to a device on the I2C bus.\n @param addr The address of the device you wish to talk to.\n @param buf A series of unsigned bytes; the data you wish to transmit.\n @param length The number of bytes in buf that you wish to send."]
    pub fn watch_i2c_send(addr: i16, buf: *mut u8, length: u16);
}
extern "C" {
    #[doc = " @brief Receives a series of values from a device on the I2C bus.\n @param addr The address of the device you wish to hear from.\n @param buf Storage for the incoming bytes; on return, it will contain the received data.\n @param length The number of bytes that you wish to receive."]
    pub fn watch_i2c_receive(addr: i16, buf: *mut u8, length: u16);
}
extern "C" {
    #[doc = " @brief Writes a byte to a register in an I2C device.\n @param addr The address of the device you wish to address.\n @param reg The register on the device that you wish to set.\n @param data The value that you wish to set the register to."]
    pub fn watch_i2c_write8(addr: i16, reg: u8, data: u8);
}
extern "C" {
    #[doc = " @brief Reads a byte from a register in an I2C device.\n @param addr The address of the device you wish to address.\n @param reg The register on the device that you wish to read.\n @return An unsigned byte representing the value of the register that was read."]
    pub fn watch_i2c_read8(addr: i16, reg: u8) -> u8;
}
extern "C" {
    #[doc = " @brief Reads an unsigned little-endian word from a register in an I2C device.\n @param addr The address of the device you wish to address.\n @param reg The register on the device that you wish to read.\n @return An unsigned word representing the value of the register that was read.\n @note This reads two bytes into the word in bus order. If the device returns\nthe LSB first and then the MSB, you can use this value as returned.\nIf the device returns the data in big-endian order or uses some other\nkind of fancy bit packing, you may need to shuffle some bits around."]
    pub fn watch_i2c_read16(addr: i16, reg: u8) -> u16;
}
extern "C" {
    #[doc = " @brief Reads three bytes as an unsigned little-endian int from a register in an I2C device.\n @param addr The address of the device you wish to address.\n @param reg The register on the device that you wish to read.\n @return An unsigned word representing the value of the register that was read.\n @note This reads three bytes into the word in bus order. If the device returns\nthese bytes LSB first, you can use this value as returned. If there is a\nsign bit, the device returns the data in big-endian order, or it uses some\nother kind of fancy bit packing, you may need to shuffle some bits around."]
    pub fn watch_i2c_read24(addr: i16, reg: u8) -> u32;
}
extern "C" {
    #[doc = " @brief Reads an unsigned little-endian int from a register in an I2C device.\n @param addr The address of the device you wish to address.\n @param reg The register on the device that you wish to read.\n @return An unsigned word representing the value of the register that was read.\n @note This reads three bytes into the word in bus order. If the device returns\nthese bytes LSB first, you can use this value as returned. If the device\nreturns the data in big-endian order, or it uses some other kind of fancy\nbit packing, you may need to shuffle some bits around."]
    pub fn watch_i2c_read32(addr: i16, reg: u8) -> u32;
}
extern "C" {
    #[doc = " @addtogroup spi SPI Controller Driver\n @brief This section covers functions related to the SAM L22's built-in SPI driver, including\n        configuring the SPI bus and writing to / reading from devices.\n/\n/// @{\n/** @brief Enables the SPI peripheral. Call this before attempting to interface with SPI devices."]
    pub fn watch_enable_spi();
}
extern "C" {
    #[doc = " @brief Disables the SPI peripheral."]
    pub fn watch_disable_spi();
}
extern "C" {
    #[doc = " @brief Writes a series of values to a device on the SPI bus.\n @param buf A series of unsigned bytes; the data you wish to transmit.\n @param length The number of bytes in buf that you wish to send.\n @note This function does not manage the chip select pin (usually A3)."]
    pub fn watch_spi_write(buf: *const u8, length: u16) -> bool;
}
extern "C" {
    #[doc = " @brief Reads a series of values from a device on the SPI bus.\n @param buf Storage for the incoming bytes; on return, it will contain the received data.\n @param length The number of bytes that you wish to receive.\n @note This function does not manage the chip select pin (usually A3)."]
    pub fn watch_spi_read(buf: *mut u8, length: u16) -> bool;
}
extern "C" {
    #[doc = " @brief Reads a series of values from a device on the SPI bus.\n @param data_out Storage for outgoing bytes.\n @param data_in Storage for incoming bytes.\n @param length The number of bytes to transfer.\n @note This function does not manage the chip select pin (usually A3)."]
    pub fn watch_spi_transfer(data_out: *const u8, data_in: *mut u8, length: u16) -> bool;
}
extern "C" {
    #[doc = " @brief Initializes the debug UART.\n @param tx_pin The pin the watch will use to transmit, or 0 for a receive-only UART.\n               If specified, must be either A2 or A4.\n @param rx_pin The pin the watch will use to receive, or 0 for a transmit-only UART.\n               If specified, must be A1, A2, A3 or A4 (pin A0 cannot receive UART data).\n @param baud The baud rate for the UART. A typical value is 19200."]
    pub fn watch_enable_uart(tx_pin: u8, rx_pin: u8, baud: u32);
}
extern "C" {
    #[doc = " @brief Transmits a string of bytes on the UART's TX pin.\n @param s A null-terminated string containing the bytes you wish to transmit."]
    pub fn watch_uart_puts(s: *mut ::core::ffi::c_char);
}
extern "C" {
    #[doc = " @brief Receives a single byte from the UART's RX pin.\n @return the received byte.\n @note This method will block until a byte is received!"]
    pub fn watch_uart_getc() -> ::core::ffi::c_char;
}
extern "C" {
    #[doc = " @addtogroup storage Flash Storage\n @brief This section covers functions related to the SAM L22's 8 kilobyte EEPROM emulation area.\n @details The SAM L22 inside Sensor Watch has a 256 kilobyte Flash memory array that can be\n          programmed with whatever data we want. We use most of it to store the bootloader\n          and the application code that runs on your wrist. The bootloader region is read-only,\n          and the main application area is only writable by the bootloader (when you drag new\n          code onto the WATCHBOOT drive). However! there's also a special 8 kilobyte region\n          at the end of the Flash memory called the EEPROM Emulation Area. This EEPROM emulation\n          area can be written or erased while the main Flash array is being read. This makes it\n          super easy to work with, and useful for storing a small amount of non-volatile data that\n          persists across reboots, even when power is lost.\n          The functions in this section are very basic, and only cover reading and writing data\n          in this area. The region is laid out as 32 rows consisting of 4 pages of 64 bytes.\n          32*4*64 = 8192 bytes. The area can be written one page at a time, but it can only be\n          erased one row at a time. You can read at arbitrary word-aligned offsets within a row.\n\n                 ┌──────────────┬──────────────┬──────────────┬──────────────┐\n          Row 0  │   64 bytes   │   64 bytes   │   64 bytes   │   64 bytes   │\n                 ├──────────────┼──────────────┼──────────────┼──────────────┤\n          Row 1  │   64 bytes   │   64 bytes   │   64 bytes   │   64 bytes   │\n                 ├──────────────┼──────────────┼──────────────┼──────────────┤\n           ...   │              │              │              │              │\n                 ├──────────────┼──────────────┼──────────────┼──────────────┤\n          Row 31 │   64 bytes   │   64 bytes   │   64 bytes   │   64 bytes   │\n                 └──────────────┴──────────────┴──────────────┴──────────────┘\n/\n/// @{\n/** @brief Reads a range of bytes from the storage area.\n @param row The row you want to read.\n @param offset The offset from the beginning of the row.\n @param buffer A buffer of at least `size` bytes.\n @param size The number of bytes you wish to read."]
    pub fn watch_storage_read(row: u32, offset: u32, buffer: *mut u8, size: u32) -> bool;
}
extern "C" {
    #[doc = " @brief Writes bytes to a page in the storage area. Note that the row should already be erased before writing.\n @param row The row containing the page you want to write.\n @param offset The offset from the beginning of the row. Must be a multiple of 64.\n @param buffer The buffer containing the bytes you wish to set.\n @param size The number of bytes you wish to write."]
    pub fn watch_storage_write(row: u32, offset: u32, buffer: *const u8, size: u32) -> bool;
}
extern "C" {
    #[doc = " @brief Erases a row in the storage area, setting all its bytes to 0xFF.\n @param row The row you want to erase."]
    pub fn watch_storage_erase(row: u32) -> bool;
}
extern "C" {
    #[doc = " @brief Waits for any pending writes to complete."]
    pub fn watch_storage_sync() -> bool;
}
extern "C" {
    pub static mut btn_alarm_callback: ext_irq_cb_t;
}
extern "C" {
    pub static mut a2_callback: ext_irq_cb_t;
}
extern "C" {
    pub static mut a4_callback: ext_irq_cb_t;
}
extern "C" {
    #[doc = " @brief Registers a callback on one of the RTC's external wake pins, which can wake the device\n        from Sleep, Deep Sleep and BACKUP modes (but see warning re: BACKUP mode).\n @param pin Either pin BTN_ALARM, A2, or A4. These are the three external wake pins. If the pin\n            is BTN_ALARM, this function also enables an internal pull down on that pin.\n @param callback The callback to be called if this pin triggers outside of BACKUP mode. If this is\n                 NULL, no callback will be called even in normal modes, but the interrupt will\n                 still be enabled so that it can wake the device.\n @param level The level you wish to scan for: true for rising, false for falling. Note that you\n              cannot scan for both rising and falling edges like you can with the external interrupt\n              pins; with the external wake interrupt, you can only get one or the other.\n @note When in ACTIVE, STANDBY and Sleep / Deep sleep modes, this will function much like a standard\n       external interrupt situation: these pins will wake the device, and your callback will be\n       called. However, if the device enters BACKUP mode and one of these pins wakes the device, your\n       callback WILL NOT be called, as the device is basically waking from reset at that point.\n @warning As of the current SAM L22 silicon revision (rev B), the BTN_ALARM pin cannot wake the\n          device from BACKUP mode. You can still use this function to register a BTN_ALARM interrupt\n          in normal or deep sleep mode, but to wake from BACKUP, you will need to use pin A2 or A4."]
    pub fn watch_register_extwake_callback(pin: u8, callback: ext_irq_cb_t, level: bool);
}
extern "C" {
    #[doc = " @brief Unregisters the RTC interrupt on one of the EXTWAKE pins. This will prevent a value change on\n        one of these pins from waking the device.\n @param pin Either pin BTN_ALARM, A2, or A4. If the pin is BTN_ALARM, this function DOES NOT disable\n            the internal pull down on that pin."]
    pub fn watch_disable_extwake_interrupt(pin: u8);
}
extern "C" {
    #[doc = " @brief Stores data in one of the RTC's backup registers, which retain their data in BACKUP mode.\n @param data An unsigned 32 bit integer with the data you wish to store.\n @param reg A register from 0-7."]
    pub fn watch_store_backup_data(data: u32, reg: u8);
}
extern "C" {
    #[doc = " @brief Gets 32 bits of data from the RTC's BACKUP register.\n @param reg A register from 0-7.\n @return An unsigned 32 bit integer with the from the backup register."]
    pub fn watch_get_backup_data(reg: u8) -> u32;
}
extern "C" {
    #[doc = " @brief enters Sleep Mode by disabling all pins and peripherals except the RTC and the LCD.\n @details This sleep mode is not the lowest power mode available, but it has the benefit of allowing you\n          to display a message to the user while asleep. You can also set an alarm interrupt to wake at a\n          configfurable interval (every minute, hour or day) to update the display. You can wake from this\n          mode by pressing the ALARM button, if you registered an extwake callback on the ALARM button.\n          Also note that when your app wakes from this sleep mode, your app_setup method will be called\n          again, since this function will have disabled things you set up there.\n\n          Note that to wake from either the ALARM button, the A2 interrupt or the A4 interrupt, you\n          must first configure this by calling watch_register_extwake_callback.\n\n          Power consumption depends on temperature, but as a rough estimate, this mode will consume:\n           * 6.0 ~ 7.5µA while at normal room temperatures\n           * 9.5µA while worn on a wrist (temperature ≈ 31° C)"]
    pub fn watch_enter_sleep_mode();
}
extern "C" {
    #[doc = " @brief enters Deep Sleep Mode by disabling all pins and peripherals except the RTC.\n @details Short of BACKUP mode, this is the lowest power mode you can enter while retaining your\n          application state (and the ability to wake with the alarm button). Just note that the display\n          will be completely off, so you should document to the user of your application that they will\n          need to press the alarm button to wake the device, or use a sensor board with support for\n          an external wake pin.\n\n          All notes from watch_enter_sleep_mode apply here, except for power consumption. You can estimate\n          the power consumption of this mode to be on the order of 4µA at room temperature."]
    pub fn watch_enter_deep_sleep_mode();
}
extern "C" {
    #[doc = " @brief Enters the SAM L22's lowest-power mode, BACKUP.\n @details This function does some housekeeping before entering BACKUP mode. It first disables all pins\n          and peripherals except for the RTC, and disables the tick interrupt (since that would wake\n          us up from BACKUP mode). Once again, if you wish to wake from the A2 or the A4 interrupt,\n          you must first configure this by calling watch_register_extwake_callback.\n @note If you have a callback set for an external wake interrupt, it will be called if triggered while\n       in ACTIVE, STANDBY, Sleep and Deep Sleep modes, but it *will not be called* when waking from\n       BACKUP mode. Waking from backup is effectively like waking from reset, except that your\n       @ref app_wake_from_backup function will be called.\n @warning On current revisions of the SAM L22 silicon, the ALARM_BTN pin (PA02 RTC/IN2) cannot wake\n          the device from deep sleep mode. There is an errata note (Reference: 15010) that says that\n          due to a silicon bug, RTC/IN2 is not functional in BACKUP. As a result, you should not call\n          this function unless you have a device on the nine-pin connector with an external interrupt\n          on pin A2 or A4 (i.e. an accelerometer with an interrupt pin)."]
    pub fn watch_enter_backup_mode();
}
extern "C" {
    #[doc = " Called by main.c while setting up the app. You should not call this from your app."]
    pub fn _watch_init();
}
extern "C" {
    #[doc = " Initializes the real-time clock peripheral."]
    pub fn _watch_rtc_init();
}
extern "C" {
    #[doc = " Called by buzzer and LED setup functions. You should not call this from your app."]
    pub fn _watch_enable_tcc();
}
extern "C" {
    #[doc = " Called by buzzer and LED teardown functions. You should not call this from your app."]
    pub fn _watch_disable_tcc();
}
extern "C" {
    #[doc = " Called by main.c if plugged in to USB. You should not call this from your app."]
    pub fn _watch_enable_usb();
}
extern "C" {
    pub fn _write(
        file: ::core::ffi::c_int,
        ptr: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn _read(
        file: ::core::ffi::c_int,
        ptr: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    #[doc = " @brief Returns true if either the buzzer or the LED driver is enabled.\n @details Both the buzzer and the LED use the TCC peripheral to drive their behavior. This function returns true if that\n          peripheral is enabled. You can use this function to determine whether you need to call the watch_disable_leds or\n          or watch_enable_buzzer functions before using these peripherals."]
    pub fn watch_is_buzzer_or_led_enabled() -> bool;
}
extern "C" {
    #[doc = " @brief Returns true if USB is enabled."]
    pub fn watch_is_usb_enabled() -> bool;
}
extern "C" {
    #[doc = " @brief Resets in the UF2 bootloader mode"]
    pub fn watch_reset_to_bootloader();
}
extern "C" {
    #[doc = " @brief Reads up to len bytes from the USB serial.\n @param file ignored, you can pass in 0\n @param ptr pointer to a buffer of at least len bytes\n @param len the number of bytes you wish to read, max 256.\n @return The number of bytes read, or zero if no bytes were read."]
    pub fn read(
        file: ::core::ffi::c_int,
        ptr: *mut ::core::ffi::c_char,
        len: ::core::ffi::c_int,
    ) -> ::core::ffi::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union movement_settings_t {
    pub bit: movement_settings_t__bindgen_ty_1,
    pub reg: u32,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct movement_settings_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
}
#[test]
fn bindgen_test_layout_movement_settings_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<movement_settings_t__bindgen_ty_1>(),
        5usize,
        concat!("Size of: ", stringify!(movement_settings_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<movement_settings_t__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(movement_settings_t__bindgen_ty_1)
        )
    );
}
impl movement_settings_t__bindgen_ty_1 {
    #[inline]
    pub fn button_should_sound(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_button_should_sound(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn to_interval(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_to_interval(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn to_always(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_to_always(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn le_interval(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_le_interval(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn led_duration(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_led_duration(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn led_red_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_led_red_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn led_green_color(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_led_green_color(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn time_zone(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_time_zone(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn clock_mode_24h(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_clock_mode_24h(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn use_imperial_units(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_use_imperial_units(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn alarm_enabled(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_alarm_enabled(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(33usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(33usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        button_should_sound: bool,
        to_interval: u8,
        to_always: bool,
        le_interval: u8,
        led_duration: u8,
        led_red_color: u8,
        led_green_color: u8,
        time_zone: u8,
        clock_mode_24h: bool,
        use_imperial_units: bool,
        alarm_enabled: bool,
        reserved: u8,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let button_should_sound: u8 = unsafe { ::core::mem::transmute(button_should_sound) };
            button_should_sound as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let to_interval: u8 = unsafe { ::core::mem::transmute(to_interval) };
            to_interval as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let to_always: u8 = unsafe { ::core::mem::transmute(to_always) };
            to_always as u64
        });
        __bindgen_bitfield_unit.set(4usize, 3u8, {
            let le_interval: u8 = unsafe { ::core::mem::transmute(le_interval) };
            le_interval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let led_duration: u8 = unsafe { ::core::mem::transmute(led_duration) };
            led_duration as u64
        });
        __bindgen_bitfield_unit.set(10usize, 4u8, {
            let led_red_color: u8 = unsafe { ::core::mem::transmute(led_red_color) };
            led_red_color as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let led_green_color: u8 = unsafe { ::core::mem::transmute(led_green_color) };
            led_green_color as u64
        });
        __bindgen_bitfield_unit.set(24usize, 6u8, {
            let time_zone: u8 = unsafe { ::core::mem::transmute(time_zone) };
            time_zone as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let clock_mode_24h: u8 = unsafe { ::core::mem::transmute(clock_mode_24h) };
            clock_mode_24h as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let use_imperial_units: u8 = unsafe { ::core::mem::transmute(use_imperial_units) };
            use_imperial_units as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let alarm_enabled: u8 = unsafe { ::core::mem::transmute(alarm_enabled) };
            alarm_enabled as u64
        });
        __bindgen_bitfield_unit.set(33usize, 6u8, {
            let reserved: u8 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_movement_settings_t() {
    const UNINIT: ::core::mem::MaybeUninit<movement_settings_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<movement_settings_t>(),
        8usize,
        concat!("Size of: ", stringify!(movement_settings_t))
    );
    assert_eq!(
        ::core::mem::align_of::<movement_settings_t>(),
        4usize,
        concat!("Alignment of ", stringify!(movement_settings_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_settings_t),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_settings_t),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union movement_location_t {
    pub bit: movement_location_t__bindgen_ty_1,
    pub reg: u32,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct movement_location_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_movement_location_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<movement_location_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(movement_location_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<movement_location_t__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(movement_location_t__bindgen_ty_1)
        )
    );
}
impl movement_location_t__bindgen_ty_1 {
    #[inline]
    pub fn latitude(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_latitude(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn longitude(&self) -> i16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u16) }
    }
    #[inline]
    pub fn set_longitude(&mut self, val: i16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(latitude: i16, longitude: i16) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let latitude: u16 = unsafe { ::core::mem::transmute(latitude) };
            latitude as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let longitude: u16 = unsafe { ::core::mem::transmute(longitude) };
            longitude as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_movement_location_t() {
    const UNINIT: ::core::mem::MaybeUninit<movement_location_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<movement_location_t>(),
        4usize,
        concat!("Size of: ", stringify!(movement_location_t))
    );
    assert_eq!(
        ::core::mem::align_of::<movement_location_t>(),
        4usize,
        concat!("Alignment of ", stringify!(movement_location_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_location_t),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_location_t),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union movement_birthdate_t {
    pub bit: movement_birthdate_t__bindgen_ty_1,
    pub reg: u32,
}
#[repr(C)]
#[repr(align(2))]
#[derive(Debug, Copy, Clone)]
pub struct movement_birthdate_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 5usize]>,
}
#[test]
fn bindgen_test_layout_movement_birthdate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<movement_birthdate_t__bindgen_ty_1>(),
        6usize,
        concat!("Size of: ", stringify!(movement_birthdate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<movement_birthdate_t__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(movement_birthdate_t__bindgen_ty_1)
        )
    );
}
impl movement_birthdate_t__bindgen_ty_1 {
    #[inline]
    pub fn year(&self) -> u16 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_year(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn month(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_month(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn day(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_day(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn hour(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 5u8) as u8) }
    }
    #[inline]
    pub fn set_hour(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn minute(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(32usize, 6u8) as u8) }
    }
    #[inline]
    pub fn set_minute(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(32usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        year: u16,
        month: u8,
        day: u8,
        hour: u8,
        minute: u8,
    ) -> __BindgenBitfieldUnit<[u8; 5usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 5usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let year: u16 = unsafe { ::core::mem::transmute(year) };
            year as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let month: u8 = unsafe { ::core::mem::transmute(month) };
            month as u64
        });
        __bindgen_bitfield_unit.set(16usize, 5u8, {
            let day: u8 = unsafe { ::core::mem::transmute(day) };
            day as u64
        });
        __bindgen_bitfield_unit.set(24usize, 5u8, {
            let hour: u8 = unsafe { ::core::mem::transmute(hour) };
            hour as u64
        });
        __bindgen_bitfield_unit.set(32usize, 6u8, {
            let minute: u8 = unsafe { ::core::mem::transmute(minute) };
            minute as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_movement_birthdate_t() {
    const UNINIT: ::core::mem::MaybeUninit<movement_birthdate_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<movement_birthdate_t>(),
        8usize,
        concat!("Size of: ", stringify!(movement_birthdate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<movement_birthdate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(movement_birthdate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_birthdate_t),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_birthdate_t),
            "::",
            stringify!(reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union movement_reserved_t {
    pub bit: movement_reserved_t__bindgen_ty_1,
    pub reg: u32,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct movement_reserved_t__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_movement_reserved_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<movement_reserved_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(movement_reserved_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<movement_reserved_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(movement_reserved_t__bindgen_ty_1)
        )
    );
}
impl movement_reserved_t__bindgen_ty_1 {
    #[inline]
    pub fn reserved(&self) -> u32 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 32u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 32u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(reserved: u32) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 32u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_movement_reserved_t() {
    const UNINIT: ::core::mem::MaybeUninit<movement_reserved_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<movement_reserved_t>(),
        4usize,
        concat!("Size of: ", stringify!(movement_reserved_t))
    );
    assert_eq!(
        ::core::mem::align_of::<movement_reserved_t>(),
        4usize,
        concat!("Alignment of ", stringify!(movement_reserved_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_reserved_t),
            "::",
            stringify!(bit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_reserved_t),
            "::",
            stringify!(reg)
        )
    );
}
pub const movement_event_type_t_EVENT_NONE: movement_event_type_t = 0;
pub const movement_event_type_t_EVENT_ACTIVATE: movement_event_type_t = 1;
pub const movement_event_type_t_EVENT_TICK: movement_event_type_t = 2;
pub const movement_event_type_t_EVENT_LOW_ENERGY_UPDATE: movement_event_type_t = 3;
pub const movement_event_type_t_EVENT_BACKGROUND_TASK: movement_event_type_t = 4;
pub const movement_event_type_t_EVENT_TIMEOUT: movement_event_type_t = 5;
pub const movement_event_type_t_EVENT_LIGHT_BUTTON_DOWN: movement_event_type_t = 6;
pub const movement_event_type_t_EVENT_LIGHT_BUTTON_UP: movement_event_type_t = 7;
pub const movement_event_type_t_EVENT_LIGHT_LONG_PRESS: movement_event_type_t = 8;
pub const movement_event_type_t_EVENT_LIGHT_LONG_UP: movement_event_type_t = 9;
pub const movement_event_type_t_EVENT_MODE_BUTTON_DOWN: movement_event_type_t = 10;
pub const movement_event_type_t_EVENT_MODE_BUTTON_UP: movement_event_type_t = 11;
pub const movement_event_type_t_EVENT_MODE_LONG_PRESS: movement_event_type_t = 12;
pub const movement_event_type_t_EVENT_MODE_LONG_UP: movement_event_type_t = 13;
pub const movement_event_type_t_EVENT_ALARM_BUTTON_DOWN: movement_event_type_t = 14;
pub const movement_event_type_t_EVENT_ALARM_BUTTON_UP: movement_event_type_t = 15;
pub const movement_event_type_t_EVENT_ALARM_LONG_PRESS: movement_event_type_t = 16;
pub const movement_event_type_t_EVENT_ALARM_LONG_UP: movement_event_type_t = 17;
pub type movement_event_type_t = ::core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct movement_event_t {
    pub event_type: u8,
    pub subsecond: u8,
}
#[test]
fn bindgen_test_layout_movement_event_t() {
    const UNINIT: ::core::mem::MaybeUninit<movement_event_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<movement_event_t>(),
        2usize,
        concat!("Size of: ", stringify!(movement_event_t))
    );
    assert_eq!(
        ::core::mem::align_of::<movement_event_t>(),
        1usize,
        concat!("Alignment of ", stringify!(movement_event_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_event_t),
            "::",
            stringify!(event_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subsecond) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_event_t),
            "::",
            stringify!(subsecond)
        )
    );
}
extern "C" {
    pub static movement_timezone_offsets: [i16; 0usize];
}
extern "C" {
    pub static movement_valid_position_0_chars: [::core::ffi::c_char; 0usize];
}
extern "C" {
    pub static movement_valid_position_1_chars: [::core::ffi::c_char; 0usize];
}
#[doc = " @brief Perform setup for your watch face.\n @details It's tempting to say this is 'one-time' setup, but technically this function is called more than\n          once. When the watch first boots, this function is called with a NULL context_ptr, indicating\n          that it is the first run. At this time you should set context_ptr to something non-NULL if you\n          need to keep track of any state in your watch face. If your watch face requires any other setup,\n          like configuring a pin mode or a peripheral, you may want to do that here too.\n          This function will be called again after waking from sleep mode, since sleep mode disables all\n          of the device's pins and peripherals.\n @param settings A pointer to the global Movement settings. You can use this to inform how you present your\n                 display to the user (i.e. taking into account whether they have silenced the buttons, or if\n                 they prefer 12 or 24-hour mode). You can also change these settings if you like.\n @param watch_face_index The index of this watch face in the global array of watch faces; 0 is the first face,\n                         1 is the second, etc. You may stash this value in your context if you wish to reference\n                         it later; your watch face's index is set at launch and will not change.\n @param context_ptr A pointer to a pointer; at first invocation, this value will be NULL, and you can set it\n                    to any value you like. Subsequent invocations will pass in whatever value you previously\n                    set. You may want to check if this is NULL and if so, allocate some space to store any\n                    data required for your watch face.\n"]
pub type watch_face_setup = ::core::option::Option<
    unsafe extern "C" fn(
        settings: *mut movement_settings_t,
        watch_face_index: u8,
        context_ptr: *mut *mut ::core::ffi::c_void,
    ),
>;
#[doc = " @brief Prepare to go on-screen.\n @details This function is called just before your watch enters the foreground. If your watch face has any\n          segments or text that is always displayed, you may want to set that here. In addition, if your\n          watch face depends on data from a peripheral (like an I2C sensor), you will likely want to enable\n          that peripheral here. In addition, if your watch face requires an update frequncy other than 1 Hz,\n          you may want to request that here using the movement_request_tick_frequency function.\n @param settings A pointer to the global Movement settings. @see watch_face_setup.\n @param context A pointer to your watch face's context. @see watch_face_setup.\n"]
pub type watch_face_activate = ::core::option::Option<
    unsafe extern "C" fn(settings: *mut movement_settings_t, context: *mut ::core::ffi::c_void),
>;
#[doc = " @brief Handle events and update the display.\n @details This function is called in response to an event. You should set up a switch statement that handles,\n          at the very least, the EVENT_TICK and EVENT_MODE_BUTTON_UP event types. The tick event happens once\n          per second (or more frequently if you asked for a faster tick with movement_request_tick_frequency).\n          The mode button up event occurs when the user presses the MODE button. **Your loop function SHOULD\n          call the movement_move_to_next_face function in response to this event.** If you have a good reason\n          to override this behavior (e.g. your user interface requires all three buttons), your watch face MUST\n          call the movement_move_to_next_face function in response to the EVENT_MODE_LONG_PRESS event. If you\n          fail to do this, the user will become stuck on your watch face.\n @param event A struct containing information about the event, including its type. @see movement_event_type_t\n              for a list of all possible event types.\n @param settings A pointer to the global Movement settings. @see watch_face_setup.\n @param context A pointer to your application's context. @see watch_face_setup.\n @return true if your watch face is prepared for the system to enter STANDBY mode; false to keep the system awake.\n         You should almost always return true.\n         Note that this return value has no effect if your loop function has called movement_move_to_next_face\n         or movement_move_to_face; in that case, your watch face will resign immediately, and the next watch\n         face will make the decision on entering standby mode.\n @note There are two event types that require some extra thought:\nThe EVENT_LOW_ENERGY_UPDATE event type is a special case. If you are in the foreground when the watch\ngoes into low energy mode, you will receive this tick once a minute (at the top of the minute) so that\nyou can update the screen. Great! But! When you receive this event, all pins and peripherals other than\nthe RTC will have been disabled to save energy. If your display is clock or calendar oriented, this is\nfine. But if your display requires polling an I2C sensor or reading a value with the ADC, you won't be\nable to do this. You should either display the name of the watch face in response to the low power tick,\nor ensure that you resign before low power mode triggers, (e.g. by calling movement_move_to_face(0)).\nYour watch face MUST NOT wake up peripherals in response to a low power tick.** The purpose of this\nmode is to consume as little energy as possible during the (potentially long) intervals when it's\nunlikely the user is wearing or looking at the watch.\nEVENT_BACKGROUND_TASK is also a special case. @see watch_face_wants_background_task for details."]
pub type watch_face_loop = ::core::option::Option<
    unsafe extern "C" fn(
        event: movement_event_t,
        settings: *mut movement_settings_t,
        context: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[doc = " @brief Prepare to go off-screen.\n @details This function is called before your watch face enters the background. If you requested a tick\n          frequency other than the standard 1 Hz, **you must call movement_request_tick_frequency(1) here**\n          to reset to 1 Hz. You should also disable any peripherals you enabled when you entered the foreground.\n @param settings A pointer to the global Movement settings. @see watch_face_setup.\n @param context A pointer to your application's context. @see watch_face_setup."]
pub type watch_face_resign = ::core::option::Option<
    unsafe extern "C" fn(settings: *mut movement_settings_t, context: *mut ::core::ffi::c_void),
>;
#[doc = " @brief OPTIONAL. Request an opportunity to run a background task.\n @details Most apps will not need this function, but if you provide it, Movement will call it once per minute in\n          both active and low power modes, regardless of whether your app is in the foreground. You can check the\n          current time to determine whether you require a background task. If you return true here, Movement will\n          immediately call your loop function with an EVENT_BACKGROUND_TASK event. Note that it will not call your\n          activate or deactivate functions, since you are not going on screen.\n\n          Examples of background tasks:\n           - Wake and play a sound when an alarm or timer has been triggered.\n           - Check the state of an RTC interrupt pin or the timestamp of an RTC interrupt event.\n           - Log a data point from a sensor, and then return to sleep mode.\n\n          Guidelines for background tasks:\n           - Assume all peripherals and pins other than the RTC will be disabled when you get an EVENT_BACKGROUND_TASK.\n           - Even if your background task involves only the RTC peripheral, try to request background tasks sparingly.\n           - If your background task involves an external pin or peripheral, request background tasks no more than once per hour.\n           - If you need to enable a pin or a peripheral to perform your task, return it to its original state afterwards.\n\n @param settings A pointer to the global Movement settings. @see watch_face_setup.\n @param context A pointer to your application's context. @see watch_face_setup.\n @return true to request a background task; false otherwise."]
pub type watch_face_wants_background_task = ::core::option::Option<
    unsafe extern "C" fn(
        settings: *mut movement_settings_t,
        context: *mut ::core::ffi::c_void,
    ) -> bool,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct watch_face_t {
    pub setup: watch_face_setup,
    pub activate: watch_face_activate,
    pub loop_: watch_face_loop,
    pub resign: watch_face_resign,
    pub wants_background_task: watch_face_wants_background_task,
}
#[test]
fn bindgen_test_layout_watch_face_t() {
    const UNINIT: ::core::mem::MaybeUninit<watch_face_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<watch_face_t>(),
        40usize,
        concat!("Size of: ", stringify!(watch_face_t))
    );
    assert_eq!(
        ::core::mem::align_of::<watch_face_t>(),
        8usize,
        concat!("Alignment of ", stringify!(watch_face_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(watch_face_t),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).activate) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(watch_face_t),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).loop_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(watch_face_t),
            "::",
            stringify!(loop_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).resign) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(watch_face_t),
            "::",
            stringify!(resign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wants_background_task) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(watch_face_t),
            "::",
            stringify!(wants_background_task)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct movement_state_t {
    pub settings: movement_settings_t,
    pub current_watch_face: i16,
    pub next_watch_face: i16,
    pub watch_face_changed: bool,
    pub fast_tick_enabled: bool,
    pub fast_ticks: i16,
    pub light_ticks: i16,
    pub alarm_ticks: i16,
    pub is_buzzing: bool,
    pub alarm_note: BuzzerNote,
    pub light_down_timestamp: u16,
    pub mode_down_timestamp: u16,
    pub alarm_down_timestamp: u16,
    pub needs_background_tasks_handled: bool,
    pub has_scheduled_background_task: bool,
    pub needs_wake: bool,
    pub le_mode_ticks: i32,
    pub timeout_ticks: i16,
    pub tick_frequency: u8,
    pub last_second: u8,
    pub subsecond: u8,
    pub next_available_backup_register: u8,
}
#[test]
fn bindgen_test_layout_movement_state_t() {
    const UNINIT: ::core::mem::MaybeUninit<movement_state_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<movement_state_t>(),
        52usize,
        concat!("Size of: ", stringify!(movement_state_t))
    );
    assert_eq!(
        ::core::mem::align_of::<movement_state_t>(),
        4usize,
        concat!("Alignment of ", stringify!(movement_state_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).settings) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(settings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_watch_face) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(current_watch_face)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_watch_face) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(next_watch_face)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).watch_face_changed) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(watch_face_changed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fast_tick_enabled) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(fast_tick_enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fast_ticks) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(fast_ticks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).light_ticks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(light_ticks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alarm_ticks) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(alarm_ticks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_buzzing) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(is_buzzing)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alarm_note) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(alarm_note)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).light_down_timestamp) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(light_down_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode_down_timestamp) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(mode_down_timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alarm_down_timestamp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(alarm_down_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).needs_background_tasks_handled) as usize - ptr as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(needs_background_tasks_handled)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).has_scheduled_background_task) as usize - ptr as usize
        },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(has_scheduled_background_task)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).needs_wake) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(needs_wake)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).le_mode_ticks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(le_mode_ticks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout_ticks) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(timeout_ticks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tick_frequency) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(tick_frequency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_second) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(last_second)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).subsecond) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(subsecond)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).next_available_backup_register) as usize - ptr as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(movement_state_t),
            "::",
            stringify!(next_available_backup_register)
        )
    );
}
extern "C" {
    pub fn movement_move_to_face(watch_face_index: u8);
}
extern "C" {
    pub fn movement_move_to_next_face();
}
extern "C" {
    pub fn movement_default_loop_handler(
        event: movement_event_t,
        settings: *mut movement_settings_t,
    ) -> bool;
}
extern "C" {
    pub fn movement_illuminate_led();
}
extern "C" {
    pub fn movement_request_tick_frequency(freq: u8);
}
extern "C" {
    pub fn movement_schedule_background_task(date_time: watch_date_time);
}
extern "C" {
    pub fn movement_cancel_background_task();
}
extern "C" {
    pub fn movement_schedule_background_task_for_face(
        watch_face_index: u8,
        date_time: watch_date_time,
    );
}
extern "C" {
    pub fn movement_cancel_background_task_for_face(watch_face_index: u8);
}
extern "C" {
    pub fn movement_request_wake();
}
extern "C" {
    pub fn movement_play_signal();
}
extern "C" {
    pub fn movement_play_alarm();
}
extern "C" {
    pub fn movement_play_alarm_beeps(rounds: u8, alarm_note: BuzzerNote);
}
extern "C" {
    pub fn movement_claim_backup_register() -> u8;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::core::ffi::c_uint,
    pub fp_offset: ::core::ffi::c_uint,
    pub overflow_arg_area: *mut ::core::ffi::c_void,
    pub reg_save_area: *mut ::core::ffi::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::core::mem::MaybeUninit<__va_list_tag> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _spi_m_sync_hpl_interface {
    pub _address: u8,
}
