<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Sensor Watch: Real-Time Clock</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Sensor Watch<span id="projectnumber">&#160;0.0.2</span>
   </div>
   <div id="projectbrief">A board replacement for the classic Casio F-91W wristwatch, powered by a Microchip SAM L22 microcontroller.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="doc-content">
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Real-Time Clock</div></div>
</div><!--header-->
<div class="contents">

<p>This section covers functions related to the SAM L22's real-time clock peripheral, including date, time and alarm functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionwatch__date__time.html">watch_date_time</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9bc41a324472cc3c2f39679849e3a4e9" id="r_ga9bc41a324472cc3c2f39679849e3a4e9"><td class="memItemLeft" align="right" valign="top"><a id="ga9bc41a324472cc3c2f39679849e3a4e9" name="ga9bc41a324472cc3c2f39679849e3a4e9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>WATCH_RTC_REFERENCE_YEAR</b>&#160;&#160;&#160;(2020)</td></tr>
<tr class="separator:ga9bc41a324472cc3c2f39679849e3a4e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga13ec58aba1f66d56e859e6b64dc0b47a" id="r_ga13ec58aba1f66d56e859e6b64dc0b47a"><td class="memItemLeft" align="right" valign="top"><a id="ga13ec58aba1f66d56e859e6b64dc0b47a" name="ga13ec58aba1f66d56e859e6b64dc0b47a"></a>
typedef enum watch_rtc_alarm_match&#160;</td><td class="memItemRight" valign="bottom"><b>watch_rtc_alarm_match</b></td></tr>
<tr class="separator:ga13ec58aba1f66d56e859e6b64dc0b47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa0a79638c3b14ee82798ca18fbb2014a" id="r_gaa0a79638c3b14ee82798ca18fbb2014a"><td class="memItemLeft" align="right" valign="top"><a id="gaa0a79638c3b14ee82798ca18fbb2014a" name="gaa0a79638c3b14ee82798ca18fbb2014a"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>watch_rtc_alarm_match</b> { <b>ALARM_MATCH_DISABLED</b> = 0
, <b>ALARM_MATCH_SS</b>
, <b>ALARM_MATCH_MMSS</b>
, <b>ALARM_MATCH_HHMMSS</b>
 }</td></tr>
<tr class="separator:gaa0a79638c3b14ee82798ca18fbb2014a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3ac65a314540ae8b7be5b9015785d565" id="r_ga3ac65a314540ae8b7be5b9015785d565"><td class="memItemLeft" align="right" valign="top"><a id="ga3ac65a314540ae8b7be5b9015785d565" name="ga3ac65a314540ae8b7be5b9015785d565"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_watch_rtc_is_enabled</b> (void)</td></tr>
<tr class="memdesc:ga3ac65a314540ae8b7be5b9015785d565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by main.c to check if the RTC is enabled. You may call this function, but outside of app_init, it should always return true. <br /></td></tr>
<tr class="separator:ga3ac65a314540ae8b7be5b9015785d565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfcc143db9d71e95c2d2dc45732ab4e5" id="r_gadfcc143db9d71e95c2d2dc45732ab4e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadfcc143db9d71e95c2d2dc45732ab4e5">watch_rtc_set_date_time</a> (<a class="el" href="unionwatch__date__time.html">watch_date_time</a> date_time)</td></tr>
<tr class="memdesc:gadfcc143db9d71e95c2d2dc45732ab4e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the date and time.  <br /></td></tr>
<tr class="separator:gadfcc143db9d71e95c2d2dc45732ab4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga166b575563d39a0061dc9a28ad0309a7" id="r_ga166b575563d39a0061dc9a28ad0309a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="unionwatch__date__time.html">watch_date_time</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga166b575563d39a0061dc9a28ad0309a7">watch_rtc_get_date_time</a> (void)</td></tr>
<tr class="memdesc:ga166b575563d39a0061dc9a28ad0309a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the date and time.  <br /></td></tr>
<tr class="separator:ga166b575563d39a0061dc9a28ad0309a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5220d0d7f542a0bc6c9bef176d6d83b" id="r_gaa5220d0d7f542a0bc6c9bef176d6d83b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaa5220d0d7f542a0bc6c9bef176d6d83b">watch_rtc_register_alarm_callback</a> (ext_irq_cb_t callback, <a class="el" href="unionwatch__date__time.html">watch_date_time</a> alarm_time, watch_rtc_alarm_match mask)</td></tr>
<tr class="memdesc:gaa5220d0d7f542a0bc6c9bef176d6d83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers an alarm callback that will be called when the RTC time matches the target time, as masked by the provided mask.  <br /></td></tr>
<tr class="separator:gaa5220d0d7f542a0bc6c9bef176d6d83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga836cade77c24e93c06bf534eaded55bf" id="r_ga836cade77c24e93c06bf534eaded55bf"><td class="memItemLeft" align="right" valign="top"><a id="ga836cade77c24e93c06bf534eaded55bf" name="ga836cade77c24e93c06bf534eaded55bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>watch_rtc_disable_alarm_callback</b> (void)</td></tr>
<tr class="memdesc:ga836cade77c24e93c06bf534eaded55bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the alarm callback. <br /></td></tr>
<tr class="separator:ga836cade77c24e93c06bf534eaded55bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga969ea57aaedf13d4950edbeacff3f2be" id="r_ga969ea57aaedf13d4950edbeacff3f2be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga969ea57aaedf13d4950edbeacff3f2be">watch_rtc_register_tick_callback</a> (ext_irq_cb_t callback)</td></tr>
<tr class="memdesc:ga969ea57aaedf13d4950edbeacff3f2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a "tick" callback that will be called once per second.  <br /></td></tr>
<tr class="separator:ga969ea57aaedf13d4950edbeacff3f2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685f2afb2e99dfebf8d2ef058a5bc19d" id="r_ga685f2afb2e99dfebf8d2ef058a5bc19d"><td class="memItemLeft" align="right" valign="top"><a id="ga685f2afb2e99dfebf8d2ef058a5bc19d" name="ga685f2afb2e99dfebf8d2ef058a5bc19d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>watch_rtc_disable_tick_callback</b> (void)</td></tr>
<tr class="memdesc:ga685f2afb2e99dfebf8d2ef058a5bc19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the tick callback for the given period. <br /></td></tr>
<tr class="separator:ga685f2afb2e99dfebf8d2ef058a5bc19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb4e67aa0062e39eaff465aeebc24f53" id="r_gaeb4e67aa0062e39eaff465aeebc24f53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gaeb4e67aa0062e39eaff465aeebc24f53">watch_rtc_register_periodic_callback</a> (ext_irq_cb_t callback, uint8_t frequency)</td></tr>
<tr class="memdesc:gaeb4e67aa0062e39eaff465aeebc24f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a callback that will be called at a configurable period.  <br /></td></tr>
<tr class="separator:gaeb4e67aa0062e39eaff465aeebc24f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e025485bb50e1c93abd4a185447705f" id="r_ga4e025485bb50e1c93abd4a185447705f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga4e025485bb50e1c93abd4a185447705f">watch_rtc_disable_periodic_callback</a> (uint8_t frequency)</td></tr>
<tr class="memdesc:ga4e025485bb50e1c93abd4a185447705f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the tick callback for the given period.  <br /></td></tr>
<tr class="separator:ga4e025485bb50e1c93abd4a185447705f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadccd826da474b5fe24cac8d8edc88ae6" id="r_gadccd826da474b5fe24cac8d8edc88ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#gadccd826da474b5fe24cac8d8edc88ae6">watch_rtc_disable_matching_periodic_callbacks</a> (uint8_t mask)</td></tr>
<tr class="memdesc:gadccd826da474b5fe24cac8d8edc88ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables tick callbacks for the given periods (as a bitmask).  <br /></td></tr>
<tr class="separator:gadccd826da474b5fe24cac8d8edc88ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0150da34307ba61e44f1a00aa90a7f0f" id="r_ga0150da34307ba61e44f1a00aa90a7f0f"><td class="memItemLeft" align="right" valign="top"><a id="ga0150da34307ba61e44f1a00aa90a7f0f" name="ga0150da34307ba61e44f1a00aa90a7f0f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>watch_rtc_disable_all_periodic_callbacks</b> (void)</td></tr>
<tr class="memdesc:ga0150da34307ba61e44f1a00aa90a7f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables all periodic callbacks, including the once-per-second tick callback. <br /></td></tr>
<tr class="separator:ga0150da34307ba61e44f1a00aa90a7f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab379cf9c5231e18a5525a4138359d386" id="r_gab379cf9c5231e18a5525a4138359d386"><td class="memItemLeft" align="right" valign="top"><a id="gab379cf9c5231e18a5525a4138359d386" name="gab379cf9c5231e18a5525a4138359d386"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>watch_rtc_enable</b> (bool en)</td></tr>
<tr class="memdesc:gab379cf9c5231e18a5525a4138359d386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable RTC while in-flight. This is quite dangerous operation, so we repeat writing register twice. Used when temporarily pausing RTC when adjusting subsecond, which are not accessible otherwise. <br /></td></tr>
<tr class="separator:gab379cf9c5231e18a5525a4138359d386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf90cba54229b673627303ebd29c664db" id="r_gaf90cba54229b673627303ebd29c664db"><td class="memItemLeft" align="right" valign="top"><a id="gaf90cba54229b673627303ebd29c664db" name="gaf90cba54229b673627303ebd29c664db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>watch_rtc_freqcorr_write</b> (int16_t value, int16_t sign)</td></tr>
<tr class="memdesc:gaf90cba54229b673627303ebd29c664db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjusts frequency correction in single register write. Not waiting for syncronisation to save power - if you won't write new correction value in the same ~millisecond - will not cause issue. <br /></td></tr>
<tr class="separator:gaf90cba54229b673627303ebd29c664db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This section covers functions related to the SAM L22's real-time clock peripheral, including date, time and alarm functions. </p>
<p>The real-time clock is the only peripheral that main.c enables for you. It is the cornerstone of low power operation on the watch, and it is required for several key functions that we assume will be available, namely the wake from BACKUP mode and the callback on the ALARM button. It is also required for the operation of the 1 Hz tick interrupt, which you will most likely use to wake from STANDBY mode. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gadccd826da474b5fe24cac8d8edc88ae6" name="gadccd826da474b5fe24cac8d8edc88ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadccd826da474b5fe24cac8d8edc88ae6">&#9670;&#160;</a></span>watch_rtc_disable_matching_periodic_callbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watch_rtc_disable_matching_periodic_callbacks </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>mask</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables tick callbacks for the given periods (as a bitmask). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>The frequencies of tick callbacks you wish to disable, in Hz. The 128 Hz callback is 0b1, the 64 Hz callback is 0b10, the 32 Hz callback is 0b100, etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4e025485bb50e1c93abd4a185447705f" name="ga4e025485bb50e1c93abd4a185447705f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e025485bb50e1c93abd4a185447705f">&#9670;&#160;</a></span>watch_rtc_disable_periodic_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watch_rtc_disable_periodic_callback </td>
          <td>(</td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>frequency</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the tick callback for the given period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency</td><td>The frequency of the tick you wish to disable, in Hz. <b>Must be a power of 2</b>, from 1 to 128. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga166b575563d39a0061dc9a28ad0309a7" name="ga166b575563d39a0061dc9a28ad0309a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga166b575563d39a0061dc9a28ad0309a7">&#9670;&#160;</a></span>watch_rtc_get_date_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="unionwatch__date__time.html">watch_date_time</a> watch_rtc_get_date_time </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the date and time. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="unionwatch__date__time.html">watch_date_time</a> with the current date and time, with a year value from 0-63 representing 2020-2083. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#gadfcc143db9d71e95c2d2dc45732ab4e5" title="Sets the date and time.">watch_rtc_set_date_time</a> for notes about how the year is stored. </dd></dl>

</div>
</div>
<a id="gaa5220d0d7f542a0bc6c9bef176d6d83b" name="gaa5220d0d7f542a0bc6c9bef176d6d83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5220d0d7f542a0bc6c9bef176d6d83b">&#9670;&#160;</a></span>watch_rtc_register_alarm_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watch_rtc_register_alarm_callback </td>
          <td>(</td>
          <td class="paramtype">ext_irq_cb_t</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionwatch__date__time.html">watch_date_time</a></td>          <td class="paramname"><span class="paramname"><em>alarm_time</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">watch_rtc_alarm_match</td>          <td class="paramname"><span class="paramname"><em>mask</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers an alarm callback that will be called when the RTC time matches the target time, as masked by the provided mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function you wish to have called when the alarm fires. If this value is NULL, the alarm interrupt will still be enabled, but no callback function will be called. </td></tr>
    <tr><td class="paramname">alarm_time</td><td>The time that you wish to match. The date is currently ignored. </td></tr>
    <tr><td class="paramname">mask</td><td>One of the values in watch_rtc_alarm_match indicating which values to check.</td></tr>
  </table>
  </dd>
</dl>
<p>The alarm interrupt is a versatile tool for scheduling events in the future, especially since it can wake the device from all sleep modes. The key to its versatility is the mask parameter. Suppose we set an alarm for midnight, 00:00:00.</p><ul>
<li>if mask is ALARM_MATCH_SS, the alarm will fire every minute when the clock ticks to seconds == 0.</li>
<li>with ALARM_MATCH_MMSS, the alarm will once an hour, at the top of each hour.</li>
<li>with ALARM_MATCH_HHMMSS, the alarm will fire at midnight every day. In theory the SAM L22's alarm function can match on days, months and even years, but I have not had success with this yet; as such, I am omitting these options for now. </li>
</ul>

</div>
</div>
<a id="gaeb4e67aa0062e39eaff465aeebc24f53" name="gaeb4e67aa0062e39eaff465aeebc24f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb4e67aa0062e39eaff465aeebc24f53">&#9670;&#160;</a></span>watch_rtc_register_periodic_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watch_rtc_register_periodic_callback </td>
          <td>(</td>
          <td class="paramtype">ext_irq_cb_t</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t</td>          <td class="paramname"><span class="paramname"><em>frequency</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a callback that will be called at a configurable period. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function you wish to have called at the specified period. If you pass in NULL, the periodic interrupt will still be enabled, but no callback function will be called. </td></tr>
    <tr><td class="paramname">frequency</td><td>The frequency of the tick in Hz. <b>Must be a power of 2</b>, from 1 to 128 inclusive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A 1 Hz tick (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ga969ea57aaedf13d4950edbeacff3f2be" title="Registers a &quot;tick&quot; callback that will be called once per second.">watch_rtc_register_tick_callback</a>) is suitable for most applications, in that it gives you a chance to update the display once a second — an ideal update rate for a watch! If however you are displaying a value (such as an accelerometer output) that updates more frequently than once per second, you may want to tick at 16 or 32 Hz to update the screen more quickly. Just remember that the more frequent the tick, the more power your <a class="el" href="group__app.html" title="This section covers the functions that you will implement in your app.c file when designing a Sensor ...">Application Framework</a> will consume. Ideally you should enable the fast tick only when the user requires it (i.e. in response to an input event), and move back to the slow tick after some time.</dd></dl>
<p>Also note that the RTC peripheral does not have sub-second resolution, so even if you set a 2 or 4 Hz interval, the system will not have any way of telling you where you are within a given second; watch_rtc_get_date_time will return the exact same timestamp until the second ticks over. </p>

</div>
</div>
<a id="ga969ea57aaedf13d4950edbeacff3f2be" name="ga969ea57aaedf13d4950edbeacff3f2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga969ea57aaedf13d4950edbeacff3f2be">&#9670;&#160;</a></span>watch_rtc_register_tick_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watch_rtc_register_tick_callback </td>
          <td>(</td>
          <td class="paramtype">ext_irq_cb_t</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a "tick" callback that will be called once per second. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The function you wish to have called when the clock ticks. If you pass in NULL, the tick interrupt will still be enabled, but no callback function will be called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this is equivalent to calling watch_rtc_register_periodic_callback with a frequency of 1. It can be disabled with either <a class="el" href="#ga685f2afb2e99dfebf8d2ef058a5bc19d" title="Disables the tick callback for the given period.">watch_rtc_disable_tick_callback()</a> or watch_rtc_disable_periodic_callback(1), and will also be disabled when watch_rtc_disable_all_periodic_callbacks is called. </dd></dl>

</div>
</div>
<a id="gadfcc143db9d71e95c2d2dc45732ab4e5" name="gadfcc143db9d71e95c2d2dc45732ab4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfcc143db9d71e95c2d2dc45732ab4e5">&#9670;&#160;</a></span>watch_rtc_set_date_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void watch_rtc_set_date_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="unionwatch__date__time.html">watch_date_time</a></td>          <td class="paramname"><span class="paramname"><em>date_time</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the date and time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">date_time</td><td>The date and time you wish to set, with a year value from 0-63 representing 2020-2083. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The SAM L22 stores the year as six bits representing a value from 0 to 63. It treats this as a year offset from a reference year, which must be a leap year. Since 2020 was a leap year, and it allows useful dates through 2083, it is assumed that watch apps will use 2020 as the reference year; thus 1 means 2021, 2 means 2022, etc. <b>You will be responsible for handling this offset in your code</b>, if the calendar year is needed for timestamp calculation logic or display purposes. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
